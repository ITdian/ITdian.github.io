<!DOCTYPE html>
<html >
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="IT点彼岸" />



<meta name="description" content="一:面向对象的相关概念01 对象是什么? 什么都是对象.对象是具体的事物 思考:电脑(分类) 人 桌子 狗 猫 老师 同学  这些都不是对象,只是一种类别. 02 对象的描述信息(静态特征) 张三: 身高 体重 身份证号码 专业 班级 名字 李四家的狗: 颜色 年龄 名字 03 对象的行为特征(动态的行为) 张三: 吃饭 睡觉 打游戏 跑步 李四家的狗: 吃饭 叫 睡觉 打架 流口水 04 js的">
<meta property="og:type" content="article">
<meta property="og:title" content="first">
<meta property="og:url" content="http://yoursite.com/2017/05/23/面向对象day2/index.html">
<meta property="og:site_name" content="IT点彼岸的博客">
<meta property="og:description" content="一:面向对象的相关概念01 对象是什么? 什么都是对象.对象是具体的事物 思考:电脑(分类) 人 桌子 狗 猫 老师 同学  这些都不是对象,只是一种类别. 02 对象的描述信息(静态特征) 张三: 身高 体重 身份证号码 专业 班级 名字 李四家的狗: 颜色 年龄 名字 03 对象的行为特征(动态的行为) 张三: 吃饭 睡觉 打游戏 跑步 李四家的狗: 吃饭 叫 睡觉 打架 流口水 04 js的">
<meta property="og:updated_time" content="2017-05-23T14:08:15.461Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="first">
<meta name="twitter:description" content="一:面向对象的相关概念01 对象是什么? 什么都是对象.对象是具体的事物 思考:电脑(分类) 人 桌子 狗 猫 老师 同学  这些都不是对象,只是一种类别. 02 对象的描述信息(静态特征) 张三: 身高 体重 身份证号码 专业 班级 名字 李四家的狗: 颜色 年龄 名字 03 对象的行为特征(动态的行为) 张三: 吃饭 睡觉 打游戏 跑步 李四家的狗: 吃饭 叫 睡觉 打架 流口水 04 js的">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="IT点彼岸的博客" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>first | IT点彼岸的博客</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: undefined
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/time.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">IT点彼岸</a></h1>
        </hgroup>

        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="/itdian666@163.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">IT点彼岸</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/time.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">IT点彼岸</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="/itdian666@163.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-面向对象day2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/05/23/面向对象day2/" class="article-date">
      <time datetime="2017-05-23T14:06:10.000Z" itemprop="datePublished">2017-05-23</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      first
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="一-面向对象的相关概念"><a href="#一-面向对象的相关概念" class="headerlink" title="一:面向对象的相关概念"></a>一:面向对象的相关概念</h3><pre><code>01 对象是什么?
什么都是对象.对象是具体的事物
思考:电脑(分类) 人 桌子 狗 猫 老师 同学  这些都不是对象,只是一种类别.
02 对象的描述信息(静态特征)
张三: 身高 体重 身份证号码 专业 班级 名字
李四家的狗: 颜色 年龄 名字
03 对象的行为特征(动态的行为)
张三: 吃饭 睡觉 打游戏 跑步
李四家的狗: 吃饭 叫 睡觉 打架 流口水
04 js的对象
对象定义:键值对(key-value)的集合 | 属性(方法)的工具包|对遍历和函数的封装.
对象的组成:
    静态特征:属性(定义在对象中变量)    
    动态行为:方法(定义在对象中函数)
05 补充:
面向对象和面向过程并没有孰优孰劣,解决问题的时候需要看实际的情况(选取正确的方案)
为什么要使用面向对象的方式来写代码? 方便 节省 复用性高
&lt;script&gt;
var dog = {
    name:&quot;旺财&quot;,
    age:13,
    color:&quot;紫色&quot;,
    eat: function () {
        console.log(&quot;eat&quot;);
    },
    sleepp:function (){
        console.log(&quot;sleep&quot;);
    },
    run:function () {
        console.log(&quot;run&quot;);
    }
}

console.log(dog);   //object  { dog对象的东西 }
dog.eat();      //eat
dog.run();      //run


&lt;/script&gt;
</code></pre><h3 id="二-创建并设置标签样式的小案例-面向过程"><a href="#二-创建并设置标签样式的小案例-面向过程" class="headerlink" title="二:创建并设置标签样式的小案例(面向过程)"></a>二:创建并设置标签样式的小案例(面向过程)</h3><pre><code>div&lt;我是第$个div标签&gt;*6

p&lt;我是第$个p标签&gt;*3    

 冗余度(重复的代码很多)
&lt;script&gt;
//01 获得页面中所有的div标签
var divs = document.getElementsByTagName(&quot;div&quot;);
//02 遍历所有的标签并且设置
for (var i = 0; i &lt; divs.length; i++) {
    divs[i].style.border = &quot;1px solid red&quot;;
}

//03 获得页面中所有p标签
var ps = document.getElementsByTagName(&apos;p&apos;);
//04 遍历所有的标签并且设置
for (var i = 0; i &lt; ps.length; i++) {
    ps[i].style.border = &apos;1px solid red&apos;;
}
&lt;/script&gt;
</code></pre><h3 id="三-函数封装-面向过程"><a href="#三-函数封装-面向过程" class="headerlink" title="三:函数封装(面向过程):"></a>三:函数封装(面向过程):</h3><pre><code>&lt;div&gt;我是第1个div标签&lt;/div&gt;
&lt;div&gt;我是第2个div标签&lt;/div&gt;
&lt;div&gt;我是第3个div标签&lt;/div&gt;
&lt;div&gt;我是第4个div标签&lt;/div&gt;
&lt;div&gt;我是第5个div标签&lt;/div&gt;
&lt;div&gt;我是第6个div标签&lt;/div&gt;

需求    :设置页面中所有div标签的样式（边框） border = &quot;1px solid red&quot;;
 设置页面中所有的p标签的样式（边框） border = &quot;1px solid red&quot;;
&lt;p&gt;我是第1个p便签&lt;/p&gt;
&lt;p&gt;我是第2个p便签&lt;/p&gt;
&lt;p&gt;我是第3个p便签&lt;/p&gt;
&lt;script&gt;

//把固定不变的部分抽取作为函数体
//把改变的部分抽取作为函数的参数
function getEle(tagName) {
    return document.getElementsByTagName(tagName);
}
function setBorder(eles) {
    for (var i = 0; i &lt; eles.length; i++) {
        eles[i].style.border = &quot;1px solid red&quot;;
    }
}

var divs = getEle(&quot;div&quot;);
var ps = getEle(&quot;p&quot;);
setBorder(divs);
setBorder(ps);

&lt;/script&gt;
</code></pre><h3 id="四-函数封装-面向对象"><a href="#四-函数封装-面向对象" class="headerlink" title="四:函数封装(面向对象)"></a>四:函数封装(面向对象)</h3><pre><code>&lt;div&gt;我是第1个div标签&lt;/div&gt;
&lt;div&gt;我是第2个div标签&lt;/div&gt;
&lt;div&gt;我是第3个div标签&lt;/div&gt;
&lt;div&gt;我是第4个div标签&lt;/div&gt;
&lt;div&gt;我是第5个div标签&lt;/div&gt;    
&lt;div&gt;我是第6个div标签&lt;/div&gt;

需求:设置页面中所有div标签的样式（边框） border = &quot;1px solid red&quot;;
 设置页面中所有的p标签的样式（边框） border = &quot;1px solid red&quot;;
&lt;p&gt;我是第1个p便签&lt;/p&gt;
&lt;p&gt;我是第2个p便签&lt;/p&gt;
&lt;p&gt;我是第3个p便签&lt;/p&gt;

冗余度 （重复的内容）

&lt;script&gt;

//把固定不变的部分抽取作为函数体
//把改变的部分抽取作为函数的参数
//使用对象来进行封装
var XMGQuery =  {
    getEle:{
        tagName:function (tagName) {
            return document.getElementsByTagName(tagName);
        },
        id:function (id) {
            return document.getElementById(id);
        },
        calssName:function (classNmae) {
            return document.getElementsByClassName(classNmae);
        },
    },
    setStyle:{
        setBorder:function (eles) {
            for (var i = 0; i &lt; eles.length; i++) {
                eles[i].style.border = &quot;1px solid red&quot;;
            }
        },
        setColor:function (eles) {
            for (var i = 0; i &lt; eles.length; i++) {
                eles[i].style.color = &quot;red&quot;;
            }
        }
    }
}
XMGQuery.setStyle.setBorder(XMGQuery.getEle.tagName(&quot;div&quot;));
XMGQuery.setStyle.setBorder(XMGQuery.getEle.tagName(&quot;p&quot;));

&lt;/script&gt;
</code></pre><h3 id="六-面向对象的三大特效"><a href="#六-面向对象的三大特效" class="headerlink" title="六:面向对象的三大特效"></a>六:面向对象的三大特效</h3><pre><code>01封装
好处:复用(!),降低冗余度,更有利于模块化编程,能够为变量函数提供更多的保护.使用对象来封装变量和函数
02 继承
现实中继承：一般是子女获得父母的财富|资源的一种方式。
代码中继承：子类获得父类的属性和方法（成员）的一种方式。
js中的继承:
严格来说js并不是一门面向对象的语言(类-class),支持面向对象而已.
js中的继承是一个对象获得另外一个对象的属性和方法的一种行为.
术语:
父类
子类
超类
js中
父对象 - 子对象
a---b(属性|方法)
实现方法
001 属性拷贝(浅拷贝)
002 属性拷贝(深拷贝)
003 原型式继承
004 原型链继承
005 借用构造函数
006 组合继承
02.多态
多种形态
特点:对于同一个操作(指令),不同的对象表现出不同的反应,隐藏不同
观点:js天生就是一门支持多态的语法.
好处:灵活
&lt;script&gt;
var obj = {
    name :&quot;旺财&quot;,
    age:20,
    friends:[&quot;乌拉乌拉&quot;,&quot;扒拉扒拉&quot;,&quot;哗啦哗啦&quot;],
    showName:function () {
        console.log(this.name);
    }
};

var o = {};

//o 对象需要获得obj对象的属性和方法  o 子对象 obj父对象
 //    o.name = obj.name;
    //    o.age = obj.age;
//    o.showName = obj.showName;
//    o.showName();

for(var k in obj)
{
   // o.k = obj.k;
    o[k] = obj[k];
}
console.log(o);

//如果是引用类型，那么会有共享的问题
obj.friends.push(&quot;无力无力&quot;);
console.log(o);
</code></pre><h3 id="七-创建对象的几种方式"><a href="#七-创建对象的几种方式" class="headerlink" title="七:创建对象的几种方式"></a>七:创建对象的几种方式</h3><pre><code>01 字面量
02 内置构造函数 new Object()|new Date()
03 简单工厂函数创建
04 自定义构造函数
05 Object.create()
&lt;script&gt;

//书（对象）
//属性：书名 | 作者 | 出版社 | 价格
//方法：deslog 打印书本的介绍信息

var book1 = {
    name:&quot;西游记&quot;,
    author:&quot;吴承恩&quot;,
    press:&quot;中华书局&quot;,
    price:&quot;0.1&quot;,
    desLog:function () {
        console.log(&quot;书名：&quot; + this.name + &quot; 作者：&quot; + this.author);
    }
}
book1.desLog();

//需求：（图书管理员）
var book2 = {
    name:&quot;悟空传&quot;,
    author:&quot;今何在&quot;,
    press:&quot;湖南文艺出版社&quot;,
    price:&quot;28.00&quot;,
    desLog:function () {
        console.log(&quot;书名：&quot; + this.name + &quot; 作者：&quot; + this.author);
    }
}

var book3 = {
    name:&quot;什么是批判&quot;,
    author:&quot;福柯&quot;,
    press:&quot;北京大学出版社&quot;,
    price:&quot;58.00&quot;,
    desLog:function () {
        console.log(&quot;书名：&quot; + this.name + &quot; 作者：&quot; + this.author);
    }
}
console.log(book3);

//......

//问题:如果要创建多个同类型的对象，那么代码冗余度太高（重复的代码），复用性（差）
&lt;/script&gt;

2  内置构造函数
Array Date Object Function String Number Boolean
使用方法:new 构造函数(参数)
&lt;script&gt;
var date = new Date();
var array = new Array();
var string = new String(&quot;demo&quot;);

&lt;/script&gt;
&lt;script&gt;

var book = new Object();
book.name = &quot;三国演义&quot;;
book.author = &quot;罗贯中&quot;;
book.press = &quot;中华书局&quot;;
book.desLog = function () {
    console.log(this.name + this.author);
}
book.desLog();

var book2 = new Object();
book2.name = &quot;红楼梦&quot;;
book2.author = &quot;曹公子&quot;;
book2.press = &quot;中华书局&quot;;
book2.desLog = function () {
    console.log(this.name + this.author);
}
book2.desLog();

//问题：同字面量方式一样
&lt;/script&gt;

3. 简单工厂函数创建对象

&lt;script&gt;

//01 提供一个函数
function createBook(name,author) {
    //02 创建空的对象
    var book = new Object();
    //03 设置对象的属性和方法
    book.name = name;
    book.author = author;
    book.desLog = function () {
        console.log(this.name + this.author);
    }
    //04 把创建的对象返回
    return book;
}

var book1 = createBook(&quot;悟空传&quot;,&quot;孙悟空&quot;);
var book2 = createBook(&quot;红楼梦&quot;,&quot;曹公子&quot;);
console.log(book1);
console.log(book2);
console.log( book1 ==  book2);
book1.desLog();
book2.desLog();
&lt;/script&gt;


4.自定义构造函数
&lt;script&gt;

//01 提供一个函数
function createBook(name,author) {
    //02 创建空的对象
    var book = new Object();
    //03 设置对象的属性和方法
    book.name = name;
    book.author = author;
    book.desLog = function () {
        console.log(this.name + this.author);
    }
    //04 把创建的对象返回
    return book;
}

var book1 = createBook(&quot;悟空传&quot;,&quot;孙悟空&quot;);
var book2 = createBook(&quot;红楼梦&quot;,&quot;曹公子&quot;);
console.log(book1);
console.log(book2);
console.log(book1 == book2);
book1.desLog();
book2.desLog();

//问题（特点）：对象类型判断的问题
function createPerson(name,age) {
    var obj = new Object();
    obj.name = name;
    obj.age = age;
    return obj;
}
function createDog(name,age) {
    var obj = new Object();
    obj.name = name;
    obj.age = age;
    return obj;
}

//创建人对象
var obj1 = createPerson(&quot;张三&quot;,23);
var obj2 = createDog(&quot;李四&quot;,10);

//obj1 --- obj2
console.log(obj1);
console.log(obj2);

//无法区分对象的类型  ：obj1（人）obj2(狗)

&lt;/script&gt;

自定义构造函数创建对象
术语：
构造函数 ==  普通函数，人为的区分（首字母大写）
构造函数：主要做初始化的处理（设置属性和方法）
new :    创建对象（{}）
var obj = new Object();
核心过程
01 提供一个构造函数（普通函数首字母大写）
02 通过this指针来设置对象的属性和方法
03 使用new 构造函数（）创建对象

内部的实现过程：
01 提供构造函数
02 创建一个空的对象{} ===&gt; Object
03 设置新创建对象的原型对象为构造函数的原型对象
04 设置新创建对象的构造函数为当前的构造函数
05 把新创建的对象赋值给this
06 通过this设置属性和方法
07 默认在最后把新创建的对象返回

返回值
01 如果没有显示的return,那么默认在最后把新创建的对象返回
02 如果显示的return,那么结果得看具体的情况：
    001 返回的是值类型的  忽略（返回新对象）
    002 返回的是引用类型的 return的对象会把新创建的对象覆盖
&lt;script&gt;
function Dog(name) {
    this.name = name;
    return [1,2,3];
}

var dog1 = new Dog(&quot;旺财&quot;);
console.log(dog1);
&lt;/script&gt;
&lt;script&gt;
function CreatePerson(name,age) {
    //创建对象{}
    //把新的对象赋值给this
    this.name = name;
    this.age = age;
    this.showName = function () {
        console.log(this.name);
    }
    //默认把新创建的对象返回
}
var p1 = new CreatePerson(&quot;张三&quot;,99);
var p2 = new CreatePerson(&quot;李四&quot;,0.9);
p1.showName();
p2.showName();
&lt;/script&gt;

&lt;script&gt;
function Person(name,age) {
    //01 创建对象{}
    //var o = new Object();    o的构造函数 --- Object
    //02 把新的对象赋值给this
    //this = o;
    //03 设置新创建对象的原型对象为构造函数的原型对象
    //o.__proto__ = Person.prototype;
    //04 设置新创建对象的构造函数为当前的构造函数
    //o.constructor = Person;

    this.name = name;
    this.age = age;
    this.showName = function () {
        console.log(this.name);
    }
    //默认把新创建的对象返回
    //return this;
}
var p1 = new Person(&quot;张三&quot;,99);
var p2 = new Person(&quot;李四&quot;,0.9);
p1.showName();
p2.showName();
&lt;/script&gt;

构造函数和普通函数没有什么区别，人为的进行区分（首字母大写）
构造函数在调用的时候需要和new一起使用
普通函数直接调用
</code></pre><h3 id="八-构造函数注意事项01"><a href="#八-构造函数注意事项01" class="headerlink" title="八:构造函数注意事项01"></a>八:构造函数注意事项01</h3><pre><code>01 函数传值
02 instanceOf
03 对象到底是什么类型(构造器属性)
&lt;script&gt;
function Person(name,doSomething) {
    this.name = name;
    this.doSomething = doSomething;
}

var p1 = new Person(&quot;张三&quot;,function () {
    console.log(&quot;流口水&quot;);
});
var p2 = new Person(&quot;李四&quot;,function () {
    console.log(&quot;咬人&quot;);
});
p1.doSomething();
p2.doSomething();
&lt;/script&gt;
&lt;script&gt;
function Book(name) {
    this.name = name;
}
function Dog(name) {
    this.name = name;
}

var obj1 = new Book(&quot;阿黄&quot;);
var obj2 = new Dog(&quot;阿黄&quot;);

//可以区分对象的类型
//instanceOf  检查某个对象是否是指定构造函数的实例对象（是不是它创建出来）
console.log(obj1 instanceof Book);   //true
console.log(obj2 instanceof Book);  //false
console.log(obj1 instanceof Dog);   //false
console.log(obj2 instanceof Dog);   //true
console.log(obj1 instanceof Object);  //true Object是所有对象的基本对象

//var obj3 = {};
//obj3 是什么类型？
console.log(obj1.constructor);      //Book
console.log(obj2.constructor);      //Dog
&lt;/script&gt;
</code></pre><h3 id="九-函数注意事项02"><a href="#九-函数注意事项02" class="headerlink" title="九:函数注意事项02"></a>九:函数注意事项02</h3><pre><code>01 构造函数必须要和new一起使用，如果直接调用那么无法创建对象
02 this的指向
如果是使用new 构造函数（）调用，那么this---&gt;具体的对象
如果是以普通函数的方式调用吧，那么this ----&gt;window

03 this的丢失问题

&lt;script&gt;

window.name = &quot;xxxxxx&quot;;
var obj = {
    name:&quot;张三&quot;,
    showName:function () {
        console.log(this.name);
    }
}

obj.showName();             //对象.方法  以对象方法的形式来调用函数 （this ---&gt;对象）

var func = obj.showName;
func();   //undefined ? 空  window.name //以普通函数的方式来调用函数（this ---&gt;window）


&lt;/script&gt;
&lt;!--&lt;script&gt;--&gt;
&lt;!--function Dog(name) {--&gt;
    &lt;!--//判断：是否使用new来调用构造函数--&gt;
    &lt;!--//如果使用了new,那么就正常处理，否则就添加上一个new--&gt;
    &lt;!--//默认创建对象并且赋值给this--&gt;
    &lt;!--//if (this != window)--&gt;
    &lt;!--if (this instanceof Dog)--&gt;
    &lt;!--{--&gt;
        &lt;!--this.name = name;--&gt;
        &lt;!--console.log(this,&quot;_______&quot;);--&gt;
    &lt;!--}else--&gt;
    &lt;!--{--&gt;
        &lt;!--return new Dog(name);--&gt;
    &lt;!--}--&gt;

&lt;!--}--&gt;

&lt;!--//01 创建对象--&gt;
&lt;!--var dog1  = new Dog(&quot;阿鲁巴&quot;);--&gt;
&lt;!--var dog2 = Dog(&quot;晓晓&quot;);  //以普通函数的方式来调用构造函数，并不会报错，返回undefined--&gt;

&lt;!--console.log(dog1);--&gt;
&lt;!--console.log(dog2);--&gt;
&lt;!--console.log(window.name);--&gt;
&lt;!--&lt;/script&gt;--&gt;
</code></pre><h3 id="十-构造函数方式创建对象存在的问题"><a href="#十-构造函数方式创建对象存在的问题" class="headerlink" title="十:构造函数方式创建对象存在的问题"></a>十:构造函数方式创建对象存在的问题</h3><pre><code>&lt;script&gt;

//解决思路：把函数抽取到构造函数外部，让多个对象共享同一个函数
function func() {
    console.log(&quot;描述信息&quot;);
}

function Person(name) {
    this.name = name;
    this.showName = function () {
        console.log(this.name);
    };
    this.descriptionLog = func;
}

var p1 = new Person(&quot;张三&quot;);
var p2 = new Person(&quot;张三&quot;);

console.log(p1);
console.log(p2);

p1.showName()
p2.showName();
console.log(p1.showName == p2.showName);        //false
p1.descriptionLog();
p2.descriptionLog();
console.log(p1.descriptionLog == p2.desc riptionLog);

//新的问题：破坏代码的封装性
func();

function func() {
    console.log(&quot;func&quot;)
};

p1.descriptionLog();  //描述信息？（函数提升）

&lt;/script&gt;
</code></pre><h4 id="十一-构造函数的原型对象"><a href="#十一-构造函数的原型对象" class="headerlink" title="十一:构造函数的原型对象"></a>十一:构造函数的原型对象</h4><pre><code>01 什么是原型对象
构造函数有一个默认的相关联的对象，这个对象称为是该构造函数的原型对象
在使用new和构造函数创建对象的时候，内部默认会关联这个新对象的原型对象为当前构造函数的原型对象
这个原型对象默认是一个空的对象

02 原型对象的作用（特点）
构造函数的原型对象 上面的属性和方法 可以被使用该构造函数创建出来的所有对象 所共享

03 如何访问原型对象
001 构造函数.prototype
002 对象.__proto__
003 Object.getPrototype(对象)

04 原型对象的使用：
001 利用对象的动态特性来设置属性和方法
002 直接使用字面量方式替换原型对象

05 约定（说法）
构造函数的原型对象
对象的原型对象
构造函数的原型
对象的原型
&lt;script&gt;
function Person() {

}

console.log(Person.prototype);
Person.prototype = {
    name:&quot;name&quot;
}

var p1 = new Person();
&lt;/script&gt;

使用原型对象解决构造函数方式创建对象的问题
&lt;script&gt;
function Person(name) {
    this.name = name;
}

//设置原型对象
Person.prototype.hi = &quot;hi&quot;;
Person.prototype.showName =  function () {
    console.log(this.name);
};
Person.prototype.descriptionLog = function () {
    console.log(&quot;描述信息&quot;);
}

//创建对象
var p1 = new Person(&quot;张三&quot;);
var p2 = new Person(&quot;张老汉&quot;);
p1.showName();
p2.showName();
p1.descriptionLog();
p2.descriptionLog();
console.log(p1.hi);
console.log(p2.hi);

&lt;/script&gt;
</code></pre><h3 id="十二-实例化和实例"><a href="#十二-实例化和实例" class="headerlink" title="十二:实例化和实例"></a>十二:实例化和实例</h3><pre><code>实例化:
就是使用构造函数创建对象的过程,该过程我们称为实例化

实例:
使用构造函数来创建对象,创建出来的对象就称为这个构造函数的实例.
我们在说实例的时候,需要指明他是哪个构造函数的实例.    
&lt;script&gt;
function Dog(){
}
var dog1 = new Dog();  //实例化的过程
dog1就是Dog这个构造函数的实例.
</code></pre><h3 id="十三-原型的使用方法"><a href="#十三-原型的使用方法" class="headerlink" title="十三:原型的使用方法"></a>十三:原型的使用方法</h3><pre><code>01 利用对象的动态特性
建议:一般情况下,我们会把属性写在对象上面,把方法写在原型上面
&lt;script&gt;
function Car(type,color) {
    this.type = type;
    this.color = color;
}

//设置原型对象的方法
Car.prototype.run = function () {
    console.log(&quot;run&quot;);
}
Car.prototype.desLog = function () {
    console.log(this.type + this.color);
}
//大量的属性|方法
Car.prototype.eat = function () {
    console.log(&quot;eat&quot;);
}
Car.prototype.test1 = function () {
    console.log(&quot;test1&quot;);
}
Car.prototype.demo1 = function () {
    console.log(&quot;demo1&quot;);
}
Car.prototype.friends = [&quot;奥迪&quot;,&quot;奔驰&quot;,&quot;奥拓&quot;];

//创建对象
var car1 = new Car(&quot;奥迪&quot;,&quot;红色&quot;);
var car2 = new Car(&quot;法拉利&quot;,&quot;粉红色&quot;);
console.log(car1);
console.log(car2);
console.log(car1.friends);
console.log(car2.friends);
car1.friends.push(&quot;法拉利未来&quot;);
console.log(car1.friends);
console.log(car2.friends);
&lt;/script&gt;

02 使用字面量的方式直接替换原型对象
&lt;script&gt;
function Person(name) {
    this.name = name;
}

var p1 = new Person(&quot;威整天&quot;);
console.log(p1.hi);      //undefined

//p1.showName();          //威整天
//字面量替换原型对象
Person.prototype = {
    showName:function () {
        console.log(this.name);
    },
    desLog:function () {
        console.log(&quot;秒选信息&quot;);
    },
    hi:&quot;hi&quot;
}

var p2 = new Person(&quot;石破天&quot;);
p2.showName();          //石破天

console.log(p1.hi);      //?

//p1和p2所指向的原型对象并不是同一个
//p1的原型对象是构造函数默认关联的原型对象（空的对象）
//p2的原型对象是{}

&lt;/script&gt;
</code></pre><h3 id="十四-替换原型对象补充"><a href="#十四-替换原型对象补充" class="headerlink" title="十四:替换原型对象补充"></a>十四:替换原型对象补充</h3><pre><code>注意点:
01 注意设置原型对象的位置.建议（在设置完原型对象之后，再统一的创建对象）
02 替换了原型对象之后，需要修正构造器属性 constructor 指向的是创建当前对象的构造函数
    对象中本身并没有constructor属性,该属性是原型对象上面。
&lt;script&gt;
function Person() {
}

//    new Object()
//设置了之后，发现构造器属性指向的是Object而不是Person
Person.prototype = {
    constructor:Person,  //修正构造器属性
    show:function () {
        console.log(&quot;show&quot;);
    }
}

//Person.prototype.constructor ==》Object
//Person.prototype.constructor ==》 Person

var p1 = new Person();
var p2 = new Person();

console.log(p1.constructor == Person);
console.log(p2.constructor == Person);
//获取构造函数的原型对象的构造器属性
console.log(Person.prototype.constructor == Person);
//    Person.prototype.constructor = &quot;hi&quot;;
//    console.log(p1.constructor);
&lt;/script&gt;    
</code></pre><h3 id="十五-原型对象使用的注意点"><a href="#十五-原型对象使用的注意点" class="headerlink" title="十五:原型对象使用的注意点"></a>十五:原型对象使用的注意点</h3><pre><code>01 访问属性 | 方法
访问逻辑：首先先在对象身上查找是否有对应的属性|方法，如果有就直接使用，如果没有那么就查找原型对象
    常用的术语：
        成员：属性 + 方法
        实例成员：实例属性 + 实例方法
        原型成员：原型对象的属性 + 原型对象的方法
 02 设置属性|方法
    通过对象.属性的方式设置的是实例对象的属性
    设置对象的时候，如果是引用类型的，对象.属性.属性是可以设置原型对象的
&lt;script&gt;
function Person(name) {
    this.name = name;
}

Person.prototype = {
    name:&quot;默认的名称&quot;,
    age:20,
    showName:function () {
        console.log(this.name);
    },
    car:{
        type:&quot;火车&quot;,
        color:&quot;黑色&quot;
    }
}

var p = new Person(&quot;张三&quot;);
var p2 = new Person(&quot;李四&quot;);
console.log(p.name);    //张三
console.log(p.age);     //20
p.showName();

//设置属性
p.des = &quot;123&quot;;      //设置在实例对象身上
console.log(p2.des,&quot;___________&quot;);

console.log(p.car);
p.car.type = &quot;飞船&quot;;
console.log(p.car);

p.dog.name = &quot;呼啦哗啦&quot;;
console.log(p.dog.name); //？报错（！）
&lt;/script&gt;
</code></pre><h3 id="十六-proto属性"><a href="#十六-proto属性" class="headerlink" title="十六:proto属性"></a>十六:<strong>proto</strong>属性</h3><pre><code>该属性不是一个标准的属性（ECMA5中没有），ES6中添加了这个属性
在代码中不要出现这个属性，这个属性一般用来调试的.
在之前，该属性是某些浏览器厂商提供（部分浏览器支持）
</code></pre><h3 id="十七-has-Own-Property方法"><a href="#十七-has-Own-Property方法" class="headerlink" title="十七:has Own Property方法"></a>十七:has Own Property方法</h3><pre><code>has Own Property 我自己是否有这个属性(只检查自己的成员)

in 关键字
01 遍历对象
02 判断对象中是否存在指定的属性（实例成员 + 原型成员）

补充：
需求：检查是否存在某个属性，该属性只存在于原型对象中
    001 不是实例对象上面的属性
    002 有这个属性
&lt;script&gt;
function Person(name) {
    this.name = name;
}

Person.prototype.des = &quot;maioshu&quot;;
Person.prototype.name = &quot;maioshu&quot;;

var p1 = new Person(&quot;李四&quot;);
//in 关键字
console.log(&quot;name&quot; in p1);  //true
console.log(&quot;des&quot; in p1);   //true

console.log(p1.hasOwnProperty(&quot;name&quot;)); //true
console.log(p1.hasOwnProperty(&quot;des&quot;)); //false

function onlyPrototypeProp(obj,name) {
    return !obj.hasOwnProperty(name) &amp;&amp; name in obj;
}

console.log(onlyPrototypeProp(p1, &quot;name&quot;));  //false
console.log(onlyPrototypeProp(p1, &quot;des&quot;));  //true
&lt;/script&gt;
</code></pre><h4 id="十八-isPrototypeOf方法"><a href="#十八-isPrototypeOf方法" class="headerlink" title="十八:isPrototypeOf方法"></a>十八:isPrototypeOf方法</h4><pre><code>isPrototypeOf 是否是某个对象的原型对象
Object.getPrototypeOf(对象)
&lt;script&gt;
function Dog() {
}
var demo = {
    name:&quot;测试的名称&quot;
};

Dog.prototype = demo;  //替换原型对象
Dog.prototype.constructor = Dog;

var dog1 = new Dog;  //补充知识：如果构造函数没有传递参数，那么（）可以省略
console.log(dog1);

var abc = {};

console.log(Object.getPrototypeOf(dog1)); 
console.log(abc.isPrototypeOf(dog1));    //false


&lt;/script&gt;
</code></pre>
      
    </div>
    
  </div>
  
    


    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2017/05/23/面向对象day1/">
                    first
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2017/05/23/jQuery的选择器/">
                    first
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#一-面向对象的相关概念"><span class="toc-number">1.</span> <span class="toc-text">一:面向对象的相关概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二-创建并设置标签样式的小案例-面向过程"><span class="toc-number">2.</span> <span class="toc-text">二:创建并设置标签样式的小案例(面向过程)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三-函数封装-面向过程"><span class="toc-number">3.</span> <span class="toc-text">三:函数封装(面向过程):</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四-函数封装-面向对象"><span class="toc-number">4.</span> <span class="toc-text">四:函数封装(面向对象)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#六-面向对象的三大特效"><span class="toc-number">5.</span> <span class="toc-text">六:面向对象的三大特效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#七-创建对象的几种方式"><span class="toc-number">6.</span> <span class="toc-text">七:创建对象的几种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#八-构造函数注意事项01"><span class="toc-number">7.</span> <span class="toc-text">八:构造函数注意事项01</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#九-函数注意事项02"><span class="toc-number">8.</span> <span class="toc-text">九:函数注意事项02</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#十-构造函数方式创建对象存在的问题"><span class="toc-number">9.</span> <span class="toc-text">十:构造函数方式创建对象存在的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#十一-构造函数的原型对象"><span class="toc-number">9.1.</span> <span class="toc-text">十一:构造函数的原型对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#十二-实例化和实例"><span class="toc-number">10.</span> <span class="toc-text">十二:实例化和实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#十三-原型的使用方法"><span class="toc-number">11.</span> <span class="toc-text">十三:原型的使用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#十四-替换原型对象补充"><span class="toc-number">12.</span> <span class="toc-text">十四:替换原型对象补充</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#十五-原型对象使用的注意点"><span class="toc-number">13.</span> <span class="toc-text">十五:原型对象使用的注意点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#十六-proto属性"><span class="toc-number">14.</span> <span class="toc-text">十六:proto属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#十七-has-Own-Property方法"><span class="toc-number">15.</span> <span class="toc-text">十七:has Own Property方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#十八-isPrototypeOf方法"><span class="toc-number">15.1.</span> <span class="toc-text">十八:isPrototypeOf方法</span></a></li></ol></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"first　| IT点彼岸的博客　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2017/05/23/面向对象day1/" title="上一篇: first">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2017/05/23/jQuery的选择器/" title="下一篇: first">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/05/23/jQuery的简介,操作css与html/">jQuery的简介,操作css与html</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/23/first/">first</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/23/常用的不懂方法/">first</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/23/新文档/">first</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/23/自己构建博客/">first</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/23/面向对象day1/">first</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/23/面向对象day2/">first</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/23/jQuery的选择器/">first</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/23/jQuery网页的应用/">first</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2017 IT点彼岸
            </div>
            <div class="footer-right">
                <a href="http://itdian.cn/" target="_blank" title="快速、简洁且高效的博客框架">IT点彼岸</a>欢迎<a href="https://github.com/" target="_blank" title="简而不减 Hexo 双栏博客主题  3.5">你的到来</a><i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>