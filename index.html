<!DOCTYPE html>
<html >
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="IT点彼岸" />


    
    


<meta property="og:type" content="website">
<meta property="og:title" content="IT点彼岸的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="IT点彼岸的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="IT点彼岸的博客">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="IT点彼岸的博客" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>IT点彼岸的博客</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: undefined
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/time.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">IT点彼岸</a></h1>
        </hgroup>

        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="/itdian666@163.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">IT点彼岸</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/time.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">IT点彼岸</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="/itdian666@163.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-jQuery的简介,操作css与html" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/05/23/jQuery的简介,操作css与html/" class="article-date">
      <time datetime="2017-05-23T14:06:10.000Z" itemprop="datePublished">2017-05-23</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/23/jQuery的简介,操作css与html/">jQuery的简介,操作css与html</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <p>  主旨:write less , do more</p>
<p>   特点:1.轻量级<br>        2.强大的处理器<br>        3.出色的Dom封装<br>        4.可靠的事件处理<br>        5.浏览器兼容性强<br>        6.链式操作方式<br>        7.隐式迭代<br><!--更多--><br>Window.onload 与 $(document).ready()的区别<br>Window.onload<br>执行时机:必须等待网页全部加载完毕(包括图片等),然后再执行包裹的代码<br>执行次数:只能执行一次,如果第二次执行,会把第一次的执行覆盖掉<br>$(document).ready()<br>执行时机:只需要等待网页中的DOM结构加载完毕,就能执行包裹着的代码<br>执行次数:可以执行多次,第N次都不会被上一次覆盖<br>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
        <p class="article-more-link">
          <a href="/2017/05/23/jQuery的简介,操作css与html/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-first" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/05/23/first/" class="article-date">
      <time datetime="2017-05-23T14:06:10.000Z" itemprop="datePublished">2017-05-23</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/23/first/">first</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-常用的不懂方法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/05/23/常用的不懂方法/" class="article-date">
      <time datetime="2017-05-23T14:06:10.000Z" itemprop="datePublished">2017-05-23</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/23/常用的不懂方法/">first</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。</p>
<p>empty() 方法从被选元素移除所有内容，包括所有文本和子节点。</p>
<p>trim() 函数返回去掉开头和结尾空格后的字符串</p>
<p>prepend() 方法在被选元素的开头（仍位于内部）插入指定内容</p>
<p>data() 方法向被选元素附加数据，或者从被选元素获取数据。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-新文档" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/05/23/新文档/" class="article-date">
      <time datetime="2017-05-23T14:06:10.000Z" itemprop="datePublished">2017-05-23</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/23/新文档/">first</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>使用一个变量来记录$,以后在jQuery使用变量$</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-自己构建博客" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/05/23/自己构建博客/" class="article-date">
      <time datetime="2017-05-23T14:06:10.000Z" itemprop="datePublished">2017-05-23</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/23/自己构建博客/">first</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><a href="http://martin-liu.github.io/#!/article/4zh" target="_blank" rel="external">http://martin-liu.github.io/#!/article/4zh</a></p>
<p>知网的自己构建网站</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-面向对象day1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/05/23/面向对象day1/" class="article-date">
      <time datetime="2017-05-23T14:06:10.000Z" itemprop="datePublished">2017-05-23</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/23/面向对象day1/">first</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="一-JavaScript是由哪几部分组成"><a href="#一-JavaScript是由哪几部分组成" class="headerlink" title="## 一:JavaScript是由哪几部分组成: ##"></a>## 一:JavaScript是由哪几部分组成: ##</h4><p>01 BOM<br>    Browser Object Mode 浏览器对象模型</p>
<p>02 DOM<br>    Document Object Mode 文档(HTML文档)对象模型</p>
<p>03 ECMAScript<br>       规定了js的语法核心,关键字,类型,语言,结构</p>
<h4 id="二-js中的数据类型-基本数据类型-复杂数据类型"><a href="#二-js中的数据类型-基本数据类型-复杂数据类型" class="headerlink" title="#二:js中的数据类型:基本数据类型 | 复杂数据类型#"></a>#二:js中的数据类型:基本数据类型 | 复杂数据类型#</h4><p>01基本(简单)数据类型</p>
<pre><code>   string  字符串
number   数值(正数|小数)
boolean  布尔类型的值  true | false
null     空(对象)
undefined  没有定义
</code></pre><p>02复杂(复合)数据类型</p>
<pre><code>Object 对象类型(js中所有的复杂数据类型都是基于object)
  Array  数组类型
Date     日期类型
            x JSON  (不是数据类型--是数据结构)
Function    函数类型
RegRxp    正则表达式
Number    
Boolean
</code></pre><p>03 如何判断数据的类型</p>
<pre><code>typeof
语法: typeof 数据(变量)
结果:
typeof 字符串 string
typeof    数值        number
typeof    true|false    boolean
typeof    undefined    undefinede
typeof 复杂数据类型    object 除了函数(function)之外
</code></pre><p>注意点:</p>
<pre><code>01    typrof 本身是操作符不是函数
02 typeof 本身有返回值,这个返回值是string字符串类型的
03 null和undefined的区别        undefined是声明了变量但是从来没有赋值
变量的值永远不会为null,除非你手动的设置为null

我们设置变量的值为null,是为了我们不用变量的时候,垃圾回收机制就会回收这个变量
</code></pre><h4 id="三-赋值"><a href="#三-赋值" class="headerlink" title="三:赋值(=)"></a>三:赋值(=)</h4><pre><code>a=b;  把等号右边的变量(b)保存的内容复制一份给左边的变量
等于符号(==)
返回值:true|false
判定:比较左右两边的值是否相等,如果相等返回的就是true.反之就是false
全等符号(===)
返回值:true|false
判定:比较左右两边的值&amp;类型是否相等,如果值和类型都相等,那么结果就为true,反之就是false

&lt;script&gt;
var str1 = &quot;string1&quot;;                  //字符串类型
var str2 = &quot;string1&quot;;
var str3 = new String(&quot;string1&quot;);       //字符串对象
var str4 = String(&quot;string1&quot;);
var str5 = new Object(&quot;string1&quot;);

console.log(str1 == str2);    //true
console.log(str1 == str3);      //true
console.log(str1 == str4);      //true
console.log(str1 == str5);      //true
console.log(&quot;_________________&quot;);
console.log(str1 === str2);         //true
console.log(str1 === str3);         //false
console.log(&quot;_________________&quot;);
console.log(str1 === str4);         //true
console.log(str1 === str5);         //false

console.log(str3 == str4);          //true
console.log(str3 === str4);         //false

console.log(str3 == str5);          // false
console.log(str3 === str5);         //false 类型相同但是值（地址）不同
&lt;/script&gt;
</code></pre><h4 id="四-关系运算符"><a href="#四-关系运算符" class="headerlink" title="四:关系运算符:"></a>四:关系运算符:</h4><pre><code>大于(&gt;)
小于(&lt;)
小于等于(&lt;=)
大于等于(&gt;=)
不等于(!=)
</code></pre><h4 id="五-逻辑运算符"><a href="#五-逻辑运算符" class="headerlink" title="五:逻辑运算符"></a>五:逻辑运算符</h4><pre><code>01 逻辑非(!)
!表达式
判定:取反操作
返回值:布尔类型的值:true|false
02 逻辑与(&amp;&amp;)
表达式1 &amp;&amp; 表达式2
返回值:其中的一个表达式
判定:判定表达式1是否为真,如果为真,返回表达式2,否则返回表达式1
03 逻辑或(||)
表达式1 || 表达式2
返回值:其中的一个表达式
判定:判定表达式1是否为真,如果为真,返回表达式1,否则返回表达式2

&lt;script&gt;
console.log(1 || 0);              //1
console.log(1 || 1);              //1
console.log(1 || 2);              //1
console.log(0 || 1);              //1
console.log(0 || 0);               //0
console.log(0 || 2);                //2
console.log(2 || 1);                //2

console.log(1 &amp;&amp; 1);                //1
console.log(1 &amp;&amp; 2);                //2
console.log(1 &amp;&amp; 0);                //0
console.log(0 &amp;&amp; 1);                //0
console.log(0 &amp;&amp; 2);                //0
console.log(0 &amp;&amp; 0);                //0
console.log(2 &amp;&amp; 1);                //1
console.log(2 &amp;&amp; 0);                //0

&lt;/script&gt;
</code></pre><h4 id="六-在js中数据的存储有两种方式-值-引用"><a href="#六-在js中数据的存储有两种方式-值-引用" class="headerlink" title="六:在js中数据的存储有两种方式:值|引用"></a>六:在js中数据的存储有两种方式:值|引用</h4><pre><code>按照存储方式的不同,可以分成两种类型
01 值类型
string
number
boolean
undefined
null
值类型的变量存储的内容是具体的数据,比如说&quot;string&quot;
02 引用类型
object类型的,包括Array Function Date RegExp String Number Boolean
引用类型的对象存储的内容是引用(reference--地址),该地址指向内存中具体的数据,
具体的数据单独存储在内存中
&lt;script&gt;

var str = &quot;string1&quot;;    //值类型
var num = 10;           //值类型
var boolT = true;       //值类型

var car = {             //引用类型
    type:&quot;奔驰&quot;,
    color:&quot;黑色&quot;
}

//key - value
var person = {          //引用类型
    name:&quot;张三&quot;,
    age:18,
    car:car
}


console.log(person.name);     //张三
console.log(person.car);      //Object
(color: &quot;黑色&quot;type: &quot;奔驰&quot;__proto__: Object)
&lt;/script&gt;
</code></pre><h4 id="七-赋值（-）"><a href="#七-赋值（-）" class="headerlink" title="七:赋值（=）"></a>七:赋值（=）</h4><pre><code>a = b；  把等号右边的变量存储的内容复制一份给左边的变量

值类型的赋值:

把等号右边的变量存储的内容(具体的数据)复制一份给左边的变量
注意点:修改了其中的一个变量,对另外一个变量没有影响,他们是相互独立的.

引用类型的赋值

把等号右边的对象存储的内容(指向具体数据的地址)复制一份给左边的对象
注意点:修改了其中的某一个对象,对另外一个对象有影响,他们共享内存中的同一块数据
 &lt;script&gt;
    var str1 = &quot;string1&quot;;
var str2 = str1;        //值类型的赋值
console.log(str1 == str2);  //true
str1 = &quot;修改&quot;;
console.log(str1 == str2);  //false
console.log(str1);      //修改
console.log(str2);      //string1

var obj1 = {
    name:&quot;张三&quot;
}

var obj2 = obj1;   //引用类型的赋值
console.log(obj1 == obj2);      //true
obj1.name = &quot;李四&quot;;
console.log(obj1.name);   //李四
console.log(obj2.name);   //李四

//赋值操作之后，如果重新使用字面量的方式来设置对象，那么会切断和赋值对象之间的联系
obj1 = {
    age:20,
    name:&quot;老王&quot;
}

console.log(obj1.name);     //老王
console.log(obj2.name);     //李四

&lt;/script&gt;  
</code></pre><h4 id="八-值类型和引用类型在函数中的使用"><a href="#八-值类型和引用类型在函数中的使用" class="headerlink" title="八:值类型和引用类型在函数中的使用"></a>八:值类型和引用类型在函数中的使用</h4><pre><code>01 函数的参数:
形式参数(形参):在函数声明的时候,写在()中的变量,形参在函数内部使用,
在函数内部作为局部变量使用,形参用来占位
实际参数(实参):在函数调用的时候,写在()中的变量(对象)
02 函数的调用:
内部会把实参赋值给形参
实参可能是值类型的也可能是引用类型的
03 值类型的数据作为函数的参数
在函数内部修改了形参的值(a),对函数外部的实参不会产生影响,他们是相互独立的.
04 引用类型的数据作为函数的参数
在函数内部修改了形参的值(paremObj),对函数外部的实参会产生影响,他们共享内存中的同一块数据

&lt;script&gt;
var num = 10;
function func(a) {
    console.log(a); //10
    a = 20;
    console.log(a); //20
}
func(num);
console.log(num);   //10
//console.log(a);

var obj = {
    name:&quot;张三&quot;
}

function foo(paramObj) {
    console.log(paramObj.name);   //张三
    paramObj.name = &quot;李老汉&quot;;
    console.log(paramObj.name); //李老汉

    paramObj = {
        name:&quot;老王&quot;
    }
    console.log(paramObj.name); //老王
}
foo(obj);
console.log(obj.name);    // 李老汉
  &lt;/script&gt;
</code></pre><h4 id="九-对象的动态特性"><a href="#九-对象的动态特性" class="headerlink" title="九:对象的动态特性"></a>九:对象的动态特性</h4><pre><code>01  js中的对象具有动态特性
js支持在对象定义之后,动态的添加|删除|修改|查询
对象的成员:对象的属性和方法
对象:键值对的几何(key--value).属性和方法的集合
        属性:定义在对象内部的变量
        方法:定义在对象内部的函数
特性的说明:带来了方便(更灵活),但是在使用的时候容易出错(出现覆盖的问题)
02 对象的访问方式:
    1 点语法
    2 []语法  key必须是字符串的类型,如果不是字符串类型那么就当做一个变量来处理
03 动态的操作
添加:如果当前的属性不存在,那么就是添加
修改:如果当前访问的属性已经存在,那么在设置的时候就是修改
删除:使用关键字delete 语法:delete 对象.属性
&lt;script&gt;
var obj = {
    name:&quot;张三&quot;,
    age : 20,
    log:&quot;log&quot;
};

var o = {};

//需求：复制obj对象中的属性给o对象
for(var k in obj)
{
   o[k] = obj[k];
}
console.log(o);
&lt;/script&gt;
&lt;script&gt;
//01 创建空的对象
var obj ={};

//02 动态的添加成员（属性|方法）
obj.name = &quot;张三&quot;;
obj.age = 20;
obj.showName  = function () {
    console.log(this.name);//张三
}
console.log(obj.name);张三
obj.showName();

//03 修改成员
obj.name = &quot;李四&quot;;
obj.showName  = function () {
    console.log(this.name + &quot; 姓名&quot;);//李四  &quot;姓名&quot;
}
obj.showName();
console.log(obj);

delete obj.age;
console.log(obj.age);   //undefiend
console.log(&quot;___________________&quot;);

var test = {};
console.log(test);

//设置属性（添加属性） 属性名称：backgroundColor
test[&quot;background Color&quot;] = &quot;red&quot;;
console.log(test);

obj[&quot;showAge&quot;] = function () {
    console.log(this.age,&quot;____&quot;);
}
obj[&quot;showAge&quot;]();
&lt;/script&gt;

&lt;script&gt;
var obj = {
    name:&quot;张三&quot;,
    age:20,
    showName:function () {
        console.log(this.name);
    }
}

var name = &quot;name&quot;;
console.log(obj.name);  //张三
console.log(obj[name],&quot;+++++&quot;); // 张三
//console.log(obj[age]);   //报错.[key]必须是字符串类型的，如果不是字符串类型那么就当做一个变量来处理

console.log(window.name);  //name
console.log(obj);

&lt;/script&gt;
</code></pre><h4 id="十-in关键字"><a href="#十-in关键字" class="headerlink" title="十:in关键字"></a>十:in关键字</h4><pre><code>01 遍历(迭代) 对象 for...in
02 判断对象中是否存在指定的属性  语法:&quot;属性&quot; in 对象
返回值:布尔类型的值,如果有那么就返回true
注意点:
01 属性必须是字符串
02 在使用in操作符处理数组的时候需要注意: key是索引
数组[1,2,3,4,5,6] 的对象形式:{0:1,1:2,2:3,3:4,4:5,5:6};

&lt;script&gt;
var dog = {
    name:&quot;旺财&quot;,
    color:&quot;绿色&quot;
}

//判断|检查
console.log(&quot;name&quot; in dog);
console.log(&quot;age&quot; in dog);
console.log(&quot;&quot; in dog);           //false
&lt;/script&gt;

&lt;script&gt;
var arr = [1,2,3,4,5,6];
console.log(&quot;1&quot; in arr);    //true
console.log(&quot;1&quot; in arr);   //true

console.log(&quot;5&quot; in arr);       //true
console.log(&quot;6&quot; in arr);        //false  //判断arr中是否有6这个索引
&lt;/script&gt;
</code></pre><h3 id="十一-delete的作用"><a href="#十一-delete的作用" class="headerlink" title="十一:delete的作用"></a>十一:delete的作用</h3><pre><code>01 删除对象的属性
02 可以删除没有使用var声明的变量
delete关键字的使用注意
01 有返回值 布尔类型的值（true|false） 删除成功那么就是true
02 删除对象中不存在的属性，返回值是true还是false  (true)
03 删除对象的原型对象中的属性，能否删除成功(不能删除)，返回值[delete obj.hi == 删除对象中不存在的属性]
04 delete关键字无法删除使用var声明的全局的变量，但是却可以删除直接定义在window上面的属性

&lt;script&gt;
Object.prototype.hi = &quot;hi&quot;;

var obj = {name:&quot;巴拉巴拉小魔仙&quot;};
console.log(delete obj.name);

var demo = &quot;demoTest&quot;;
console.log(delete demo);

console.log(delete obj.age);
console.log(obj.hi);

//    console.log(delete Object.prototype.hi);  //true
console.log(delete obj.hi);  //true
alert(obj.hi);
console.log(obj.hi);

console.log(window.demo);   //全局变量和函数默认会成为window对象的属性和方法

window.showInfo = &quot;不可描述的信息&quot;;
console.log(showInfo);
delete window.showInfo;
console.log(showInfo);   //报错

&lt;script&gt;
var dog = {
    name:&quot;招财&quot;,
    age:14
}

console.log(dog.name);
//删除对象的属性
delete dog.name;
console.log(dog.name);

//没有使用var关键字声明的变量,那么该变量默认会成为一个全局的变量(变成window的属性)
var a = &quot;testa&quot;;
b = &quot;testb&quot;;
console.log(a);
console.log(b);

function func() {
    var num1 = 10;
    num2 = 20;
}

func();
//console.log(num1);  //
console.log(num2);

//使用delete删除属性
console.log(num2,&quot;____&quot;);
delete num2;
//console.log(num2);

console.log(a);
delete a;
console.log(a);

&lt;/script&gt;


&lt;/script&gt;
</code></pre><h3 id="十二-循环和分支"><a href="#十二-循环和分支" class="headerlink" title="十二:循环和分支"></a>十二:循环和分支</h3><pre><code>01 顺序的执行结构
02 循环结构
for循环
while
do...while   至少会执行一次循环体
for..in
&lt;!--&lt;script&gt;--&gt;
&lt;!--while (条件)--&gt;
&lt;!--{--&gt;
    &lt;!--//执行的代码--&gt;
&lt;!--}--&gt;

&lt;!--do{--&gt;
    &lt;!--//执行的代码--&gt;
&lt;!--}while(条件)--&gt;
&lt;!----&gt;
&lt;!--&lt;/script&gt;--&gt;

03 分支结构
if...else..
switch...case

&lt;script&gt;
switch (12)
{
    case 1:
        console.log(1);
        break;
    case 2:
        console.log(2);
        break;
    default:
        console.log(&quot;其他的数据&quot;);
}
&lt;/script&gt;

04 break continue
break :退出循环，执行该循环后面的代码
continue：退出循环(结束当前的循环)，继续执行下一次的循环

&lt;script&gt;
for (var i = 0; i &lt;10; i++) {
    if (i == 5)
    {
        //break;
        continue;
    }

    console.log(&quot;i = &quot; + i);

}

&lt;/script&gt;
</code></pre><h3 id="十三-调试工具的使用-断点"><a href="#十三-调试工具的使用-断点" class="headerlink" title="十三:调试工具的使用(断点)"></a>十三:调试工具的使用(断点)</h3><pre><code>调试工具
01 打开控制台
windows : F12 MAC OSX  option + command + j

02 控制台的详细介绍
03 断点（普通断点 + 条件断点）
04 网络通信的模型
客户端（浏览器|app） --- 服务器端(电脑)
客户端需要数据      ______请求__________&gt;服务器端  （01 请求）
客户端              _____数据__________服务器端     (02 响应)
请求：请求头（对客户端以及请求本身的描述信息） + 请求体（具体的参数）  GET
响应：响应头（对服务器端以及响应本身的描述信息） + 响应体（具体的数据）

GMT 格林尼治时间
北京时间  +     08

&lt;div id=&quot;demo&quot;&gt;测试的div&lt;/div&gt;
&lt;script&gt;
var a = &quot;testA&quot;;

var b = &quot;testB&quot;;
function func01() {
    console.log(a);
    console.log(b);
    var c = &quot;testC&quot;;
    console.log(c);
}

function func02() {
    console.log(&quot;func02&quot;);
}
console.log(b);
func01();
func02();

//console.log(c);

a = &quot;testAAAAASA&quot;;
console.log(a);

for (var i = 0; i &lt; 10000; i++) {
   console.log(i);

}

&lt;/script&gt;
</code></pre><h3 id="十四-异常处理"><a href="#十四-异常处理" class="headerlink" title="十四:异常处理"></a>十四:异常处理</h3><pre><code>异常处理(try...catch)
如果我们的代码发生了异常，那么该行代码后面的代码将无法得到执行
但是有的时候，我们需要保证在任何情况下某些代码都能够正常得到执行，这个时候就可以使用异常捕获结构
异常捕获结构（try...catch）
01 把可能出错的代码放在try{}代码块中

手动的抛出异常 throw关键字
异常信息：字符串 | 对象（）

完整的异常捕获结构
try{}catch(e){}finally{}
&lt;script&gt;
try
{
    //01 存放的是可能出错的代码
    //console.log(c);
}
catch(e)
{
    //02 出错之后会执行这部分代码
    console.log(e);
}
finally
{
    //03 不管是否出错都会执行的代码
    console.log(&quot;无论如何都会执行的代码&quot;);

    //有什么用？ 前端中一般不会使用
    //Node.js 服务器端  最后的扫尾和资源释放的工作
}
&lt;/script&gt;
&lt;script&gt;
try
{
    //可能出错的代码
    var a = &quot;testA&quot;;
    console.log(a);
    //console.log(c);

    //throw &quot;这里出现了隐秘的错误，请检查！&quot;;
    throw {
        errorMsg:&quot;错误信息&quot;,
        errorCode:&quot;100201&quot;
    }
}
catch (e)
{
    //出现了异常之后，会执行这个代码块中的任务（应对异常的解决方法）
    console.log(e);
}

function func() {
  console.log(&quot;func&quot;);
}

func();
&lt;/script&gt;
</code></pre><h3 id="十五-DOM操作"><a href="#十五-DOM操作" class="headerlink" title="十五: DOM操作"></a>十五: DOM操作</h3><pre><code>DOM:文档对象模型 核心对象：document
增加|删除|修改|查询
查询：getElementById|className |tagName
删除：remove...
修改: 得到标签之后直接设置
增加:createEle...

需求：创建一个div标签，设置标签的内容为：我让掉下眼泪的，不止昨夜的酒，设置样式
样式：
    高度：100px
    宽度：300px
    背景颜色:red
    边框： 1px solid #432
把标签添加到当前的页面中
&lt;script&gt;
//01 创建标签
var div = document.createElement(&quot;div&quot;);
//02 设置内容和样式
div.innerText = &quot;我让掉下眼泪的，不止昨夜的酒&quot;;
div.style.height = &quot;100px&quot;;
div.style.width = &quot;300px&quot;;
div.style.backgroundColor = &quot;red&quot;;
div.style.border = &quot;1px solid #555&quot;;
//03 添加到body
document.body.appendChild(div);
//04 删除标签
document.body.removeChild(div);

&lt;/script&gt;
</code></pre><h3 id="十六-函数和对象的创建"><a href="#十六-函数和对象的创建" class="headerlink" title="十六:函数和对象的创建"></a>十六:函数和对象的创建</h3><pre><code>函数的创建
01 函数声明 function 函数名（参数1，参数2）{函数体}
02 函数表达式 var func =  function [函数名]（参数1，参数2）{函数体}
03 使用构造函数创建（Function）

对象的创建
01 字面量的方式
02 构造函数（Object） + new
&lt;script&gt;
//01 函数声明
function func(a,b) {
    console.log(a + b);
}
func(1,2);

//02 函数表达式
var foo = function () {
    console.log(&quot;foo&quot;);
}

foo();

//03 构造函数创建
var funcName = new Function(&quot;console.log(123)&quot;);
funcName();

&lt;/script&gt;
&lt;script&gt;
var obj = {
    name:&quot;张三&quot;
}

var obj2 = new Object();  //{}
obj2.name = &quot;李四&quot;;
console.log(obj2);


&lt;/script&gt;
</code></pre><h3 id="十七-面向过程和面向对象的概念"><a href="#十七-面向过程和面向对象的概念" class="headerlink" title="十七:面向过程和面向对象的概念"></a>十七:面向过程和面向对象的概念</h3><pre><code>面向过程
关注的是解决问题需要的一个接着一个的过程

面向对象
关注的是解决问题需要的对象

面向对象编程主要重点是对象：内置对象（数组对象|日期对象|函数对象） 自定义

面向对象和面向过程都是一种解决编程问题的思想（方法）

例子：
    面向过程的洗衣服方式：
     01 收集脏衣服
     02 找个盆（桶）
     03 接水
     04 放洗衣液（洗衣粉）
     05 搅匀
     06 先泡几分钟（15）
     07 摩擦摩擦
     08 再清水冲洗一遍
     09 把衣服拧干
     10 晾衣服

    面向对象洗衣服
        01 收集脏衣服
        02 找个合适的洗衣机|男朋友|女朋友
        03 设置洗衣服和烘干的程序

面向对象和面向过程关系 其实是对面向过程的一种封装（？） 减少冗余的代码 + 复用性更好
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-面向对象day2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/05/23/面向对象day2/" class="article-date">
      <time datetime="2017-05-23T14:06:10.000Z" itemprop="datePublished">2017-05-23</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/23/面向对象day2/">first</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="一-面向对象的相关概念"><a href="#一-面向对象的相关概念" class="headerlink" title="一:面向对象的相关概念"></a>一:面向对象的相关概念</h3><pre><code>01 对象是什么?
什么都是对象.对象是具体的事物
思考:电脑(分类) 人 桌子 狗 猫 老师 同学  这些都不是对象,只是一种类别.
02 对象的描述信息(静态特征)
张三: 身高 体重 身份证号码 专业 班级 名字
李四家的狗: 颜色 年龄 名字
03 对象的行为特征(动态的行为)
张三: 吃饭 睡觉 打游戏 跑步
李四家的狗: 吃饭 叫 睡觉 打架 流口水
04 js的对象
对象定义:键值对(key-value)的集合 | 属性(方法)的工具包|对遍历和函数的封装.
对象的组成:
    静态特征:属性(定义在对象中变量)    
    动态行为:方法(定义在对象中函数)
05 补充:
面向对象和面向过程并没有孰优孰劣,解决问题的时候需要看实际的情况(选取正确的方案)
为什么要使用面向对象的方式来写代码? 方便 节省 复用性高
&lt;script&gt;
var dog = {
    name:&quot;旺财&quot;,
    age:13,
    color:&quot;紫色&quot;,
    eat: function () {
        console.log(&quot;eat&quot;);
    },
    sleepp:function (){
        console.log(&quot;sleep&quot;);
    },
    run:function () {
        console.log(&quot;run&quot;);
    }
}

console.log(dog);   //object  { dog对象的东西 }
dog.eat();      //eat
dog.run();      //run


&lt;/script&gt;
</code></pre><h3 id="二-创建并设置标签样式的小案例-面向过程"><a href="#二-创建并设置标签样式的小案例-面向过程" class="headerlink" title="二:创建并设置标签样式的小案例(面向过程)"></a>二:创建并设置标签样式的小案例(面向过程)</h3><pre><code>div&lt;我是第$个div标签&gt;*6

p&lt;我是第$个p标签&gt;*3    

 冗余度(重复的代码很多)
&lt;script&gt;
//01 获得页面中所有的div标签
var divs = document.getElementsByTagName(&quot;div&quot;);
//02 遍历所有的标签并且设置
for (var i = 0; i &lt; divs.length; i++) {
    divs[i].style.border = &quot;1px solid red&quot;;
}

//03 获得页面中所有p标签
var ps = document.getElementsByTagName(&apos;p&apos;);
//04 遍历所有的标签并且设置
for (var i = 0; i &lt; ps.length; i++) {
    ps[i].style.border = &apos;1px solid red&apos;;
}
&lt;/script&gt;
</code></pre><h3 id="三-函数封装-面向过程"><a href="#三-函数封装-面向过程" class="headerlink" title="三:函数封装(面向过程):"></a>三:函数封装(面向过程):</h3><pre><code>&lt;div&gt;我是第1个div标签&lt;/div&gt;
&lt;div&gt;我是第2个div标签&lt;/div&gt;
&lt;div&gt;我是第3个div标签&lt;/div&gt;
&lt;div&gt;我是第4个div标签&lt;/div&gt;
&lt;div&gt;我是第5个div标签&lt;/div&gt;
&lt;div&gt;我是第6个div标签&lt;/div&gt;

需求    :设置页面中所有div标签的样式（边框） border = &quot;1px solid red&quot;;
 设置页面中所有的p标签的样式（边框） border = &quot;1px solid red&quot;;
&lt;p&gt;我是第1个p便签&lt;/p&gt;
&lt;p&gt;我是第2个p便签&lt;/p&gt;
&lt;p&gt;我是第3个p便签&lt;/p&gt;
&lt;script&gt;

//把固定不变的部分抽取作为函数体
//把改变的部分抽取作为函数的参数
function getEle(tagName) {
    return document.getElementsByTagName(tagName);
}
function setBorder(eles) {
    for (var i = 0; i &lt; eles.length; i++) {
        eles[i].style.border = &quot;1px solid red&quot;;
    }
}

var divs = getEle(&quot;div&quot;);
var ps = getEle(&quot;p&quot;);
setBorder(divs);
setBorder(ps);

&lt;/script&gt;
</code></pre><h3 id="四-函数封装-面向对象"><a href="#四-函数封装-面向对象" class="headerlink" title="四:函数封装(面向对象)"></a>四:函数封装(面向对象)</h3><pre><code>&lt;div&gt;我是第1个div标签&lt;/div&gt;
&lt;div&gt;我是第2个div标签&lt;/div&gt;
&lt;div&gt;我是第3个div标签&lt;/div&gt;
&lt;div&gt;我是第4个div标签&lt;/div&gt;
&lt;div&gt;我是第5个div标签&lt;/div&gt;    
&lt;div&gt;我是第6个div标签&lt;/div&gt;

需求:设置页面中所有div标签的样式（边框） border = &quot;1px solid red&quot;;
 设置页面中所有的p标签的样式（边框） border = &quot;1px solid red&quot;;
&lt;p&gt;我是第1个p便签&lt;/p&gt;
&lt;p&gt;我是第2个p便签&lt;/p&gt;
&lt;p&gt;我是第3个p便签&lt;/p&gt;

冗余度 （重复的内容）

&lt;script&gt;

//把固定不变的部分抽取作为函数体
//把改变的部分抽取作为函数的参数
//使用对象来进行封装
var XMGQuery =  {
    getEle:{
        tagName:function (tagName) {
            return document.getElementsByTagName(tagName);
        },
        id:function (id) {
            return document.getElementById(id);
        },
        calssName:function (classNmae) {
            return document.getElementsByClassName(classNmae);
        },
    },
    setStyle:{
        setBorder:function (eles) {
            for (var i = 0; i &lt; eles.length; i++) {
                eles[i].style.border = &quot;1px solid red&quot;;
            }
        },
        setColor:function (eles) {
            for (var i = 0; i &lt; eles.length; i++) {
                eles[i].style.color = &quot;red&quot;;
            }
        }
    }
}
XMGQuery.setStyle.setBorder(XMGQuery.getEle.tagName(&quot;div&quot;));
XMGQuery.setStyle.setBorder(XMGQuery.getEle.tagName(&quot;p&quot;));

&lt;/script&gt;
</code></pre><h3 id="六-面向对象的三大特效"><a href="#六-面向对象的三大特效" class="headerlink" title="六:面向对象的三大特效"></a>六:面向对象的三大特效</h3><pre><code>01封装
好处:复用(!),降低冗余度,更有利于模块化编程,能够为变量函数提供更多的保护.使用对象来封装变量和函数
02 继承
现实中继承：一般是子女获得父母的财富|资源的一种方式。
代码中继承：子类获得父类的属性和方法（成员）的一种方式。
js中的继承:
严格来说js并不是一门面向对象的语言(类-class),支持面向对象而已.
js中的继承是一个对象获得另外一个对象的属性和方法的一种行为.
术语:
父类
子类
超类
js中
父对象 - 子对象
a---b(属性|方法)
实现方法
001 属性拷贝(浅拷贝)
002 属性拷贝(深拷贝)
003 原型式继承
004 原型链继承
005 借用构造函数
006 组合继承
02.多态
多种形态
特点:对于同一个操作(指令),不同的对象表现出不同的反应,隐藏不同
观点:js天生就是一门支持多态的语法.
好处:灵活
&lt;script&gt;
var obj = {
    name :&quot;旺财&quot;,
    age:20,
    friends:[&quot;乌拉乌拉&quot;,&quot;扒拉扒拉&quot;,&quot;哗啦哗啦&quot;],
    showName:function () {
        console.log(this.name);
    }
};

var o = {};

//o 对象需要获得obj对象的属性和方法  o 子对象 obj父对象
 //    o.name = obj.name;
    //    o.age = obj.age;
//    o.showName = obj.showName;
//    o.showName();

for(var k in obj)
{
   // o.k = obj.k;
    o[k] = obj[k];
}
console.log(o);

//如果是引用类型，那么会有共享的问题
obj.friends.push(&quot;无力无力&quot;);
console.log(o);
</code></pre><h3 id="七-创建对象的几种方式"><a href="#七-创建对象的几种方式" class="headerlink" title="七:创建对象的几种方式"></a>七:创建对象的几种方式</h3><pre><code>01 字面量
02 内置构造函数 new Object()|new Date()
03 简单工厂函数创建
04 自定义构造函数
05 Object.create()
&lt;script&gt;

//书（对象）
//属性：书名 | 作者 | 出版社 | 价格
//方法：deslog 打印书本的介绍信息

var book1 = {
    name:&quot;西游记&quot;,
    author:&quot;吴承恩&quot;,
    press:&quot;中华书局&quot;,
    price:&quot;0.1&quot;,
    desLog:function () {
        console.log(&quot;书名：&quot; + this.name + &quot; 作者：&quot; + this.author);
    }
}
book1.desLog();

//需求：（图书管理员）
var book2 = {
    name:&quot;悟空传&quot;,
    author:&quot;今何在&quot;,
    press:&quot;湖南文艺出版社&quot;,
    price:&quot;28.00&quot;,
    desLog:function () {
        console.log(&quot;书名：&quot; + this.name + &quot; 作者：&quot; + this.author);
    }
}

var book3 = {
    name:&quot;什么是批判&quot;,
    author:&quot;福柯&quot;,
    press:&quot;北京大学出版社&quot;,
    price:&quot;58.00&quot;,
    desLog:function () {
        console.log(&quot;书名：&quot; + this.name + &quot; 作者：&quot; + this.author);
    }
}
console.log(book3);

//......

//问题:如果要创建多个同类型的对象，那么代码冗余度太高（重复的代码），复用性（差）
&lt;/script&gt;

2  内置构造函数
Array Date Object Function String Number Boolean
使用方法:new 构造函数(参数)
&lt;script&gt;
var date = new Date();
var array = new Array();
var string = new String(&quot;demo&quot;);

&lt;/script&gt;
&lt;script&gt;

var book = new Object();
book.name = &quot;三国演义&quot;;
book.author = &quot;罗贯中&quot;;
book.press = &quot;中华书局&quot;;
book.desLog = function () {
    console.log(this.name + this.author);
}
book.desLog();

var book2 = new Object();
book2.name = &quot;红楼梦&quot;;
book2.author = &quot;曹公子&quot;;
book2.press = &quot;中华书局&quot;;
book2.desLog = function () {
    console.log(this.name + this.author);
}
book2.desLog();

//问题：同字面量方式一样
&lt;/script&gt;

3. 简单工厂函数创建对象

&lt;script&gt;

//01 提供一个函数
function createBook(name,author) {
    //02 创建空的对象
    var book = new Object();
    //03 设置对象的属性和方法
    book.name = name;
    book.author = author;
    book.desLog = function () {
        console.log(this.name + this.author);
    }
    //04 把创建的对象返回
    return book;
}

var book1 = createBook(&quot;悟空传&quot;,&quot;孙悟空&quot;);
var book2 = createBook(&quot;红楼梦&quot;,&quot;曹公子&quot;);
console.log(book1);
console.log(book2);
console.log( book1 ==  book2);
book1.desLog();
book2.desLog();
&lt;/script&gt;


4.自定义构造函数
&lt;script&gt;

//01 提供一个函数
function createBook(name,author) {
    //02 创建空的对象
    var book = new Object();
    //03 设置对象的属性和方法
    book.name = name;
    book.author = author;
    book.desLog = function () {
        console.log(this.name + this.author);
    }
    //04 把创建的对象返回
    return book;
}

var book1 = createBook(&quot;悟空传&quot;,&quot;孙悟空&quot;);
var book2 = createBook(&quot;红楼梦&quot;,&quot;曹公子&quot;);
console.log(book1);
console.log(book2);
console.log(book1 == book2);
book1.desLog();
book2.desLog();

//问题（特点）：对象类型判断的问题
function createPerson(name,age) {
    var obj = new Object();
    obj.name = name;
    obj.age = age;
    return obj;
}
function createDog(name,age) {
    var obj = new Object();
    obj.name = name;
    obj.age = age;
    return obj;
}

//创建人对象
var obj1 = createPerson(&quot;张三&quot;,23);
var obj2 = createDog(&quot;李四&quot;,10);

//obj1 --- obj2
console.log(obj1);
console.log(obj2);

//无法区分对象的类型  ：obj1（人）obj2(狗)

&lt;/script&gt;

自定义构造函数创建对象
术语：
构造函数 ==  普通函数，人为的区分（首字母大写）
构造函数：主要做初始化的处理（设置属性和方法）
new :    创建对象（{}）
var obj = new Object();
核心过程
01 提供一个构造函数（普通函数首字母大写）
02 通过this指针来设置对象的属性和方法
03 使用new 构造函数（）创建对象

内部的实现过程：
01 提供构造函数
02 创建一个空的对象{} ===&gt; Object
03 设置新创建对象的原型对象为构造函数的原型对象
04 设置新创建对象的构造函数为当前的构造函数
05 把新创建的对象赋值给this
06 通过this设置属性和方法
07 默认在最后把新创建的对象返回

返回值
01 如果没有显示的return,那么默认在最后把新创建的对象返回
02 如果显示的return,那么结果得看具体的情况：
    001 返回的是值类型的  忽略（返回新对象）
    002 返回的是引用类型的 return的对象会把新创建的对象覆盖
&lt;script&gt;
function Dog(name) {
    this.name = name;
    return [1,2,3];
}

var dog1 = new Dog(&quot;旺财&quot;);
console.log(dog1);
&lt;/script&gt;
&lt;script&gt;
function CreatePerson(name,age) {
    //创建对象{}
    //把新的对象赋值给this
    this.name = name;
    this.age = age;
    this.showName = function () {
        console.log(this.name);
    }
    //默认把新创建的对象返回
}
var p1 = new CreatePerson(&quot;张三&quot;,99);
var p2 = new CreatePerson(&quot;李四&quot;,0.9);
p1.showName();
p2.showName();
&lt;/script&gt;

&lt;script&gt;
function Person(name,age) {
    //01 创建对象{}
    //var o = new Object();    o的构造函数 --- Object
    //02 把新的对象赋值给this
    //this = o;
    //03 设置新创建对象的原型对象为构造函数的原型对象
    //o.__proto__ = Person.prototype;
    //04 设置新创建对象的构造函数为当前的构造函数
    //o.constructor = Person;

    this.name = name;
    this.age = age;
    this.showName = function () {
        console.log(this.name);
    }
    //默认把新创建的对象返回
    //return this;
}
var p1 = new Person(&quot;张三&quot;,99);
var p2 = new Person(&quot;李四&quot;,0.9);
p1.showName();
p2.showName();
&lt;/script&gt;

构造函数和普通函数没有什么区别，人为的进行区分（首字母大写）
构造函数在调用的时候需要和new一起使用
普通函数直接调用
</code></pre><h3 id="八-构造函数注意事项01"><a href="#八-构造函数注意事项01" class="headerlink" title="八:构造函数注意事项01"></a>八:构造函数注意事项01</h3><pre><code>01 函数传值
02 instanceOf
03 对象到底是什么类型(构造器属性)
&lt;script&gt;
function Person(name,doSomething) {
    this.name = name;
    this.doSomething = doSomething;
}

var p1 = new Person(&quot;张三&quot;,function () {
    console.log(&quot;流口水&quot;);
});
var p2 = new Person(&quot;李四&quot;,function () {
    console.log(&quot;咬人&quot;);
});
p1.doSomething();
p2.doSomething();
&lt;/script&gt;
&lt;script&gt;
function Book(name) {
    this.name = name;
}
function Dog(name) {
    this.name = name;
}

var obj1 = new Book(&quot;阿黄&quot;);
var obj2 = new Dog(&quot;阿黄&quot;);

//可以区分对象的类型
//instanceOf  检查某个对象是否是指定构造函数的实例对象（是不是它创建出来）
console.log(obj1 instanceof Book);   //true
console.log(obj2 instanceof Book);  //false
console.log(obj1 instanceof Dog);   //false
console.log(obj2 instanceof Dog);   //true
console.log(obj1 instanceof Object);  //true Object是所有对象的基本对象

//var obj3 = {};
//obj3 是什么类型？
console.log(obj1.constructor);      //Book
console.log(obj2.constructor);      //Dog
&lt;/script&gt;
</code></pre><h3 id="九-函数注意事项02"><a href="#九-函数注意事项02" class="headerlink" title="九:函数注意事项02"></a>九:函数注意事项02</h3><pre><code>01 构造函数必须要和new一起使用，如果直接调用那么无法创建对象
02 this的指向
如果是使用new 构造函数（）调用，那么this---&gt;具体的对象
如果是以普通函数的方式调用吧，那么this ----&gt;window

03 this的丢失问题

&lt;script&gt;

window.name = &quot;xxxxxx&quot;;
var obj = {
    name:&quot;张三&quot;,
    showName:function () {
        console.log(this.name);
    }
}

obj.showName();             //对象.方法  以对象方法的形式来调用函数 （this ---&gt;对象）

var func = obj.showName;
func();   //undefined ? 空  window.name //以普通函数的方式来调用函数（this ---&gt;window）


&lt;/script&gt;
&lt;!--&lt;script&gt;--&gt;
&lt;!--function Dog(name) {--&gt;
    &lt;!--//判断：是否使用new来调用构造函数--&gt;
    &lt;!--//如果使用了new,那么就正常处理，否则就添加上一个new--&gt;
    &lt;!--//默认创建对象并且赋值给this--&gt;
    &lt;!--//if (this != window)--&gt;
    &lt;!--if (this instanceof Dog)--&gt;
    &lt;!--{--&gt;
        &lt;!--this.name = name;--&gt;
        &lt;!--console.log(this,&quot;_______&quot;);--&gt;
    &lt;!--}else--&gt;
    &lt;!--{--&gt;
        &lt;!--return new Dog(name);--&gt;
    &lt;!--}--&gt;

&lt;!--}--&gt;

&lt;!--//01 创建对象--&gt;
&lt;!--var dog1  = new Dog(&quot;阿鲁巴&quot;);--&gt;
&lt;!--var dog2 = Dog(&quot;晓晓&quot;);  //以普通函数的方式来调用构造函数，并不会报错，返回undefined--&gt;

&lt;!--console.log(dog1);--&gt;
&lt;!--console.log(dog2);--&gt;
&lt;!--console.log(window.name);--&gt;
&lt;!--&lt;/script&gt;--&gt;
</code></pre><h3 id="十-构造函数方式创建对象存在的问题"><a href="#十-构造函数方式创建对象存在的问题" class="headerlink" title="十:构造函数方式创建对象存在的问题"></a>十:构造函数方式创建对象存在的问题</h3><pre><code>&lt;script&gt;

//解决思路：把函数抽取到构造函数外部，让多个对象共享同一个函数
function func() {
    console.log(&quot;描述信息&quot;);
}

function Person(name) {
    this.name = name;
    this.showName = function () {
        console.log(this.name);
    };
    this.descriptionLog = func;
}

var p1 = new Person(&quot;张三&quot;);
var p2 = new Person(&quot;张三&quot;);

console.log(p1);
console.log(p2);

p1.showName()
p2.showName();
console.log(p1.showName == p2.showName);        //false
p1.descriptionLog();
p2.descriptionLog();
console.log(p1.descriptionLog == p2.desc riptionLog);

//新的问题：破坏代码的封装性
func();

function func() {
    console.log(&quot;func&quot;)
};

p1.descriptionLog();  //描述信息？（函数提升）

&lt;/script&gt;
</code></pre><h4 id="十一-构造函数的原型对象"><a href="#十一-构造函数的原型对象" class="headerlink" title="十一:构造函数的原型对象"></a>十一:构造函数的原型对象</h4><pre><code>01 什么是原型对象
构造函数有一个默认的相关联的对象，这个对象称为是该构造函数的原型对象
在使用new和构造函数创建对象的时候，内部默认会关联这个新对象的原型对象为当前构造函数的原型对象
这个原型对象默认是一个空的对象

02 原型对象的作用（特点）
构造函数的原型对象 上面的属性和方法 可以被使用该构造函数创建出来的所有对象 所共享

03 如何访问原型对象
001 构造函数.prototype
002 对象.__proto__
003 Object.getPrototype(对象)

04 原型对象的使用：
001 利用对象的动态特性来设置属性和方法
002 直接使用字面量方式替换原型对象

05 约定（说法）
构造函数的原型对象
对象的原型对象
构造函数的原型
对象的原型
&lt;script&gt;
function Person() {

}

console.log(Person.prototype);
Person.prototype = {
    name:&quot;name&quot;
}

var p1 = new Person();
&lt;/script&gt;

使用原型对象解决构造函数方式创建对象的问题
&lt;script&gt;
function Person(name) {
    this.name = name;
}

//设置原型对象
Person.prototype.hi = &quot;hi&quot;;
Person.prototype.showName =  function () {
    console.log(this.name);
};
Person.prototype.descriptionLog = function () {
    console.log(&quot;描述信息&quot;);
}

//创建对象
var p1 = new Person(&quot;张三&quot;);
var p2 = new Person(&quot;张老汉&quot;);
p1.showName();
p2.showName();
p1.descriptionLog();
p2.descriptionLog();
console.log(p1.hi);
console.log(p2.hi);

&lt;/script&gt;
</code></pre><h3 id="十二-实例化和实例"><a href="#十二-实例化和实例" class="headerlink" title="十二:实例化和实例"></a>十二:实例化和实例</h3><pre><code>实例化:
就是使用构造函数创建对象的过程,该过程我们称为实例化

实例:
使用构造函数来创建对象,创建出来的对象就称为这个构造函数的实例.
我们在说实例的时候,需要指明他是哪个构造函数的实例.    
&lt;script&gt;
function Dog(){
}
var dog1 = new Dog();  //实例化的过程
dog1就是Dog这个构造函数的实例.
</code></pre><h3 id="十三-原型的使用方法"><a href="#十三-原型的使用方法" class="headerlink" title="十三:原型的使用方法"></a>十三:原型的使用方法</h3><pre><code>01 利用对象的动态特性
建议:一般情况下,我们会把属性写在对象上面,把方法写在原型上面
&lt;script&gt;
function Car(type,color) {
    this.type = type;
    this.color = color;
}

//设置原型对象的方法
Car.prototype.run = function () {
    console.log(&quot;run&quot;);
}
Car.prototype.desLog = function () {
    console.log(this.type + this.color);
}
//大量的属性|方法
Car.prototype.eat = function () {
    console.log(&quot;eat&quot;);
}
Car.prototype.test1 = function () {
    console.log(&quot;test1&quot;);
}
Car.prototype.demo1 = function () {
    console.log(&quot;demo1&quot;);
}
Car.prototype.friends = [&quot;奥迪&quot;,&quot;奔驰&quot;,&quot;奥拓&quot;];

//创建对象
var car1 = new Car(&quot;奥迪&quot;,&quot;红色&quot;);
var car2 = new Car(&quot;法拉利&quot;,&quot;粉红色&quot;);
console.log(car1);
console.log(car2);
console.log(car1.friends);
console.log(car2.friends);
car1.friends.push(&quot;法拉利未来&quot;);
console.log(car1.friends);
console.log(car2.friends);
&lt;/script&gt;

02 使用字面量的方式直接替换原型对象
&lt;script&gt;
function Person(name) {
    this.name = name;
}

var p1 = new Person(&quot;威整天&quot;);
console.log(p1.hi);      //undefined

//p1.showName();          //威整天
//字面量替换原型对象
Person.prototype = {
    showName:function () {
        console.log(this.name);
    },
    desLog:function () {
        console.log(&quot;秒选信息&quot;);
    },
    hi:&quot;hi&quot;
}

var p2 = new Person(&quot;石破天&quot;);
p2.showName();          //石破天

console.log(p1.hi);      //?

//p1和p2所指向的原型对象并不是同一个
//p1的原型对象是构造函数默认关联的原型对象（空的对象）
//p2的原型对象是{}

&lt;/script&gt;
</code></pre><h3 id="十四-替换原型对象补充"><a href="#十四-替换原型对象补充" class="headerlink" title="十四:替换原型对象补充"></a>十四:替换原型对象补充</h3><pre><code>注意点:
01 注意设置原型对象的位置.建议（在设置完原型对象之后，再统一的创建对象）
02 替换了原型对象之后，需要修正构造器属性 constructor 指向的是创建当前对象的构造函数
    对象中本身并没有constructor属性,该属性是原型对象上面。
&lt;script&gt;
function Person() {
}

//    new Object()
//设置了之后，发现构造器属性指向的是Object而不是Person
Person.prototype = {
    constructor:Person,  //修正构造器属性
    show:function () {
        console.log(&quot;show&quot;);
    }
}

//Person.prototype.constructor ==》Object
//Person.prototype.constructor ==》 Person

var p1 = new Person();
var p2 = new Person();

console.log(p1.constructor == Person);
console.log(p2.constructor == Person);
//获取构造函数的原型对象的构造器属性
console.log(Person.prototype.constructor == Person);
//    Person.prototype.constructor = &quot;hi&quot;;
//    console.log(p1.constructor);
&lt;/script&gt;    
</code></pre><h3 id="十五-原型对象使用的注意点"><a href="#十五-原型对象使用的注意点" class="headerlink" title="十五:原型对象使用的注意点"></a>十五:原型对象使用的注意点</h3><pre><code>01 访问属性 | 方法
访问逻辑：首先先在对象身上查找是否有对应的属性|方法，如果有就直接使用，如果没有那么就查找原型对象
    常用的术语：
        成员：属性 + 方法
        实例成员：实例属性 + 实例方法
        原型成员：原型对象的属性 + 原型对象的方法
 02 设置属性|方法
    通过对象.属性的方式设置的是实例对象的属性
    设置对象的时候，如果是引用类型的，对象.属性.属性是可以设置原型对象的
&lt;script&gt;
function Person(name) {
    this.name = name;
}

Person.prototype = {
    name:&quot;默认的名称&quot;,
    age:20,
    showName:function () {
        console.log(this.name);
    },
    car:{
        type:&quot;火车&quot;,
        color:&quot;黑色&quot;
    }
}

var p = new Person(&quot;张三&quot;);
var p2 = new Person(&quot;李四&quot;);
console.log(p.name);    //张三
console.log(p.age);     //20
p.showName();

//设置属性
p.des = &quot;123&quot;;      //设置在实例对象身上
console.log(p2.des,&quot;___________&quot;);

console.log(p.car);
p.car.type = &quot;飞船&quot;;
console.log(p.car);

p.dog.name = &quot;呼啦哗啦&quot;;
console.log(p.dog.name); //？报错（！）
&lt;/script&gt;
</code></pre><h3 id="十六-proto属性"><a href="#十六-proto属性" class="headerlink" title="十六:proto属性"></a>十六:<strong>proto</strong>属性</h3><pre><code>该属性不是一个标准的属性（ECMA5中没有），ES6中添加了这个属性
在代码中不要出现这个属性，这个属性一般用来调试的.
在之前，该属性是某些浏览器厂商提供（部分浏览器支持）
</code></pre><h3 id="十七-has-Own-Property方法"><a href="#十七-has-Own-Property方法" class="headerlink" title="十七:has Own Property方法"></a>十七:has Own Property方法</h3><pre><code>has Own Property 我自己是否有这个属性(只检查自己的成员)

in 关键字
01 遍历对象
02 判断对象中是否存在指定的属性（实例成员 + 原型成员）

补充：
需求：检查是否存在某个属性，该属性只存在于原型对象中
    001 不是实例对象上面的属性
    002 有这个属性
&lt;script&gt;
function Person(name) {
    this.name = name;
}

Person.prototype.des = &quot;maioshu&quot;;
Person.prototype.name = &quot;maioshu&quot;;

var p1 = new Person(&quot;李四&quot;);
//in 关键字
console.log(&quot;name&quot; in p1);  //true
console.log(&quot;des&quot; in p1);   //true

console.log(p1.hasOwnProperty(&quot;name&quot;)); //true
console.log(p1.hasOwnProperty(&quot;des&quot;)); //false

function onlyPrototypeProp(obj,name) {
    return !obj.hasOwnProperty(name) &amp;&amp; name in obj;
}

console.log(onlyPrototypeProp(p1, &quot;name&quot;));  //false
console.log(onlyPrototypeProp(p1, &quot;des&quot;));  //true
&lt;/script&gt;
</code></pre><h4 id="十八-isPrototypeOf方法"><a href="#十八-isPrototypeOf方法" class="headerlink" title="十八:isPrototypeOf方法"></a>十八:isPrototypeOf方法</h4><pre><code>isPrototypeOf 是否是某个对象的原型对象
Object.getPrototypeOf(对象)
&lt;script&gt;
function Dog() {
}
var demo = {
    name:&quot;测试的名称&quot;
};

Dog.prototype = demo;  //替换原型对象
Dog.prototype.constructor = Dog;

var dog1 = new Dog;  //补充知识：如果构造函数没有传递参数，那么（）可以省略
console.log(dog1);

var abc = {};

console.log(Object.getPrototypeOf(dog1)); 
console.log(abc.isPrototypeOf(dog1));    //false


&lt;/script&gt;
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-jQuery的选择器" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/05/23/jQuery的选择器/" class="article-date">
      <time datetime="2017-05-23T14:06:10.000Z" itemprop="datePublished">2017-05-23</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/23/jQuery的选择器/">first</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="jQuery选择器"><a href="#jQuery选择器" class="headerlink" title="jQuery选择器"></a>jQuery选择器</h1><p>jQuery 最核心的组成部分就是:选择器引擎。<br>   它完全继承了 CSS 的风格,可以对 DOM 元 素的标签名、属性名、状态等进行快速准确的选择,并且不必担心浏览器的兼容性,写法更加简洁。<br>jQuery 选择器实现了 CSS1~CSS3 的大部分规则之外,还实现了一些自定义的选择器,用于各种 特殊状态的选择。 </p>
<h2 id="选择器的分类"><a href="#选择器的分类" class="headerlink" title="选择器的分类:"></a>选择器的分类:</h2><p>  <strong>1.基本选择器</strong></p>
<p>  <strong>2.层级选择器</strong></p>
<p>  <strong>3.属性选择器</strong></p>
<p>  <strong>4.筛选选择器</strong></p>
<p>  <strong>5.表单选择器</strong></p>
<p>  1.基本选择器<br><img src="http://i.imgur.com/R6VNNw5.png" alt=""></p>
<p>  2.层级选择器<br><img src="http://i.imgur.com/x6i944Z.png" alt=""></p>
<p>  .next .nextAll等价和等级关系<br> <img src="http://i.imgur.com/iE3X4oX.png" alt=""><br> <img src="http://i.imgur.com/dVXlV3c.png" alt=""></p>
<p>  3.属性选择器<br><img src="http://i.imgur.com/e3JWrlv.png" alt=""></p>
<p>  4.筛选选择器<br><img src="http://i.imgur.com/tTqQCNF.png" alt=""></p>
<p>  5.父子兄弟选择</p>
<p>.parent();获取匹配元素的父元素;<br>.parents();获取匹配元素的祖先元素;<br>.children();获取匹配元素的子元素;<br>.siblings();获取匹配元素的兄弟元素;</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-jQuery网页的应用" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/05/23/jQuery网页的应用/" class="article-date">
      <time datetime="2017-05-23T14:06:10.000Z" itemprop="datePublished">2017-05-23</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/23/jQuery网页的应用/">first</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="JQUERY的网页应用"><a href="#JQUERY的网页应用" class="headerlink" title="#JQUERY的网页应用"></a>#JQUERY的网页应用</h1><p> /<em>一.设置吸顶效果</em>/</p>
<p> /<em>1.0获取NAV距离顶部的间距</em>/</p>
<p>/<em>1.1监听滚动，设置对应的样式</em>/</p>
<p>/<em>1.2获取滚动的距离</em>/</p>
<p>/<em>1.3判断比较设置样式</em>/</p>
<p>/<em>1.31设置图片的透明度，让图片出来</em>/</p>
<p>  /<em>二.设置返回顶部</em>/</p>
<p> //2.1判断</p>
<p>/<em>2.2点击BACK_TOP返回顶部</em>/</p>
<p> //2.21让回到顶部</p>
<p> /<em>三.添加LI</em>/<br>/<em>3.0使用数组来记录事项</em>/</p>
<p> /<em>当界面加载进来的时候，就去从从存储的数据中拿出对应的数据，如果没有才去加载</em>/</p>
<p> /<em>渲染界面</em>/</p>
<p>/<em>3.0去掉默认行为</em>/</p>
<p>/<em>3.1获取INPUT中内容，判断</em>/</p>
<p>  /<em>3.2创建事项</em>/</p>
<p>/<em>3.2设置事项的相关属性</em>/</p>
<p>/<em>3.3添加到数组中中保存起来</em>/</p>
<p> /<em>3.4根据数组的长度，添加节点而且吧节点显示出来</em>/</p>
<p> /<em>3.5存储数据</em>/</p>
<p> /*0.存储数据，第一个参数用来表示存储的数据的标示，任何值都可以，只是用这个值来取出数据</p>
<pre><code>* 第二个参数表示要存储的数据*/
</code></pre><p>/<em>把上一次的内容清空</em>/</p>
<p>/<em>注意：为了让对应的CHECKBOX点击的时候，让对应的不同的事项中添加不同的LI</em>/</p>
<p>/<em> 所以我们需要改造渲染方法</em>/</p>
<p>  /<em>3.41根据数组中的个数。来添加节点</em>/</p>
<p>//为了规范和严格要进行元素的判定</p>
<p> /<em>3.42创建LI</em>/</p>
<p>  // DATA-INDEX:用来给LI绑定索引</p>
<p>  /<em>3.43添加LI</em>/</p>
<p>   /<em>根据是否检查过，来确定添加到待选事件还是完成事件</em>/</p>
<p>/<em>四.切换TAB</em>/</p>
<p>   /<em>4.1点击LI切换TAB</em>/</p>
<p>   /<em>4.2获取点击的索引值</em>/</p>
<p>   /<em>4.3切换下面的DIV</em>/<br>/<em>五，点击删除按钮删除对应的LI</em>/</p>
<p>/<em>5.1获取DEL所在的LI</em>/</p>
<p>/<em>5.2获取LI对应的索引值</em>/</p>
<p>/<em>5.3为了代码严格，我们可以回索引进行判断</em>/</p>
<p> /<em>5.4删除数组中的元素</em>/</p>
<p>/<em>5.5删除节点</em>/</p>
<p>/<em>5.6存储数据</em>/</p>
<p>/<em>六.点击待办事项，让对应的事项有待办变为已经完成</em>/</p>
<p>/<em>6.1确定点击的索引</em>/</p>
<p>/<em>6.2拿出INDEX中对应的数组中的元素</em>/</p>
<p>/<em>6.3设置ISCHECK为选中</em>/</p>
<p>/<em>用OBJ替换原来位置的元素</em>/</p>
<p> /<em>6.4进行界面设置</em>/</p>
<p> /<em>6.5存储数据</em>/</p>
<p> /<em>七.点击详情按钮的处理</em>/</p>
<p> /<em>设置一个值用来表示当前点击的是哪一个</em>/</p>
<p> /<em>7.1设置让对应MASK出来</em>/</p>
<p> /<em>7.2获取点击详情按钮的索引</em>/</p>
<p>/<em>7.21设置CURR_INDEX的值</em>/</p>
<p>/<em>7.3根据索引值获取数组中对应的元素</em>/</p>
<p> /<em>7.4根据对应的事项设置我们具体的内容</em>/</p>
<p>/<em>7.41设置标题</em>/</p>
<p>/<em>7.42设置内容</em>/</p>
<p>/<em>7.43设置提醒时间</em>/</p>
<p> /<em>八.处理事件的相关点击</em>/</p>
<p>  /<em>8.1点击内容阻止冒泡</em>/</p>
<p>/<em>8.11阻止冒泡</em>/</p>
<p>  /<em>8.2设置当光标移动到INPUT中设置时间的时候，让对应的时间的选择器展示出来</em>/</p>
<p>  /<em>8.21设置本地化时间(设置中国时间)</em>/</p>
<p>   /<em>8.22给对应的标签设置对应时间选择器</em>/</p>
<p>/<em>九.更新数据和界面</em>/</p>
<p>  /<em>9.1获取点击详细按钮对应的索引值</em>/</p>
<p>   /<em>9.2根据索引值获取对应数组中的元素</em>/</p>
<p>/<em>9.3设置元素的数据</em>/</p>
<p> /<em>IS_NOTICE：表示有没有提醒去做对应事项</em>/</p>
<p>/<em>9.4赋值回原来的位置</em>/</p>
<p> /<em>9.5存储数据</em>/</p>
<p>/<em>9.6更新界面</em>/</p>
<p>/<em>9.7让当前的MASK消失</em>/</p>
<p> /<em>十.提醒设置</em>/</p>
<p>/<em>10.1我们需要时时刻刻比较当前的时间和设置的时间，所以要使用定时器</em>/</p>
<p> /<em>10.2获取每一元素的的提醒时间，和当前时间比较，需要使用遍历</em>/</p>
<p>/<em>10.3判断当前的时间是否大于提醒时间</em>/</p>
<p>  /<em>10.31获取每一提醒时间的毫秒数</em>/</p>
<p>  //需要提醒，让对应铃声响起</p>
<p>   /<em>获取的对象是JQUERY对象我们需要转化成JS对象</em>/</p>
<p>/<em>10.4当铃声响起后，表示已经提醒过了，我们要设置提醒为<br>TRUE</em>/</p>
<p> /<em>10.5重新赋值</em>/</p>
<p> /<em>10.6数据变化，就要存储数据</em>/# #</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2017 IT点彼岸
            </div>
            <div class="footer-right">
                <a href="http://itidan.cn/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>