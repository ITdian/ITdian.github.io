<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Angular的MVC和MVVM以及模块化和指令认识]]></title>
      <url>/2017/06/15/%E5%AD%A6%E4%B9%A0Angular/</url>
      <content type="html"><![CDATA[<p>#Angular</p>
<p>##一:MVC和MVVM的介绍</p>
<p>###MVC</p>
<p>####①什么是MVC?<br><img src="http://i.imgur.com/d8iezB0.png" alt="MVC图示"><br><strong>模型(Model)</strong>:模型是应用程序的主题部分。模型表示业务逻辑，或者业务逻辑。</p>
<p><strong>视图(View)</strong>:视图是应用程序中用户界面相关的部分,是用户看到并与之交互的界面。</p>
<p><strong>控制器(Controller)</strong>：控制器工作就是根据用户的输入，控制用户界面数据显示和更新model对象状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">**使用MVC的好处是有较好的可移植性和组件的可复用性**</div></pre></td></tr></table></figure>
<p>####①什么是MVVM?<br><img src="http://i.imgur.com/dOCSo9v.png" alt="MVVM图示"></p>
<p><strong>模型(Model)视图(View)</strong>:可以通过模型到视图传递数据;</p>
<p><strong>视图模型(ViewModel/VM)</strong>:视图也可以传递数据;</p>
<p><strong>MVVM</strong>:属于数据的双向绑定。<br>个人觉得阮一峰讲的比较好一点：<br><a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" title="MVC，MVP 和 MVVM 的图示" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html</a></p>
<p>##二:模块化</p>
<p>###什么是模块化?</p>
<p>AngularJS构建应用(APP)时是以模块化(Module)的方式组织的,即将整个应用划分为若干模块,每个模块都有各自的职责,最终组合成一个整体。采用模块化的组织方式，可以最大程度的实现代码的复用。</p>
<p>###如何定义模块?<br>1.创建模块：Angular提供了一个全局对象angular，在此全局对象下存在若干的方法，其中angular.module（）方法用来定义一个模块：</p>
<p><strong>第一个参数：控制器的名称</strong></p>
<p><strong>第二个参数：依赖模块名称</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var app = angular.module(&quot;app&quot;,[]);</div></pre></td></tr></table></figure>
<p>2.创建控制器:控制器(Controller)作为连接模型(Model)和视图(View)的桥梁存在,所以当我们定义好了控制器以后也就定义好了模型和视图。</p>
<p><strong>第一个参数：控制器的名称</strong></p>
<p><strong>第二个参数：依赖的服务</strong></p>
<p>app.controller(“名称”,[“$scope”,function($scope){}]);</p>
<pre>
app.controller("bbController",["$scope",function ($scope) {
        $scope.name = "test";
        $scope.age  = 2;
        $scope.arr = ["window","office","iso"];
        $scope.bb_user = [
            {"name":"xm","age":18},
            {"name":"hh","age":16}
        ]

        }])
</pre>
3.绑定模块:ng-app = "模块名称"
<pre>
< body ng-app="app">
</pre>

<p>4.绑定控制器:ng-controller = “控制器名称”</p>
<pre>
< body ng-app="app">
< ul ng-controller="bbController">
    < li>
    < li ng-bind="age">
    < br>
    < li ng-repeat="(key,value) in arr">
    < li ng-repeat="value in bb_user">
< /ul>
</pre>

<p>##三:指令</p>
<p>###1.内置指令</p>
<p>####什么是指令?<br>HTML在构建应用(APP)时候存在诸多不足之处,Angular通过扩展一系列的HTML属性或标签,这些指令都是以ng-作为前缀的,例如ng-app、ng-controller、ng-repeat等。</p>
<p>内置指令主要有以下指令：</p>
<p><strong>ng-app：</strong>指定应用根元素，至少有一个元素指定了此属性；</p>
<p><strong>ng-controller：</strong>指定控制器；</p>
<p><strong>ng-show：</strong>控制元素是否显示，true为显示，false为不显示；</p>
<p><strong>ng-hide：</strong>控制元素是否异常，true为隐藏，false为不隐藏；</p>
<p><strong>ng-if：</strong>控制元素是否”存在”,true存在,false不存在;</p>
<p><strong>ng-img:</strong>增强图片路径</p>
<p><strong>ng-href:</strong>增强地址</p>
<p><strong>ng-class:</strong>控制类名</p>
<p><strong>ng-include:</strong>引入模板</p>
<p><strong>ng:disabled:</strong>表单禁用</p>
<p><strong>ng-readonly:</strong>表单只读</p>
<p><strong>ng-checked:</strong>单/复选框表单选中     </p>
<p><strong>ng-selected:</strong>下拉框表单选中</p>
<p>###2.事件处理</p>
<p>####使用方法为:</p>
<p>ng-事件名称 = “事件响应方法名称(参数)”;</p>
<p><strong>参数可以自己指定,也可以传入对象$(event)</strong></p>
<p>使用$scope来去实现事件定义的方法</p>
<pre>
$scope.事件名称 = function(参数){

}
</pre>
html代码
<pre>
< !--单击事件:ng-click="click()-->
< p ng-click="click($event,'p')">p< /p>
< !--双击事件:ng-dblclick="dblclick($event,'h2')"
    鼠标移入事件:ng-mouseenter="mouserEnter()-->
< h2 ng-dblclick="dblclick($event,'h2')" ng-mouseenter="mouserEnter()">h2< /h2>
</pre>
js代码
<pre>
        //定义的事件方法实现
        $scope.click = function (e,ar) {
            alert(this.name);//在这里,this代表$scope
            console.log($scope.age);
        };
        $scope.dblclick = function () {
            alert("dbl")
        };
        $scope.mouserEnter = function () {
            console.log("mouserEnter")
        }
</pre>

<p><strong>注意:一定要看清楚$scope的作用域</strong></p>
<p>###3.自定义指令<br>Angularjs允许根据实际业务需要自定义指令,通过angular全局对象下的directive方法实现</p>
<p>自定义指令:</p>
<p><strong>第一个参数 指令名称</strong></p>
<p><strong>第二个参数 回调函数</strong><br>html文件:直接把nav当做标签插入html中</p>
<pre>
   app.directive("nav",[function () {
    /* < nav>< /nav>          E:元素
         < !-- directive:nav -->  A:属性
         < h2 nav>< /h2>          C:当做类
         < p class="nav">< /p>    M:可以注释形式出
        * */
        return{
            //E:元素   A:属性   C:当做类   M:可以注释形式出
            restrict:'EA',
            // template:' < ul>< li>列表< /li>< li>列表< /li>< li>列表< /li>< /ul>',
            templateUrl:'./nav.html',
            replace:true    //是否替换原标签
        }
    }])
</pre>
###4.控制器作用域
先找自身,再去找父级,自己可以访问父级的元素,父级不能访问子级的元素,

**每个控制器(Controller)又都对应一个模型(Model)也就是$scope对象**

**不同层级控制器(Controller)下的$scope便产生了作用域**

<pre>
;(function (angular) {
    var app = angular.module('app',[]);
    app.controller('bbController1',['$scope',function ($scope) {
        $scope.name = '1'
    }]);
    app.controller('bbController2',['$scope',function ($scope) {
        $scope.name = '2'
    }]);

})(angular);
</pre>
HTML代码
<pre>
< body ng-app="app" ng-controller="bbController1" >
< p ng-controller="bbController2">< /p> < !--2-->
< p>< /p>  < !--1-->
< /body>
</pre>

<p>ng-init初始化全局变量,一个AngularJS的应用(App)在启动时会自动创建一个根作用域$rootScope,这个根作用域在整个应用范围(ng-app所在标签内)都是可以被访问到的,使用<strong>ng-init = “属性名称=属性值”</strong>,使用ng-init创建的就是根作用域</p>
<pre>
< body ng-app="app" ng-init="name='init'">
< !--ng-init="name='init' 全局的name变成init-->
< p ng-controller="bbController2">< /p>  < !--2global-->
< p>< /p> <!--1-->
< p ng-controller="bbController1">< /p> <!--1-->
</pre>
<pre>
< body ng-app="app" ng-controller="bbController1" >
< p ng-controller="bbController2">< /p>  < !--2global-->
< p>< /p> <!--1-->
</pre>

<p>js代码</p>
<pre>
(function (angular) {
    var app = angular.module('app',[]);
    app.controller('bbController1',['$scope',"$rootScope",function ($scope,$rootScope) {
        $rootScope.name1 = 'global';
        $scope.name = '1'
    }]);
    app.controller('bbController2',['$scope',function ($scope) {
        $scope.name = '2'
    }]);

})(angular);
</pre>]]></content>
      
        
        <tags>
            
            <tag> Angular </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Angular]]></title>
      <url>/2017/03/25/ngRoute%E5%92%8Cui-route/</url>
      <content type="html"><![CDATA[<p>##angular 中的ngRoute 和ui-route</p>
<p>原生的angular不支持路由的嵌套,而且一个HTML页面中一般只有一个ng-view;</p>
<p>需求:如果一个界面需要多个视图模板,这个ngRoute做不了,所以引出了ui-route</p>
]]></content>
      
        
        <tags>
            
            <tag> 前端框架_Angular </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[php基本认识]]></title>
      <url>/2017/02/15/php%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86/</url>
      <content type="html"><![CDATA[<p>#php基本语法</p>
<p>##定义变量<br>$number = 10;<br><a id="more"></a></p>
<p>##数据类型<br>$nValue = 10;</p>
<p>$sValue  =’string’;</p>
<p>$bValue = true;</p>
<p>##打印<br>echo “打印”;</p>
<p>##数组<br>$arr  = array(1,2,3,4);</p>
<p>##字典(json)<br>$dict = arra(“name”=&gt;”bb”,”age”=&gt;18);</p>
<p>##if语法</p>
<pre>
$number = 19;
if($number>=18){
    echo "成年人";
}else{
    echo "未成年人";
}
</pre>

<p>##switch语法</p>
<pre>
$score = 90;
switch ($score){
    case 60:
        echo "及格";
        break;
    case 90:
        echo "优秀";
        break;
    default:
        echo "少年还需要努力!"    
}
</pre>

<p>##三目运算符</p>
<p>$age = 18;</p>
<p>$res = $age&gt;=18?”成年人”:”未成年人”;</p>
<p>##输出数组<br>$arr  = array(1,2,3,4);<br>prinf_r($arr);</p>
<p>##while语法<br>$index  = 0;<br>while ($index &lt; $conut($arr)){<br>        echo $arr[$index];<br>        echo “<br>“;<br>        $index++;<br>}</p>
<p>##for语法<br>for($index &lt; 0;$index &lt;conut($arr);$index ++){<br>        echo $arr[$index];<br>        echo “<br>“;<br>}</p>
]]></content>
      
        
        <tags>
            
            <tag> 后端_php </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[webApp项目]]></title>
      <url>/2017/02/15/wabAPP/</url>
      <content type="html"><![CDATA[<p>##webAPP项目的步骤<br>全局安装gulp   npm install gulp -g (只需要执行一次，如果已经执行过了，就不需要再去执行。Gulp -v 有版本号，代表已经执行过了)<br><a id="more"></a></p>
<p>创建一个webAPP项目的目录</p>
<p>一:进入(webAPP)使用git bush here</p>
<p>1.使用npm init命令初始化一个项目命名为web-app(注:命名时候这里不能使用大写,所以用-代替)<br>{这里也可以直接用npm init -f就会直接生成不用一步步的enter}</p>
<p>2.创建成功会生成一个package.json文件,记录当前项目当中依赖其他插件,可以按ctrl+c退出.</p>
<p>3.创建src目录, —&gt;进入创建js/style/view/images文件夹   </p>
<p> 4.把gulpfile拷贝到项目的根目录下,即是跟package.json同一级目录下.</p>
<p>5.下载gulp所需要的插件: </p>
<pre>
npm install gulp gulp-less gulp-cssmin gulp-uglify gulp-concat gulp-connect gulp-imagemin open --save-dev 
</pre>
--save-dev :把所需要的插件写到
 package.json中 

可以加上淘宝镜像地址:
<pre>--registry=https://registry.npm.taobao.org</pre>

<p>6.在根目录下执行gulp命令,注意没修改一次文件夹都要退出再进行gulp一次.</p>
<p>7.热更新的时候,只要按下保存ctrl+s,相对应网页的界面也会做出相对应的修改.</p>
<p>8.在引入css和js的时候,首先要明白一点,我们运行的HTML界面是build里面的,所以全部的东西引入都是以它为主,src里面的内容不用运行,所以它的路径错误也不会报错也导致文件无法运行.</p>
<p>9.运行在移动端要设置视口;<br>快捷键:meta:vp</p>
<pre>
< meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0" >
</pre>


<p>10.设置页面的字体大小</p>
<pre>
< script>
    var font = window.screen.width / 10 + 'px';
    document.getElementsByTagName('html')[0].style.fontSize = font;
< /script>
</pre>



<p>11.做手机网页时，是如何进行适配？ Rem与像素之间的关系。<br> .1 必须得要设置视口。</p>
<p> .2 选择rem为单位进行开发。 px在手机里面不是以像素为单位，以点坐标为单位.</p>
<p> .3.默认情况，在页面当中， 是根据html字体的大小进行缩放。 1rem = 100px/10.0  选择一个缩放比。</p>
<p> .4 在做手机网页时， 我们一般都会先设置html的字体。1rem = 10px<br>  rem 它是以html页面字体大小做为参考。</p>
<p>12.css的公用样式</p>
<p>normalize.less:html的基本样式</p>
<p>variable.less font从px转化成rem单位的.</p>
]]></content>
      
        
        <tags>
            
            <tag> WebApp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[gulp]]></title>
      <url>/2016/12/25/gulp/</url>
      <content type="html"><![CDATA[<p>Gulp是一个工具。用于项目构建。<br>Gulp简介：<br>多个开发者共同开发一个项目，每位开发者负责不同的模块，这就会造成一个完整的项目实际上是由许多的“代码版段”组成的；</p>
<p>使用less、sass等一些预处理程序，降低CSS的维护成本，最终需要将这些预处理程序进行解析；合并css、javascript，压缩html、css、javascript、images可以加速网页打开速度，提升性能；<br><a id="more"></a><br>这一系列的任务完全靠手动完成几乎是不可能的，借助构建工具可以轻松实现。<br>所谓构建工具是指通过简单配置就可以帮我们实现合并、压缩、校验、预处理等一系列任务的软件工具。<br>常见的构建工具包括：Grunt、Gulp、F.I.S（百度出品）、webpack</p>
<p>Gulp是基于Nodejs开发的一个构建工具，借助gulp插件可以实现不同的构建任务，以其简洁的配置和卓越的性能成为目前主流的构建工具。</p>
<p>安装：<br>1.先要全局安装<br>$ npm install -g gulp –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="external">https://registry.npm.taobao.org</a></p>
<p>2.再本地安装。<br>切换到项目目录。<br>$ npm install gulp –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="external">https://registry.npm.taobao.org</a></p>
<p>###1.全局安装gulp   npm install gulp -g (只需要执行一次，如果已经执行过了，就不需要再去执行。Gulp -v 有版本号，代表已经执行过了)</p>
<p>###2.创建项目目录 （webApp）</p>
<p>###3.npm init -f  创建一个package.json 记录当前项目当中依赖其它插件</p>
<p>###4.创建src目录–&gt;进入src创建js/style/view文件夹</p>
<p>###5.把gulpfile拷贝到项目根目录当中</p>
<p>###6.下载gulp所需要的插件<br>      npm install gulp gulp-less gulp-cssmin gulp-uglify gulp-concat gulp-connect gulp-imagemin open –save-dev </p>
<p>###7.执行gulp</p>
<p>###8.手机屏幕适配</p>
<pre>
<
meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"
>
</pre>
###9.设置页面的字体大小
<pre>
< script>
    var font = window.screen.width / 10 + 'px';
    document.getElementsByTagName('html')[0].style.fontSize = font;
< /script>
</pre>

<p>###10.做手机网页时，是如何进行适配？ Rem与像素之间的关系。</p>
<p>  .1 必须得要设置视口。</p>
<p>  .2 选择rem为单位进行开发。 px在手机里面不是以像素为单位，以点坐标为单位。</p>
<p>  .3.默认情况，在页面当中， 是根据html字体的大小进行缩放。 1rem = 100px/10.0  选择一个缩放比。</p>
<p>  .4 在做手机网页时， 我们一般都会先设置html的字体。1rem = 10px,rem 它是以html页面字体大小做为参考。</p>
<p>##学习gulp就是学习它的方法和它的插件。<br>Gulp工作原理：<br><img src="http://i.imgur.com/I2Uq9Gs.png" alt=""></p>
<p>Gulp是指挥别的插件做任务的运行器。它是一个管理者。<br>这样做的目的是为了方便扩展。 小霸王 插卡。<br>学习gulp就是学习gulp的插件。</p>
]]></content>
      
        
        <tags>
            
            <tag> 构建工具 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jQuery选择器]]></title>
      <url>/2016/06/25/jQuery%E7%9A%84%E9%80%89%E6%8B%A9%E5%99%A8/</url>
      <content type="html"><![CDATA[<h1 id="jQuery选择器"><a href="#jQuery选择器" class="headerlink" title="jQuery选择器"></a>jQuery选择器</h1><p>jQuery 最核心的组成部分就是:选择器引擎。<br>   它完全继承了 CSS 的风格,可以对 DOM 元 素的标签名、属性名、状态等进行快速准确的选择,并且不必担心浏览器的兼容性,写法更加简洁。<br>jQuery 选择器实现了 CSS1~CSS3 的大部分规则之外,还实现了一些自定义的选择器,用于各种特殊状态的选择。 </p>
<a id="more"></a>
<h2 id="选择器的分类"><a href="#选择器的分类" class="headerlink" title="选择器的分类:"></a>选择器的分类:</h2><p>  <strong>1.基本选择器</strong></p>
<p>  <strong>2.层级选择器</strong></p>
<p>  <strong>3.属性选择器</strong></p>
<p>  <strong>4.筛选选择器</strong></p>
<p>  <strong>5.表单选择器</strong><br><!-- more --><br>  1.基本选择器<br><img src="http://i.imgur.com/R6VNNw5.png" alt=""></p>
<p>  2.层级选择器<br><img src="http://i.imgur.com/x6i944Z.png" alt=""></p>
<p>  .next .nextAll等价和等级关系<br> <img src="http://i.imgur.com/iE3X4oX.png" alt=""><br> <img src="http://i.imgur.com/dVXlV3c.png" alt=""></p>
<p>  3.属性选择器<br><img src="http://i.imgur.com/e3JWrlv.png" alt=""></p>
<p>  4.筛选选择器<br><img src="http://i.imgur.com/tTqQCNF.png" alt=""></p>
<p>  5.父子兄弟选择</p>
<p>.parent();获取匹配元素的父元素;<br>.parents();获取匹配元素的祖先元素;<br>.children();获取匹配元素的子元素;<br>.siblings();获取匹配元素的兄弟元素;</p>
]]></content>
      
        
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[开发流程]]></title>
      <url>/2016/05/15/%E5%B7%A5%E4%BD%9C%E5%BD%93%E4%B8%AD%E7%9A%84%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>###工作当中的开发流程<br><img src="http://i.imgur.com/mHPkxxd.png" alt=""><br><a id="more"></a><br><img src="http://i.imgur.com/yZZbwHx.png" alt=""></p>
]]></content>
      
        
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Zepto]]></title>
      <url>/2016/03/15/Zepto/</url>
      <content type="html"><![CDATA[<p>###Zepto.js</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1268909-e7880615d282a4d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>随着移动端的愈加火爆，目前很多HTML5的框架都在支持移动方向，比如：Vue.js，zepto.js，React Native等等。<br><a id="more"></a><br>Zepto 是一个轻量级的针对现代高级浏览器的 JavaScript 库， 它与jquery 有着类似的api。 如果你会用 jquery，那么你也会用 zepto。</p>
<p>Zepto的设计目的是提供 jQuery 的类似的API，但并不是100%覆盖 jQuery 。Zepto设计的目的是有一个5-10k的通用库、下载并快速执行、有一个熟悉通用的API，所以你能把你主要的精力放到应用开发上。</p>
<p><strong>思考：jQuery和Zepto.js的区别在哪里？</strong></p>
<p>（1）jQuery更多是在PC端被应用，因此，考虑了很多低级浏览器的的兼容性问题；而Zepto.js则是直接抛弃了低级浏览器的适配问题，显得很轻盈；</p>
<p>（2）Zepto.js在移动端被运用的更加广泛；</p>
<p>（3）jQuery的底层是通过DOM来实现效果的， zepto.js 是用css3 来实现的；</p>
<p>（4）Zepto.js可以说是阉割版本的jQuery。 <img src="http://upload-images.jianshu.io/upload_images/1268909-e4941bbfdc3461af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><strong>1.1   浏览器兼容</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Safari 6+ </div><div class="line">Chrome 30+ </div><div class="line">Firefox 24+ </div><div class="line">iOS 5+ Safari </div><div class="line">Android 2.3+ Browser </div><div class="line">Internet Explorer 10+</div></pre></td></tr></table></figure>
<p><strong>1.2  Zepto初体验.html</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">    &lt;html lang=&quot;en&quot;&gt;</div><div class="line">    &lt;head&gt;</div><div class="line">        &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">        &lt;title&gt;&lt;/title&gt;</div><div class="line">        &lt;style&gt;</div><div class="line">            .box&#123;</div><div class="line">                width: 200px;</div><div class="line">                height: 200px;</div><div class="line">                background-color: #ccc;</div><div class="line">                margin: 20px;</div><div class="line">            &#125;</div><div class="line">        &lt;/style&gt;</div><div class="line">    &lt;/head&gt;</div><div class="line">    &lt;body&gt;</div><div class="line">       &lt;button&gt;点我&lt;/button&gt;</div><div class="line">       &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</div><div class="line"></div><div class="line">    &lt;!--&lt;script src=&quot;js/jquery-1.7.2.min.js&quot;&gt;&lt;/script&gt;--&gt;</div><div class="line">    &lt;script src=&quot;js/zepto.min.js&quot;&gt;&lt;/script&gt;</div><div class="line">    &lt;script&gt;</div><div class="line">        $(function () &#123;</div><div class="line">            $(&apos;button&apos;).click(function () &#123;</div><div class="line">                $(&apos;.box&apos;).css(&apos;background-color&apos;, &apos;red&apos;);</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &lt;/script&gt;</div><div class="line">    &lt;/body&gt;</div><div class="line">    &lt;/html&gt;</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/1268909-fc685569c04e5f11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1268909-d49d1aed43382e4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><strong>1.3  Zepto官网</strong></p>
<p>英文版：http:\/\/zeptojs.com\/</p>
<p>中文版：http:\/\/www.css88.com\/doc\/zeptojs_api\/</p>
<p><strong>1.4  Zepto设计模块</strong></p>
<p>zepto 为了保持足够的轻量和效率，只保留了默认的最基本的功能，其他的功能，如果有需要，只要再次引入就可以了；</p>
<p>注意：jQuery的底层是通过DOM来实现效果的， zepto 是用css3 来实现的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1268909-ce235da18fc89367.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><strong>1.5   案例实现：Zepto选择器.html</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">    &lt;html lang=&quot;en&quot;&gt;</div><div class="line">    &lt;head&gt;</div><div class="line">        &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">        &lt;title&gt;&lt;/title&gt;</div><div class="line">        &lt;style&gt;</div><div class="line">            div&#123;</div><div class="line">                width: 200px;</div><div class="line">                height: 200px;</div><div class="line">                background-color: red;</div><div class="line">                margin: 10px;</div><div class="line">            &#125;</div><div class="line">        &lt;/style&gt;</div><div class="line">    &lt;/head&gt;</div><div class="line">    &lt;body&gt;</div><div class="line">        &lt;button&gt;改变第二个颜色&lt;/button&gt;</div><div class="line">        &lt;div&gt;&lt;/div&gt;</div><div class="line">        &lt;div&gt;&lt;/div&gt;</div><div class="line"></div><div class="line">    &lt;!--&lt;script src=&quot;js/jquery-1.7.2.min.js&quot;&gt;&lt;/script&gt;--&gt;</div><div class="line">    &lt;script src=&quot;js/zepto.min.js&quot;&gt;&lt;/script&gt;</div><div class="line">    &lt;script src=&quot;js/selector.js&quot;&gt;&lt;/script&gt;</div><div class="line">    &lt;script&gt;</div><div class="line">        $(function () &#123;</div><div class="line">            $(&apos;button&apos;).click(function (event) &#123;</div><div class="line">                 $(&apos;div:eq(1)&apos;).css(&apos;background-color&apos;, &apos;blue&apos;);</div><div class="line">                // $(&apos;div&apos;).eq(1).css(&apos;background-color&apos;, &apos;blue&apos;);</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &lt;/script&gt;</div><div class="line">    &lt;/body&gt;</div><div class="line">    &lt;/html&gt;</div></pre></td></tr></table></figure>
<p><strong>1.6   tap 和 click 的区别</strong></p>
<p>tap 只作用在移动端，PC端是无效的;</p>
<p>click 在pc端和移动端都是ok的;</p>
<p>但是我们在移动端要用tap，因为 tap 比 click 快200-300ms。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 禁止触发默认的手势</div><div class="line">* &#123; touch-action: none; &#125;</div></pre></td></tr></table></figure>
<p><strong>1.7  zepto 和  jquery</strong></p>
<p>zepto默认只具有基本的模块，其他功能模块需要单独引用，引用的模块，必须放在zepto的后面，fx.js 和fx_methods.js 他们之间必须是fx_methods.js在fx.js的后面；其他的包之间顺序无所谓；</p>
<p>jQuery默认是一个文件中，包含所有的功模块；</p>
<p>zepto的底层是通过css3 实现的，jQuery是操作的DOM,所以有些css3的效果，是jquery做不到的；</p>
<p>zepto比jQuery多了更多的移动端的 事件的支持，比如说tap， swipe……</p>
<p>zepto的兼容性比jQuery差，因为zepto更多的是注重移动端和效率，jQuery注重的是兼容性。</p>
<p>注意：zepto上面的动画，不要加太多， 因为动画很耗性能，加多了会很卡，特别是一些webview开发；</p>
<p><img src="/assets/place.png" alt=""></p>
]]></content>
      
        
        <tags>
            
            <tag> 前端框架_Zepto </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swiper]]></title>
      <url>/2016/03/15/swiper/</url>
      <content type="html"><![CDATA[<h3 id="一、swiper"><a href="#一、swiper" class="headerlink" title="一、swiper"></a>一、swiper</h3><p><strong>1.1  简介</strong></p>
<p>swiper是一款免费以及轻量级的移动设备触控滑块的js框架，主要是为iOS设计，同时，在Android、WP系统和其他PC浏览器上也有着良好的体验。<br><a id="more"></a></p>
<p><strong>1.2  特点</strong></p>
<p>轻量级，简洁高效，可定制性非常高；</p>
<p>横跨各种设备，兼容IOS、Android、WP、PC端设备；</p>
<p>提供多种版本支持（可自由选择jQuery\/zepto版或原生js）。</p>
<blockquote>
<p>注意:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1268909-405029e74adf38ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>swiper从3.0开始不再全面支持PC端。因此，如需要在PC上兼容更多浏览器，可以选择swiper 2.x(支持IE7)。</p>
</blockquote>
<p><strong>1.3  如何使用？</strong></p>
<p>// 引入文件</p>
<p>  <link rel="stylesheet" href="“css/swiper.min.css"">
  <script src="“js/swiper.min.js""></script></p>
<p>// HTML结构</p>
<pre>
< div class="swiper-container">
  < div class="swiper-wrapper">
      < div class="swiper-slide">Slide 1
      < div class="swiper-slide">Slide 2
      < div class="swiper-slide">Slide 3
   < /div>
< /div>
</pre>

<p>//Js文件调用</p>
<p>var swiper = new Swiper(‘.swiper-container’);           </p>
<p><strong>1.4  高级效果和参数</strong></p>
<p>html部分:</p>
<pre>

 < div class="swiper-container">
      < div class="swiper-wrapper">
           < div class="swiper-slide">Slide 1
           < div class="swiper-slide">Slide 2
           < div class="swiper-slide">Slide 3
      < /div>

      < !-- 如果需要分页器 -->
      < div class="swiper-pagination">

      < !-- 如果需要导航按钮 -->
      < div class="swiper-button-prev">
      < div class="swiper-button-next">

      < !-- 如果需要滚动条 -->
      < div class="swiper-scrollbar">

</pre>

<p>JS部分:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var mySwiper = new Swiper (&apos;.swiper-container&apos;, &#123;</div><div class="line">         // 如果需要分页器</div><div class="line">         pagination: &apos;.swiper-pagination&apos;,</div><div class="line"></div><div class="line">         // 如果需要前进后退按钮</div><div class="line">         nextButton: &apos;.swiper-button-next&apos;,</div><div class="line">         prevButton: &apos;.swiper-button-prev&apos;,</div><div class="line"></div><div class="line">         // 如果需要滚动条</div><div class="line">         scrollbar: &apos;.swiper-scrollbar&apos;,</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>其他常用参数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;pre&gt;</div><div class="line">loop: true,         //循环开关</div><div class="line">autoplay: 3000,         //自动播放间隔时间（单位：毫秒）默认不自动播放</div><div class="line">direction: &apos;vertical&apos;,   //切换方向   水平(horizontal)或垂直(vertical)</div><div class="line">speed:300,           //切换速度（单位：毫秒）</div><div class="line">keyboardControl:true,          //键盘控制开关</div><div class="line">paginationType:‘bullets’,     //分页器外观   bullets 、  fraction 、  progress</div><div class="line">effect: &apos;fade&apos;,       //切换效果  fade、cube、coverflow、flip</div><div class="line">……</div><div class="line">&lt;/pre&gt;</div></pre></td></tr></table></figure>
<p><strong>1.5  官方文档</strong></p>
<p><a href="http://www.swiper.com.cn/" target="_blank" rel="external">http:\/\/www.swiper.com.cn\/</a></p>
<p><strong>1.6  swiper animate</strong></p>
<p>使用:   引入文件(比之前多了animate.css 和swiper.animate.js)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;link rel=&quot;stylesheet&quot; href=“css/swiper.min.css&quot;&gt;</div><div class="line">&lt;link rel=&quot;stylesheet&quot; href=“css/animate.min.css&quot;&gt;</div><div class="line">&lt;script src=“js/swiper.min.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script src=“js/swiper.animate.min.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>HTML结构: 在需要运动的元素上面增加类名 ani, 然后添加swiper animate 参数。</p>
<p>swiper-animate-effect：切换效果，例如 fadeInUp</p>
<p>swiper-animate-duration：动画持续时间（单位秒），例如 0.5s</p>
<p>swiper-animate-delay: 延迟时间（单位秒）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;pre&gt;</div><div class="line">&lt; div class=&quot;swiper-container&quot;&gt;</div><div class="line">   &lt; div class=&quot;swiper-wrapper&quot;&gt;</div><div class="line">     &lt; div class=&quot;swiper-slide&quot;&gt;</div><div class="line">         &lt; p class=&quot;ani&quot; </div><div class="line">            swiper-animate-effect=&quot;fadeInUp&quot; </div><div class="line">            swiper-animate-duration=&quot;0.5s&quot; </div><div class="line">            swiper-animate-delay=&quot;0.3s&quot;&gt;</div><div class="line">            Slider 1</div><div class="line">         &lt; /p&gt;</div><div class="line">      &lt; /div&gt;</div><div class="line">    &lt; /div&gt;</div><div class="line"> &lt; /div&gt;</div><div class="line">&lt;/pre&gt;</div></pre></td></tr></table></figure>
<p>JS文件调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var mySwiper = new Swiper (&apos;.swiper-container&apos;, &#123;</div><div class="line">    onInit: function(swiper)&#123; //Swiper2.x的初始化是onFirstInit</div><div class="line">        swiperAnimateCache(swiper); //隐藏动画元素</div><div class="line">        swiperAnimate(swiper);   //初始化完成开始动画</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    onSlideChangeEnd: function(swiper)&#123;</div><div class="line">        swiperAnimate(swiper);  //每个slide切换结束时也运行当前slide动画</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> 前端框架_swiper </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Less]]></title>
      <url>/2016/02/15/Less/</url>
      <content type="html"><![CDATA[<h3 id="LESS"><a href="#LESS" class="headerlink" title="LESS"></a>LESS</h3><p><strong>1.1   什么是LESS?</strong></p>
<p>Less 是一门 CSS 预处理语言，使用了类似CSS的语法，为CSS赋予了动态语言的特征。它扩展了 CSS 语言，增加了变量、Mixin(混合)、嵌套、函数和运算等特性，使 CSS 更易维护和扩展。此外，Less 可以运行在 Node 或浏览器端。</p>
<p>一句话：用类似JS的语法去写CSS。<br><a id="more"></a></p>
<p><strong>1.2   LESS的特点？</strong></p>
<p>作为CSS的一种扩展，LESS CSS不仅向下兼容CSS的语法，而且连新增的特性也是使用CSS语法。这样的设置使得学习LESS非常轻松，而且你可以在任何时候回退到CSS。</p>
<p><strong>1.3   变量</strong></p>
<p>单独定义一系列通用的样式，然后在需要的时候去调用。所以在做全局样式调整的时候我们可能只需要修改几行代码就可以了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// JS中定义变量</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">'张三'</span>;</div><div class="line"></div><div class="line"><span class="comment">// LESS中定义变量</span></div><div class="line">@color:red;</div><div class="line">h1&#123;</div><div class="line">   <span class="attr">color</span>: @color;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>1.4   嵌套</strong></p>
<p>在一个选择器中嵌套另一个选择器来实现继承，这样很大程度上减少了代码量，并且代码看起来更加清晰。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">div&#123;</div><div class="line">  h1&#123;</div><div class="line">    color:red;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：嵌套一般情况下，不要超过3层</p>
</blockquote>
<p><strong>1.5   运算</strong></p>
<p>运算提供了加、减、乘、除操作，其他复杂的运算交给函数；通常我们可以做属性值和颜色的运算，这样就可以实现属性值之间的复杂关系。</p>
<blockquote>
<p>注意：运算符与值之间必须以空格分开。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@w:500px;</div><div class="line">div&#123;</div><div class="line">   h1&#123;</div><div class="line">     width: @w - 100;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">h1&#123;</div><div class="line">  width: @w;</div><div class="line">  border: 1px solid #000;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>1.6  混合(Mixins)</strong></p>
<p>混合可以将一个定义好的class A轻松的引入到class B中，从而简单的实现class B 继承class A的所有属性。我们还可以带参数的调用，就像使用函数一样。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1268909-47c87ce9ada2c14e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<blockquote>
<p>注意：混合的使用就和js的自定义函数类似，首先 混合 必须前面是以 . +混合名称开始</p>
<p>结构：.名称(变量){}</p>
<p>可以有默认值，也可以没有默认值，没有的话，在调用的时候必须传参，有默认值的时候就可以不用传递参数；</p>
<p>多个参数之间和js一样，用逗号（,） 隔开</p>
</blockquote>
<p><strong>1.7  函数</strong></p>
<p>LESS中的函数 - 映射了JavaScript函数代码，如果你愿意的话，可以操纵属性值。</p>
<p>比如：鼠标移上亮度增加20%。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1268909-0c53243634ccae88.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>需要查找的时候，直接查文档就可以了。</p>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">saturate(@color, 10%); // 饱和度增加 10%</div><div class="line">desaturate(@color, 10%); // 饱和度降低 10%</div><div class="line">lighten(@color, 10%); // 亮度增加 10%</div><div class="line">darken(@color, 10%); // 亮度降低 10%</div><div class="line">fadein(@color, 10%); // 透明度增加 10%</div><div class="line">fadeout(@color, 10%); // 透明度降低 10%</div><div class="line">fade(@color, 50%); // 设定透明度为 50%</div><div class="line">spin(@color, 10); // 色相值增加 10</div><div class="line">……</div></pre></td></tr></table></figure>
<p><strong>1.8   匹配模式</strong></p>
<p>类似js中的if else判断，只有匹配成功才能起作用。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1268909-1390d5d8494d8d94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<blockquote>
<p>注意：匹配模式中,定义的模式名称都是一样的，只是参数不一样，调用的时候只需选择对应的参数就可以了。</p>
</blockquote>
<p><strong>1.9    如何使用LESS?</strong></p>
<p><strong>方式一：客户端直接调用</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;link rel=&quot;stylesheet/less&quot; href=&quot;less/less.less&quot;&gt;</div><div class="line">&lt;!--用于编译LESS的--&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;js/less.min.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：必须在服务器环境中才能生效，动态编译注入虚拟DOM或者内存中，类似ajax。</p>
<p>开发中常用的服务器组合：WAPM</p>
</blockquote>
<p><strong>方式二：预编译（提前编译）</strong></p>
<p>在代码编辑器中，按照LESS的语法规则写好LESS文件；</p>
<p>使用编译工具把.less文件编译成.css文件；</p>
<p>把编译后的css文件引入到页面即可。</p>
<blockquote>
<p>编译工具：Koala</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/1268909-791d357dc781af8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><strong>1.10  如何在一个LESS文件中导入另一个LESS文件？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@import &quot;less.less&quot;; // 注意：less文件扩展名可选</div></pre></td></tr></table></figure>
<p><strong>1.11   其他补充?</strong></p>
<p>\/\/    不会被编译器编译的注释</p>
<p>\/**\/  是可以被编译器编译的 注释</p>
<p>~’ ’  表示的是禁止被编译</p>
<p>&amp;     表示选择所有的父级元素</p>
<p><strong>1.12 命名不要加空格</strong> </p>
<p><strong>1.13  《授之于渔》</strong></p>
<p>LESS官网：<a href="http://lesscss.org/" target="_blank" rel="external">http:\/\/lesscss.org\/</a></p>
<p>LESS中文网 ：<a href="http://www.lesscss.cn/" target="_blank" rel="external">http:\/\/www.lesscss.cn\/</a>  和  <a href="http://www.lesscss.cn/" target="_blank" rel="external">http:\/\/www.lesscss.net\/</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 前端软件 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git]]></title>
      <url>/2016/01/15/Git/</url>
      <content type="html"><![CDATA[<p>##git</p>
<p>###认识shell命令<br>shell俗称为壳,区分kernel(核),是Bash中的一种命令.<br>类似DOS下的conmand和后来的cmd.exe,接收用户命令,调出相应的应用程序.<br><a id="more"></a></p>
<p>###常见命令格式:命令[-options][参数]</p>
<p><strong>pwd</strong>:(print working directorg)查看当前目录</p>
<p><strong>cd</strong>:(change directory)切换目录,如cd/etc</p>
<p><strong>ls</strong>:(list):查看当前目录下内容:如ls -al</p>
<p><strong>mkdir</strong>:(make directory)创建目录,如  mkdir blog</p>
<p><strong>touch</strong>:创建文件:如 touch iddex.html</p>
<p><strong>wc</strong>:(word count)字数信息统计,如wc index.html</p>
<p><strong>cat</strong>:查看文件全部内容 如:cat index.html</p>
<p><strong>more/less</strong>:查看文件,  如more/etc/password</p>
<p><strong>rm</strong>:(remove)删除文件,如rm index.html</p>
<p><strong>rmdir</strong>:*(remove directory) 删除文件夹,只能删除空文件夹,不常用</p>
<p><strong>mv</strong>:(move)移动文件或重命名,如 mv index.html</p>
<p><strong>cp</strong>:(copy)复制文件, cp index.html</p>
<p><strong>head</strong>:查看文件前几行,如head -5 index.html</p>
<p><strong>tail</strong>:查看文件后几行 -n -f tail -5 index.html</p>
<p><strong>tab</strong>:自动补全,连续按两次会将所有匹配内容显示出来</p>
<p><strong>history</strong>:查看操作历史</p>
<p><strong>ssh</strong>:远程登录,如ssh root@192.168.0.1</p>
<p><strong>&gt;和&gt;&gt;重定向</strong>,如echo hello world!&gt;readme.md ,&gt;覆盖  &gt;&gt;追加</p>
<p><strong>wget</strong> 下载,如wget <a href="https://nodejs.org/dist/v4.4.0/node-v4.4.0.tar.gz" target="_blank" rel="external">https://nodejs.org/dist/v4.4.0/node-v4.4.0.tar.gz</a></p>
<p><strong>tar</strong>:解压缩,如tar zxvf node-v4.4.0.tar.gz</p>
<p><strong>curl</strong>:网络请求,如:curl <a href="http://www.baidu.com" target="_blank" rel="external">http://www.baidu.com</a></p>
<p><strong>who am i</strong>:查看当前用于</p>
<p><strong>|</strong>:管道符</p>
<p><strong>grep</strong>:匹配内容,一般结合管道符使用</p>
<p>##vi编辑器<br>vi编辑器和window下的记事本差不多,不过功能比之强大,是Linux的标配:有三种模式</p>
<p><strong>1.命名行模式</strong></p>
<p><strong>2.输入模式</strong></p>
<p><strong>3.末行模式</strong></p>
<p>这三种模式用户可以进行切换<br><img src="http://i.imgur.com/43vuoNg.png" alt=""></p>
<p>在输入模式下是不能够直接切换到末行模式,必须得先回到命令模式</p>
<p>我们可以通过ESC键来切换到命令模式</p>
<p>每一种编辑下面有对应的命令</p>
<p>1.输入模式命令</p>
<p>直接输入i或a进行输入模式,可以进行内容的编辑</p>
<p>想要退出输入模式,则按下键盘esc键</p>
<p>2.末行模式命令</p>
<p>进行末行模式:shift+:</p>
<p>w:保存当前文件</p>
<p>w filePath/fileName:另存为</p>
<p>wq:保存并退出</p>
<p>e!撤销更改,返回上一次保存状态</p>
<p>q!不保存,强制退出</p>
<p>set nu:设置行号</p>
<p>3.命令模式</p>
<p>zz:(大写)保存并直接退出</p>
<p>u:撤销操作,可以撤销多次</p>
<p>yy:赋值当前行</p>
<p>dd:删除当前行</p>
<p>p:粘贴内容</p>
<p>ctrl+f:镶嵌翻页</p>
<p>ctrl+b:向后翻页</p>
<p>##生成ssh公钥<br>ssh是一种网络协议,用于计算机之间的加密登录.<br>ssh知识一种协议,存在多种实现,既有商业实现,也有开源实现.本文针对的实现是openSSH,它是自由软件,应用非常广泛</p>
<p>访问服务器的时候,服务器会把它的公钥发送给你</p>
<p>当输入密码的时候,它会拿着密钥公钥一起加密,把加密后的密码.再发送给服务器</p>
<p>想要解开密码.原始服务的密钥才能解开</p>
<p>操作流程</p>
<p>1.第一步:在本地生成一个公钥,使用命令如下:<br>ssh-keygen -t rsa<br><img src="http://i.imgur.com/RAgZs9a.png" alt=""></p>
<p>一路回车</p>
<p>前往对应的文件夹当中查找生成的公钥,私钥文件</p>
<p><img src="http://i.imgur.com/8nAwVI6.png" alt=""></p>
<p>输入的密码我们看不到,当我们输入密码完毕时,按回车时,系统会自动的把输入的密码连服务器发来的公钥一起加密.发送给服务器,发送给服务器之后,服务器使用它的私钥,先解密.再去判断密码.增加了安全性</p>
<p>整个过程,流程图如下:<br><img src="http://i.imgur.com/32ELY33.png" alt=""></p>
<p>免密码登录</p>
<p>登录成功后,我们把我们本地计算机的公钥给放到远程服务器当中</p>
<p>1.在远程服务商创建文件夹.ssh</p>
<p>使用命令:mkdir .ssh</p>
<p>2.进入,ssh文件夹当中</p>
<p>使用命令:cd .ssh</p>
<p>3.创建文件,文件命名为authorized_keys</p>
<p>使用命令</p>
<p>touch authorized_key</p>
<p>4.使用vi编辑authorized_keys文件</p>
<p>vi authorized_keys</p>
<p>进入插入模式,把本地公钥给拷贝到该文件当中</p>
<p>保存退出</p>
<p>下次再进去时,已经不需要密码了</p>
<p>##git的工作原理</p>
<p>git管理我们文件的三种状态,分别是:</p>
<p><strong>1.已经提交(committed)</strong></p>
<p><strong>2.已经修改(modified)</strong></p>
<p><strong>3.已经暂存(staged)</strong></p>
<p>由此引入Git项目的三个工作区域的概念</p>
<p><strong>1.Git仓库</strong></p>
<p><strong>2.工作目录</strong></p>
<p><strong>3.暂存区域</strong></p>
<p>Git仓库:目录是Git用来保存项目的元数据和对象数据库的地方<br>        这是Git中最重要的部分,从其他计算机克隆仓库,拷的就是这里的数据.</p>
<p>工作目录:是对项目的某个版本独立提取出来的内容<br>        这些从Git仓库的压缩数据库中提取出来的文件,放在磁盘上供你使用或者修改</p>
<p>暂存区域:是一个文件,保存了下次将提交的文件列表信息,一般在Git仓库目录中,有时候也被称作’索引’(index),不过一般说法还是叫暂存区域</p>
<p>基本的Git工作流程如下:</p>
<p><strong>1.在工作目录中修改文件</strong></p>
<p><strong>2.暂存文件,将文件的快照放入暂存区域</strong></p>
<p><strong>3.提交更新,找到暂存区域的文件,将快照永久存储到Git仓库目录</strong><br><img src="http://i.imgur.com/CmUJTTl.png" alt=""></p>
<p>#git命令的运用</p>
<p>##配置用户</p>
<p>###git config–global user.name”自己的名字”;</p>
<p>###git config–global user.email”自己的邮箱地址”;</p>
<p>###git init  初始化仓库</p>
<p>###git status  查看文件状态</p>
<p>###git add *或-a  添加文件到暂存区</p>
<p>###git commit -m “备注信息”  提交文件</p>
<p>###git log 查看历史</p>
<p>###git reset–hard sha值  恢复到上一次的提交</p>
<p>###创建分支:git branch 分支名称</p>
<p>###切换分支:git checkout 分支名称</p>
<p>###查看分支:git branch</p>
<p>###合并分支:git merge 分支名称</p>
<p>###<font color="red">删除分支:git branch -d 分支名称</font></p>
<p>##git 共享仓库<br><strong>git要求共享仓库是以.git结尾的目录</strong></p>
<p><strong>mkdir repo.git 创建以.git结尾mulv</strong></p>
<p><strong>cd repo.git进入这个目录</strong></p>
<p><strong>git init –bare 初始化一个共享仓库,注意选项–bare</strong></p>
<p><strong>这样我们就建好了一个共享的仓库,但这时这个仓库是一个空的仓库</strong></p>
<p>以上就是我们直接创建仓库的步骤,除了上面的方法之外,我们还可以通过</p>
<p><strong>git clone –bare仓库地址的形式,将已有一个仓库导出成一个裸仓库</strong></p>
<p><strong>向共享仓库共享内容:通过git push 仓库地址</strong></p>
<p><strong>从共享仓库里取出内容</strong></p>
<p><strong>git clone ./repo.git.demo</strong></p>
<p><strong>git pull ../repo.git master</strong></p>
]]></content>
      
        
        <tags>
            
            <tag> 版本控制系统 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[项目实战]]></title>
      <url>/2015/08/28/Bootstrap%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/</url>
      <content type="html"><![CDATA[<p>#项目实战</p>
<h3 id="一-搭建-Bootstrap-页面骨架及项目目录结构"><a href="#一-搭建-Bootstrap-页面骨架及项目目录结构" class="headerlink" title="一. 搭建 Bootstrap 页面骨架及项目目录结构"></a>一. 搭建 Bootstrap 页面骨架及项目目录结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">├─ /weijinsuo/ ··················· 项目根目录</div><div class="line">└─┬─ /css/ ······················· 项目CSS文件</div><div class="line">├─ /font/ ······················ 使用到的字体文件</div><div class="line">├─ /img/ ······················· 使用到的图片文件</div><div class="line">├─ /js/ ························ 自己的JS脚本</div><div class="line">├─ /lib/ ······················· 第三方类库</div><div class="line">├─ /favicon.ico ················ 站点图标</div><div class="line">└─ /index.html ················· 入口文件</div></pre></td></tr></table></figure>
<a id="more"></a>
<p><img src="/assets/place.png" alt=""></p>
<h3 id="二、项目编码规范约定"><a href="#二、项目编码规范约定" class="headerlink" title="二、项目编码规范约定"></a>二、项目编码规范约定</h3><h4 id="2-1-HTML约定"><a href="#2-1-HTML约定" class="headerlink" title="2.1   HTML约定"></a>2.1   HTML约定</h4><ul>
<li><p>所有的CSS引用在HEAD中，按照第三方优先的顺序排列，我们自己的CSS肯定在最下面</p>
</li>
<li><p>所有JS文件都引用在Body的最下面（加载的缘由），按照依赖顺序排序</p>
</li>
<li><p>如果只是使用bootstrap的样式的话，就不用引用js文件</p>
</li>
<li><p>在head中引入必要的CSS文件，优先引用第三方的CSS，方便我们自己的样式覆盖</p>
</li>
<li><p>在body末尾引入必要的JS文件，优先引用第三方的JS，注意JS文件之间的依赖关系，比如bootstrap.js依赖jQuery，那就应该先引用jquery.js 然后引用bootstrap.js</p>
</li>
<li><p>特殊情况：如果js文件是用于处理一些css样式的，那一般在head中进行引入</p>
</li>
</ul>
<h4 id="2-2-CSS约定"><a href="#2-2-CSS约定" class="headerlink" title="2.2   CSS约定"></a>2.2   CSS约定</h4><ul>
<li><p>除了公共级别样式，其余样式全部加模块前缀</p>
</li>
<li><p>尽量使用 直接子代选择器， 少用间接子代 避免选错</p>
</li>
<li><p>CSS类名冲突 通过约定 给模块加上一个独一无二的名字</p>
</li>
<li><p>使用子代选择器的方式</p>
</li>
</ul>
<h4 id="2-2-JS约定"><a href="#2-2-JS约定" class="headerlink" title="2.2   JS约定"></a>2.2   JS约定</h4><ul>
<li><p>不允许使用onxxx = function(){}的方式注册事件</p>
</li>
<li><p>原生JS统一使用addEventListener(‘xxx’, function(){});</p>
</li>
</ul>
<p><img src="/assets/place.png" alt=""></p>
<h3 id="三、项目默认配置设定"><a href="#三、项目默认配置设定" class="headerlink" title="三、项目默认配置设定"></a>三、项目默认配置设定</h3><h4 id="3-1-HTML5文档结构"><a href="#3-1-HTML5文档结构" class="headerlink" title="3.1   HTML5文档结构"></a>3.1   HTML5文档结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;zh-CN&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;页面标题&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line"></div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<h4 id="3-2-Viewport设置"><a href="#3-2-Viewport设置" class="headerlink" title="3.2   Viewport设置"></a>3.2   Viewport设置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0&quot;&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p>html中插入视口设置，可以通过emmet __meta:vp__ 插入</p>
<p>此属性为移动端页面视口设置，当前值表示在移动端页面的宽度为设备的宽度，并且不缩放（缩放级别为1）</p>
<p>960px 内容 被套在一个宽度为980px(绝大多数设备的视口默认尺寸)的容器(视口)中，将视口缩放到设备的真实尺寸中进行展示</p>
</blockquote>
<h4 id="3-3-浏览器兼容模式"><a href="#3-3-浏览器兼容模式" class="headerlink" title="3.3   浏览器兼容模式"></a>3.3   浏览器兼容模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p>html中插入兼容模式设置，可以通过emmet __meta:compat__ 插入</p>
<p>此属性为文档兼容模式声明，表示如果在IE浏览器下则使用最新的标准渲染当前文档</p>
</blockquote>
<h4 id="3-4-favicon（站点图标）"><a href="#3-4-favicon（站点图标）" class="headerlink" title="3.4   favicon（站点图标）"></a>3.4   favicon（站点图标）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;link rel=&quot;shortcut icon&quot; type=&quot;image/x-icon&quot; href=&quot;favicon.ico&quot;&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p>html中插入图标链接，可以通过emmet __link:favicon__ 插入</p>
</blockquote>
<h4 id="3-5-引入相应的第三方文件"><a href="#3-5-引入相应的第三方文件" class="headerlink" title="3.5   引入相应的第三方文件"></a>3.5   引入相应的第三方文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;bootstrap.css&quot;&gt;</div><div class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;index.css&quot;&gt;</div><div class="line">...</div><div class="line">&lt;script src=&quot;jquery.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script src=&quot;bootstrap.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<h4 id="3-6-设置默认字体"><a href="#3-6-设置默认字体" class="headerlink" title="3.6   设置默认字体"></a>3.6   设置默认字体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">body&#123;</div><div class="line">font-family: &quot;Helvetica Neue&quot;,</div><div class="line">Helvetica,</div><div class="line">Microsoft Yahei,</div><div class="line">Hiragino Sans GB,</div><div class="line">WenQuanYi Micro Hei,</div><div class="line">sans-serif;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/assets/place.png" alt=""></p>
<h3 id="四、项目结构搭建"><a href="#四、项目结构搭建" class="headerlink" title="四、项目结构搭建"></a>四、项目结构搭建</h3><h4 id="4-1-完成页面空结构搭建"><a href="#4-1-完成页面空结构搭建" class="headerlink" title="4.1   完成页面空结构搭建"></a>4.1   完成页面空结构搭建</h4><blockquote>
<p>先划分好页面中的大容器，然后在具体看每一个容器中单独的情况</p>
</blockquote>
<h4 id="4-2-构建顶部通栏"><a href="#4-2-构建顶部通栏" class="headerlink" title="4.2   构建顶部通栏"></a>4.2   构建顶部通栏</h4><ul>
<li><strong>container类</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">定义一个固定宽度且居中的版心</div><div class="line">container是具备响应式的能力</div><div class="line">四个档位 1170 970 750 100%</div></pre></td></tr></table></figure>
<ul>
<li><strong>栅格系统</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Bootstrap中的栅格系统就是将一行划分为12列</div><div class="line">我们通过col-*-*的类名控制某个元素在某种屏幕的情况下展示几列</div><div class="line">col-md-6 在中等屏幕下 占1/2</div><div class="line">col-xs-12 在超小屏幕下 占全部</div></pre></td></tr></table></figure>
<ul>
<li><strong>row类</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">.row&#123; marginLeft:-15px; marginRight:-15px &#125;</div><div class="line">抵消掉container中定义的padding</div></pre></td></tr></table></figure>
<ul>
<li><strong>col-**</strong><em>-\</em><strong>**类</strong></li>
</ul>
<p>在某种屏幕尺寸下控制列的占比</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">col-xs-[列数]：在超小屏幕下展示几份</div><div class="line">col-sm-[列数]：在小屏幕下展示几份</div><div class="line">col-md-[列数]：在中等屏幕下展示几份</div><div class="line">col-lg-[列数]：在大屏幕下展示几份</div><div class="line">__xs__ : 超小屏幕 手机 (&lt;768px)</div><div class="line">__sm__ : 小屏幕 平板 (≥768px)</div><div class="line">__md__ : 中等屏幕 桌面显示器 (≥992px)</div><div class="line">__lg__ : 大屏幕 大桌面显示器 (≥1200px)</div></pre></td></tr></table></figure>
<h4 id="4-3-字体图标"><a href="#4-3-字体图标" class="headerlink" title="4.3   字体图标"></a>4.3   字体图标</h4><blockquote>
<p>字体实际上就是记录一个字符对应的图形</p>
<p>在CSS中为元素设置字体，以前只能设置客户端存在的字体</p>
<p>webfont 在线字体</p>
<p>我自己做一套图形的字体</p>
<p>如何定义一个web字体？</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/* 定义一个叫做“bb”字体 */</div><div class="line">@font-face &#123;</div><div class="line">font-family: &apos;bb&apos;;</div><div class="line">src: url(&apos;../font/MiFie-Web-Font.eot&apos;) format(&apos;embedded-opentype&apos;),</div><div class="line">url(&apos;../font/MiFie-Web-Font.svg&apos;) format(&apos;svg&apos;),</div><div class="line">url(&apos;../font/MiFie-Web-Font.ttf&apos;) format(&apos;truetype&apos;),</div><div class="line">url(&apos;../font/MiFie-Web-Font.woff&apos;) format(&apos;woff&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>字体文件格式</strong></li>
</ul>
<p>eot : embedded-opentype</p>
<p>svg : svg</p>
<p>ttf : truetype</p>
<p>woff : woff</p>
<ul>
<li><p><strong>icomoon</strong></p>
</li>
<li><p><strong>使用方式</strong></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">@font-face &#123;</div><div class="line">font-family: &apos;bb&apos;;</div><div class="line">src: url(&apos;../font/MiFie-Web-Font.eot&apos;) format(&apos;embedded-opentype&apos;),</div><div class="line">url(&apos;../font/MiFie-Web-Font.svg&apos;) format(&apos;svg&apos;),</div><div class="line">url(&apos;../font/MiFie-Web-Font.ttf&apos;) format(&apos;truetype&apos;),</div><div class="line">url(&apos;../font/MiFie-Web-Font.woff&apos;) format(&apos;woff&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">[class^=&quot;icon-&quot;],</div><div class="line">[class*=&quot; icon-&quot;] &#123;</div><div class="line">/*注意上面选择器中间的空格*/</div><div class="line">/*我们使用的名为bb的字体就是上面的@font-face的方式声明的*/</div><div class="line">font-family: bb;</div><div class="line">font-style: normal;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.icon-mobilephone::before&#123;</div><div class="line">content: &apos;\e908&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;div class=&quot;col-md-2 text-center&quot;&gt;</div><div class="line">    &lt;a class=&quot;mobile-link&quot; href=&quot;#&quot;&gt;</div><div class="line">        &lt;i class=&quot;icon-mobile&quot;&gt;&lt;/i&gt;</div><div class="line">        &lt;span&gt;IT点论坛&lt;/span&gt;</div><div class="line">        &lt;!-- 这里使用的是bootstrap中的字体图标 --&gt;</div><div class="line">        &lt;i class=&quot;glyphicon glyphicon-chevron-down&quot;&gt;&lt;/i&gt;</div><div class="line">        &lt;img src=&quot;...&quot; alt=&quot;&quot;&gt;</div><div class="line">    &lt;/a&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p>[<em>attribute</em>^=<em>value</em>]   选择器匹配属性值以指定值开头的每个元素。</p>
<p>[<em>attribute*</em>=<em>value</em>]    选择器匹配属性值包含指定值开头的每个元素。</p>
</blockquote>
<h4 id="4-4-二维码图片展示"><a href="#4-4-二维码图片展示" class="headerlink" title="4.4   二维码图片展示"></a>4.4   二维码图片展示</h4><h4 id="4-5-按钮样式生成"><a href="#4-5-按钮样式生成" class="headerlink" title="4.5   按钮样式生成"></a>4.5   按钮样式生成</h4><ul>
<li><p>http:\/\/blog.koalite.com\/bbg\/</p>
</li>
<li><p>可以通过界面生成一个新的按钮样式</p>
</li>
<li><p>具体代码</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">.btn-bb &#123;</div><div class="line">color: #ffffff;</div><div class="line">background-color: #E92322;</div><div class="line">border-color: #DB3B43;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.btn-bb:hover,</div><div class="line">.btn-bb:focus,</div><div class="line">.btn-bb:active,</div><div class="line">.btn-bb.active,</div><div class="line">.open .dropdown-toggle.btn-bb &#123;</div><div class="line">color: #ffffff;</div><div class="line">background-color: #E92322;</div><div class="line">border-color: #DB3B43;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.btn-bb:active,</div><div class="line">.btn-bb.active,</div><div class="line">.open .dropdown-toggle.btn-bb &#123;</div><div class="line">background-image: none;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.btn-bb.disabled,</div><div class="line">.btn-bb[disabled],</div><div class="line">fieldset[disabled] .btn-bb,</div><div class="line">.btn-bb.disabled:hover,</div><div class="line">.btn-bb[disabled]:hover,</div><div class="line">fieldset[disabled] .btn-bb:hover,</div><div class="line">.btn-bb.disabled:focus,</div><div class="line">.btn-bb[disabled]:focus,</div><div class="line">fieldset[disabled] .btn-bb:focus,</div><div class="line">.btn-bb.disabled:active,</div><div class="line">.btn-bb[disabled]:active,</div><div class="line">fieldset[disabled] .btn-bb:active,</div><div class="line">.btn-bb.disabled.active,</div><div class="line">.btn-bb[disabled].active,</div><div class="line">fieldset[disabled] .btn-bb.active &#123;</div><div class="line">background-color: #E92322;</div><div class="line">border-color: #DB3B43;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.btn-bb .badge &#123;</div><div class="line">color: #E92322;</div><div class="line">background-color: #ffffff;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-6-小屏幕隐藏"><a href="#4-6-小屏幕隐藏" class="headerlink" title="4.6   小屏幕隐藏"></a>4.6   小屏幕隐藏</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;topbar hidden-xs hidden-sm&quot;&gt;&lt;/div&gt;</div><div class="line">//  或者</div><div class="line">&lt;div class=&quot;topbar visible-md visible-lg&quot;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p>__hidden-xx__ : 在某种屏幕下隐藏</p>
<p>__visible-xx-xxx__ : 在某种屏幕尺寸下显示</p>
<p>visible-md-xx：指的是中等屏幕可见，不是中等屏幕以上</p>
<p>visible-md-block visible-lg-block == hidden-sm hidden-xs</p>
</blockquote>
<ul>
<li>根据hidden-xxx和visible-xxx的特点，我们可以通过媒体查询的方式实习</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">@media (max-width:768px) &#123;</div><div class="line">/*-xs*/</div><div class="line">.hidden-xs &#123;</div><div class="line">display: none;</div><div class="line">&#125;</div><div class="line">.visible-xs-block &#123;</div><div class="line">display: block;</div><div class="line">&#125;</div><div class="line">.visible-xs-inline &#123;</div><div class="line">display: inline;</div><div class="line">&#125;</div><div class="line">.visible-xs-inline-block &#123;</div><div class="line">display: inline-block;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@media (max-width:992px) &#123;</div><div class="line">/*-sm*/</div><div class="line">.hidden-sm &#123;</div><div class="line">display: none;</div><div class="line">&#125;</div><div class="line">.visible-sm-block &#123;</div><div class="line">display: block;</div><div class="line">&#125;</div><div class="line">.visible-sm-inline &#123;</div><div class="line">display: inline;</div><div class="line">&#125;</div><div class="line">.visible-sm-inline-block &#123;</div><div class="line">display: inline-block;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@media (max-width:1200px) &#123;</div><div class="line">/*-md*/</div><div class="line">.hidden-md &#123;</div><div class="line">display: none;</div><div class="line">&#125;</div><div class="line">.visible-md-block &#123;</div><div class="line">display: block;</div><div class="line">&#125;</div><div class="line">.visible-md-inline &#123;</div><div class="line">display: inline;</div><div class="line">&#125;</div><div class="line">.visible-md-inline-block &#123;</div><div class="line">display: inline-block;</div><div class="line">&#125;</div><div class="line"></div><div class="line">----------</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">@media (min-width:1200px) &#123;</div><div class="line">/*-lg*/</div><div class="line">.hidden-lg &#123;</div><div class="line">display: none;</div><div class="line">&#125;</div><div class="line">.visible-lg-block &#123;</div><div class="line">display: block;</div><div class="line">&#125;</div><div class="line">.visible-lg-inline &#123;</div><div class="line">display: inline;</div><div class="line">&#125;</div><div class="line">.visible-lg-inline-block &#123;</div><div class="line">display: inline-block;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-7-导航通栏"><a href="#4-7-导航通栏" class="headerlink" title="4.7   导航通栏"></a>4.7   导航通栏</h4><ul>
<li>在使用了boostrap过后，大多数界面元素都是通过bootstrap提供好的界面组件修改得来</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;nav class=&quot;navbar navbar-default navbar-bb navbar-static-top&quot;&gt;</div><div class="line">    &lt;div class=&quot;container&quot;&gt;</div><div class="line">        &lt;div class=&quot;navbar-header&quot;&gt;</div><div class="line">            &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;</div><div class="line">                &lt;i class=&quot;icon-icon&quot;&gt;&lt;/i&gt;</div><div class="line">                &lt;i class=&quot;icon-logo&quot;&gt;&lt;/i&gt;</div><div class="line">            &lt;/a&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">        &lt;ul class=&quot;nav navbar-nav&quot;&gt;</div><div class="line">            &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;我要投资&lt;/a&gt;&lt;/li&gt;</div><div class="line">            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;我要借款&lt;/a&gt;&lt;/li&gt;</div><div class="line">            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;平台介绍&lt;/a&gt;&lt;/li&gt;</div><div class="line">            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;新手专区&lt;/a&gt;&lt;/li&gt;</div><div class="line">            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;最新动态&lt;/a&gt;&lt;/li&gt;</div><div class="line">            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;微论坛&lt;/a&gt;&lt;/li&gt;</div><div class="line">        &lt;/ul&gt;</div><div class="line">        &lt;ul class=&quot;nav navbar-nav navbar-right hidden-sm&quot;&gt;</div><div class="line">            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;个人中心&lt;/a&gt;&lt;/li&gt;</div><div class="line">        &lt;/ul&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/nav&gt;</div></pre></td></tr></table></figure>
<ul>
<li>Bootstrap扩展</li>
</ul>
<blockquote>
<p>通过bootstrap文档对导航条样式的设置发现，其实本身是有一个类似于主题的概念</p>
<p>navbar-default：默认的外观</p>
<p>navbar-inverse：暗色背景的样式</p>
<p>所以我们希望可以通过自定义一套完整的风格（继承navbar-default）：</p>
<p>navbar-bb</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.navbar-bb&#123;</div><div class="line">...</div><div class="line">&#125;</div><div class="line">...具体代码参考navbar-default实现即可</div></pre></td></tr></table></figure>
<ul>
<li>品牌logo</li>
</ul>
<blockquote>
<p>使用字体图标</p>
</blockquote>
<ul>
<li>菜单行高调整</li>
</ul>
<blockquote>
<p>默认样式中菜单的行高为20px，我们可以调整为自己想要的高度</p>
<p>一般都是通过自己的样式去覆盖</p>
</blockquote>
<ul>
<li>响应式菜单</li>
</ul>
<blockquote>
<p>默认菜单是不具备响应式的能力的，通过观察文档发现，响应式菜单是通过一个按钮控制的</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">&lt;nav class=&quot;navbar navbar-default navbar-bb navbar-static-top&quot;&gt;</div><div class="line">    &lt;div class=&quot;container&quot;&gt;</div><div class="line">        &lt;div class=&quot;navbar-header&quot;&gt;</div><div class="line">            &lt;!-- 点击该按钮会切换菜单的显示或隐藏 --&gt;</div><div class="line">            &lt;button</div><div class="line">                    id=&quot;btn&quot;</div><div class="line">                    type=&quot;button&quot;</div><div class="line">                    class=&quot;navbar-toggle collapsed&quot;</div><div class="line">                    data-toggle=&quot;collapse&quot;</div><div class="line">                    data-target=&quot;#nav_list&quot;</div><div class="line">                    aria-expanded=&quot;false&quot;</div><div class="line">            &gt;</div><div class="line">                &lt;span class=&quot;sr-only&quot;&gt;切换菜单&lt;/span&gt;</div><div class="line">                &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;</div><div class="line">                &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;</div><div class="line">                &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;</div><div class="line">            &lt;/button&gt;</div><div class="line">            &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;</div><div class="line">                &lt;i class=&quot;icon-icon&quot;&gt;&lt;/i&gt;</div><div class="line">                &lt;i class=&quot;icon-logo&quot;&gt;&lt;/i&gt;</div><div class="line">            &lt;/a&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">        &lt;div id=&quot;nav_list&quot; class=&quot;collapse navbar-collapse&quot;&gt;</div><div class="line">            &lt;ul class=&quot;nav navbar-nav&quot;&gt;</div><div class="line">                &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;我要投资&lt;/a&gt;&lt;/li&gt;</div><div class="line">                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;我要借款&lt;/a&gt;&lt;/li&gt;</div><div class="line">                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;平台介绍&lt;/a&gt;&lt;/li&gt;</div><div class="line">                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;新手专区&lt;/a&gt;&lt;/li&gt;</div><div class="line">                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;最新动态&lt;/a&gt;&lt;/li&gt;</div><div class="line">                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;微论坛&lt;/a&gt;&lt;/li&gt;</div><div class="line">            &lt;/ul&gt;</div><div class="line">            &lt;ul class=&quot;nav navbar-nav navbar-right hidden-sm&quot;&gt;</div><div class="line">                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;个人中心&lt;/a&gt;&lt;/li&gt;</div><div class="line">            &lt;/ul&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/nav&gt;</div></pre></td></tr></table></figure>
<h4 id="4-8-轮播图"><a href="#4-8-轮播图" class="headerlink" title="4.8  轮播图"></a>4.8  轮播图</h4><ul>
<li>Bootstrap JS插件使用</li>
</ul>
<blockquote>
<p>对于Bootstrap的JS插件</p>
<p>我们只需要将文档实例中的代码粘到我们自己的代码中</p>
<p>然后作出相应的样式调整</p>
</blockquote>
<ul>
<li><p>Bootstrap中轮播图插件叫作Carousel</p>
</li>
<li><p>基本的轮播图实现</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">&lt;!-- </div><div class="line">  以下容器就是整个轮播图组件的整体，</div><div class="line">  注意该盒子必须加上 class=&quot;carousel slide&quot; data-ride=&quot;carousel&quot; 表示当前是一个轮播图</div><div class="line">  bootstrap.js会自动为当前元素添加图片轮播的特效</div><div class="line">--&gt;</div><div class="line">&lt;div id=&quot;轮播图的ID&quot; class=&quot;carousel slide&quot; data-ride=&quot;carousel&quot;&gt;</div><div class="line">    &lt;!-- ol标签是图片轮播的控制点 --&gt;</div><div class="line">    &lt;ol class=&quot;carousel-indicators&quot;&gt;</div><div class="line">        &lt;!--</div><div class="line">          每一个li就是一个单独的控制点</div><div class="line">            data-target属性就是指定当前控制点控制的是哪一个轮播图，其目的是如果界面上有多个轮播图，便于区分到底控制哪一个</div><div class="line">            data-slide-to属性是指当前的li元素绑定的是第几个轮播项</div><div class="line">          注意，默认必须给其中某个li加上active，展示的时候就是焦点项目</div><div class="line">        --&gt;</div><div class="line">        &lt;li data-target=&quot;#轮播图的ID&quot; data-slide-to=&quot;0&quot; class=&quot;active&quot;&gt;&lt;/li&gt;</div><div class="line">        &lt;li data-target=&quot;#轮播图的ID&quot; data-slide-to=&quot;1&quot;&gt;&lt;/li&gt;</div><div class="line">        &lt;!-- ...更多的 --&gt;</div><div class="line">    &lt;/ol&gt;</div><div class="line">    &lt;!--</div><div class="line">      .carousel-inner是所有轮播项的容器盒子，</div><div class="line">      注意role=&quot;listbox&quot;代表当前div是一个列表盒子，作用就是给当前div添加一个语义</div><div class="line">    --&gt;</div><div class="line">    &lt;div class=&quot;carousel-inner&quot; role=&quot;listbox&quot;&gt;</div><div class="line">        &lt;!-- 每一个.item就是单个轮播项目，注意默认要给第一个轮播项目加上active，表示为焦点 --&gt;</div><div class="line">        &lt;div class=&quot;item active&quot;&gt;</div><div class="line">            &lt;!-- 轮播项目中展示的图片 --&gt;</div><div class="line">            &lt;img src=&quot;example.jpg&quot; alt=&quot;示例图片&quot;&gt;</div><div class="line">            &lt;div class=&quot;carousel-caption&quot;&gt;</div><div class="line">                &lt;!-- 标题或说明性文字，如果不需要，直接删除当前div.carousel-caption --&gt;</div><div class="line">            &lt;/div&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">        &lt;div class=&quot;item&quot;&gt;</div><div class="line">            &lt;!-- ... --&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">        &lt;!-- ... --&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">    &lt;!-- 图片轮播上左右两个控制按钮，分别点击可以滚动到上一张和下一张 --&gt;</div><div class="line">    &lt;!-- 此处需要注意的是 该a链接的href属性必须指向需要控制的轮播图ID --&gt;</div><div class="line">    &lt;!-- 另外a链接中的data-slide=&quot;prev&quot;代表点击该链接会滚到上一张，如果设置为next的话则相反 --&gt;</div><div class="line">    &lt;a class=&quot;left carousel-control&quot; href=&quot;#轮播图的ID&quot; role=&quot;button&quot; data-slide=&quot;prev&quot;&gt;</div><div class="line">        &lt;span class=&quot;glyphicon glyphicon-chevron-left&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;</div><div class="line">        &lt;span class=&quot;sr-only&quot;&gt;上一张&lt;/span&gt;</div><div class="line">    &lt;/a&gt;</div><div class="line">    &lt;a class=&quot;right carousel-control&quot; href=&quot;#轮播图的ID&quot; role=&quot;button&quot; data-slide=&quot;next&quot;&gt;</div><div class="line">        &lt;span class=&quot;glyphicon glyphicon-chevron-right&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;</div><div class="line">        &lt;span class=&quot;sr-only&quot;&gt;下一张&lt;/span&gt;</div><div class="line">    &lt;/a&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<ul>
<li><p>轮播图片超宽造成的影响</p>
</li>
<li><p>美工为了在不同屏幕下更好地展示将图片两边做的非常宽，但是我们大多数情况的页面宽度都无法满足这样的图片宽度</p>
</li>
<li><p>而且Bootstrap的样式中默认将图片的max-width设置为100%, 造成界面图片缩放</p>
</li>
<li><p>想在一个较小屏幕下展示一个超宽的图片，并让图片居中显示</p>
</li>
<li><p>两种办法：</p>
</li>
</ul>
<p>换用背景图的方式，background-position: center center;</p>
<p>使img元素绝对定位，left:50%，margin-left: -width\/2</p>
<p>translate方式</p>
<ul>
<li>background-size</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- length</div><div class="line">+ 如 background-size: 100px 100px，将背景图固定到多大尺寸</div><div class="line">- percentage</div><div class="line">+ 如 background-size: 90% 90%，以百分比的形式设置背景大小</div><div class="line">- cover</div><div class="line">+ 1.背景图片等比例缩放</div><div class="line">+ 2.让背景图相对较小边放大到目标容器大小结束</div><div class="line">* 如：一张100\*200的背景图放到一个300\*400的盒子中，最终背景图片的大小是300\*600</div><div class="line">* 因为背景图的较小边为100，将100放大到目标容器300的宽度，放大了3倍，最终结果300\*600</div><div class="line">- contain</div><div class="line">+ 1.背景图片等比例缩放</div><div class="line">+ 2.让背景图相对较大边放大到目标容器大小结束</div><div class="line">* 如：一张100\*200的背景图放到一个300\*400的盒子中，最终背景图片的大小是200\*400</div><div class="line">* 因为背景图的较大边为200，将200放大到目标容器400的高度，放大了2倍，最终结果200\*400</div></pre></td></tr></table></figure>
<p><img src="/assets/Snip20170410_15.png" alt=""></p>
<ul>
<li><p>图片响应式</p>
</li>
<li><p>目的</p>
</li>
<li><p>各种终端都需要正常显示图片</p>
</li>
<li><p>移动端应该使用更小（体积）的图片</p>
</li>
<li><p>实现方式</p>
</li>
<li><ul>
<li>将元素中直接设置的图片背景删除，换成两个data-属性（如：data-img-sm=”小图路径”，data-img-lg=”大图路径”）</li>
</ul>
</li>
<li><p>通过JS的方式获取屏幕的宽度；</p>
</li>
<li><p>判断屏幕宽度是否小于一定的值（如：768px）；</p>
</li>
<li><p>根据判断情况决定使用具体的大图还是小图；</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 获取屏幕宽度</div><div class="line">var windowWidth = $(window).width();</div><div class="line">// 判断屏幕属于大还是小</div><div class="line">var isSmallScreen = windowWidth &lt; 768;</div><div class="line">// 根据大小为界面上的每一张轮播图设置背景</div><div class="line">// $(&apos;#main_ad &gt; .carousel-inner &gt; .item&apos;) // 获取到的是一个DOM数组（多个元素）</div><div class="line">$(&apos;#main_ad &gt; .carousel-inner &gt; .item&apos;).each(function(i, item) &#123;</div><div class="line">// 因为拿到是DOM对象 需要转换</div><div class="line">var $item = $(item);</div><div class="line">// var imgSrc = $item.data(isSmallScreen ? &apos;image-xs&apos; : &apos;image-lg&apos;);</div><div class="line">var imgSrc =</div><div class="line">isSmallScreen ? $item.data(&apos;image-xs&apos;) : $item.data(&apos;image-lg&apos;);</div><div class="line"></div><div class="line">// 设置背景图片</div><div class="line">$item.css(&apos;backgroundImage&apos;, &apos;url(&quot;&apos; + imgSrc + &apos;&quot;)&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ul>
<li>window resize事件</li>
</ul>
<blockquote>
<p>由于上一步我们实现的过程是指在页面加载完成判断一次，</p>
<p>当用户手动调整页面宽度过后没有及时发生变化，</p>
<p>所以我们可以通过window的resize事件中重新完成以上操作来解决这个问题</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function 窗口变化后执行的函数名()&#123;</div><div class="line">// 具体的操作</div><div class="line">&#125;</div><div class="line">$(window).on(&apos;resize&apos;, 窗口变化后执行的函数名);</div></pre></td></tr></table></figure>
<blockquote>
<p>这个事件只会在窗口尺寸发生变化后执行，但是我们需要一开始时执行一次</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">$(window).on(&apos;resize&apos;, 窗口变化后执行的函数名).trigger(&apos;resize&apos;);</div></pre></td></tr></table></figure>
<h4 id="4-9-网站特性"><a href="#4-9-网站特性" class="headerlink" title="4.9  网站特性"></a>4.9  网站特性</h4><ul>
<li><p>网格系统</p>
</li>
<li><p>该板块当屏幕为中等尺寸时分为3列，较小屏幕是分为2列</p>
</li>
<li><p>所以使用网格系统划分</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;col-sm-6 col-md-4&quot;&gt;</div><div class="line">    &lt;!-- ... --&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;!-- ... --&gt;</div></pre></td></tr></table></figure>
<ul>
<li><p>媒体对象样式</p>
</li>
<li><ul>
<li>每一个小块的样式可以通过Bootstrap中的媒体对象样式实现</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;a href=&quot;#&quot;&gt;</div><div class="line">    &lt;div class=&quot;media&quot;&gt;</div><div class="line">        &lt;div class=&quot;media-left&quot;&gt;</div><div class="line">            &lt;i class=&quot;icon-uniE907&quot;&gt;&lt;/i&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">        &lt;div class=&quot;media-body&quot;&gt;</div><div class="line">            &lt;h4 class=&quot;media-heading&quot;&gt;支付交易保障&lt;/h4&gt;</div><div class="line">            &lt;p&gt;银联支付全称保证支付安全&lt;/p&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/a&gt;</div></pre></td></tr></table></figure>
<ul>
<li><p>响应式辅助类型</p>
</li>
<li><ul>
<li>整个板块在超小屏幕下是隐藏起来的</li>
</ul>
</li>
<li><p>只需要给当前板块加上hidden-xs的class</p>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 前端框架_bootstrap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Bootstrap实践理解]]></title>
      <url>/2015/08/20/Bootstrap3%E7%9A%84%E5%AD%A6%E4%B9%A0md/</url>
      <content type="html"><![CDATA[<p>##Bootstrap编码规范</p>
<p>###黄金定律:不管有多少人共同参加同一项目,一定要确保每一行代码都像是一个人写的一样.</p>
<p>###HTML:语法<br>用两个空格来代替制表符（tab） – 这是唯一能保证在所有环境下获得一致展现的方法。<br>嵌套元素应当缩进一次（即两个空格）。<br>对于属性的定义，确保全部使用双引号，绝不要使用单引号。<br>不要在自闭合（self-closing）元素的尾部添加斜线 – HTML5 规范中明确说明这是可选的。<br>不要省略可选的结束标签（closing tag）（例如， 或 ）。<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">由于markdown不支持显示HTML的DOM元素,所以,每个DOM元素前面的&lt;号我都加了一个空格让代码显示出来</div></pre></td></tr></table></figure>
<pre>
< !DOCTYPE html>
< html>
  < head>
    < title>Page title
  < /head>
  < body>
    < img src="images/company-logo.png" alt="Company">
    < h1 class="hello-world">Hello, world!
  < /body>
< /html>
</pre>

<p>###HTML5 doctype<br>为每个 HTML 页面的第一行添加标准模式（standard mode）的声明，这样能够确保在每个浏览器中拥有一致的展现。</p>
<pre>
< !DOCTYPE html>
< html>
  < head>
  < /head>
< /html>
</pre>
更多请查文档:
[http://codeguide.bootcss.com/](http://codeguide.bootcss.com/ "Bootstrap编码规范")

##禁止响应式布局
Bootstrap 会自动帮你针对不同的屏幕尺寸调整你的页面，使其在各个尺寸的屏幕上表现良好。下面我们列出了如何禁用这一特性，就像这个非响应式布局实例页面一样。

禁止响应式布局有如下几步：
1. 移除 此 CSS 文档中提到的设置浏览器视口（viewport）的标签：<meta>。
2. 通过为 .container 类设置一个 width 值从而覆盖框架的默认 width 设置，例如 width: 970px !important; 。请确保这些设置全部放在默认的 Bootstrap CSS 文件的后面。注意，如果你把它放到媒体查询中，也可以略去 !important 。
3. 如果使用了导航条，需要移除所有导航条的折叠和展开行为。
4. 对于栅格布局，额外增加 .col-xs-* 类或替换掉 .col-md-* 和 .col-lg-*。 不要担心，针对超小屏幕设备的栅格系统能够在所有分辨率的环境下展开。


针对 IE8 仍然需要额外引入 Respond.js 文件（由于仍然利用了浏览器对媒体查询（media query）的支持，因此还需要做处理）。这样就禁用了 Bootstrap 对移动设备的响应式支持。


##标题嵌套
当标题嵌套时 (< h1> - < h6>)，你的文档的主标题应该是 < h1> 标签。随后的标题逻辑上就应该使用 < h2> - < h6> ，这样，屏幕阅读器就可以构造出页面的内容列表了。



#全局 CSS 样式
##移动设备优先
在 Bootstrap 2 中，框架中的某些关键部分增加了对移动设备友好的样式。而在 Bootstrap 3 中，重写了整个框架，使其一开始就是对移动设备友好的。这次不是简单的增加一些可选的针对移动设备的样式，而是直接融合进了框架的内核中。也就是说，Bootstrap 是移动设备优先的。针对移动设备的样式融合进了框架的每个角落，而不是增加一个额外的文件。

为了确保适当的绘制和触屏缩放，需要在 <head> 之中添加 viewport 元数据标签。
<pre>
< meta name="viewport" content="width=device-width, initial-scale=1">
</pre>

<p>在移动设备浏览器上，通过为视口（viewport）设置 meta 属性为 user-scalable=no 可以禁用其缩放（zooming）功能。这样禁用缩放功能后，用户只能滚动屏幕，就能让你的网站看上去更像原生应用的感觉。注意，这种方式我们并不推荐所有网站使用，还是要看你自己的情况而定！</p>
<pre>
< meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
</pre>


<p>##布局容器<br>Bootstrap 需要为页面内容和栅格系统包裹一个 .container 容器。我们提供了两个作此用处的类。注意，由于 padding 等属性的原因，这两种 容器类不能互相嵌套。</p>
<p>.container 类用于固定宽度并支持响应式布局的容器。</p>
<pre>
< div class="container">
  ...
< /div>
</pre>
.container-fluid 类用于 100% 宽度，占据全部视口（viewport）的容器。
<pre>
< div class="container-fluid">
  ...
< /div>
</pre>

<p>##栅格系统</p>
<p>Bootstrap 提供了一套响应式、移动设备优先的流式栅格系统，随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列。它包含了易于使用的预定义类，还有强大的mixin 用于生成更具语义的布局。</p>
<p>简介</p>
<p>栅格系统用于通过一系列的行（row）与列（column）的组合来创建页面布局，你的内容就可以放入这些创建好的布局中。下面就介绍一下 Bootstrap 栅格系统的工作原理：</p>
<ul>
<li>“行（row）”必须包含在 .container （固定宽度）或 .container-fluid （100% 宽度）中，以便为其赋予合适的排列（aligment）和内补（padding）。</li>
<li>通过“行（row）”在水平方向创建一组“列（column）”。</li>
<li>你的内容应当放置于“列（column）”内，并且，只有“列（column）”可以作为行（row）”的直接子元素。</li>
<li>类似 .row 和 .col-xs-4 这种预定义的类，可以用来快速创建栅格布局。Bootstrap 源码中定义的 mixin 也可以用来创建语义化的布局。</li>
<li>通过为“列（column）”设置 padding 属性，从而创建列与列之间的间隔（gutter）。通过为 .row 元素设置负值 margin 从而抵消掉为 .container 元素设置的 padding，也就间接为“行（row）”所包含的“列（column）”抵消掉了padding。</li>
<li>负值的 margin就是下面的示例为什么是向外突出的原因。在栅格列中的内容排成一行。</li>
<li>栅格系统中的列是通过指定1到12的值来表示其跨越的范围。例如，三个等宽的列可以使用三个 .col-xs-4 来创建。</li>
<li>如果一“行（row）”中包含了的“列（column）”大于 12，多余的“列（column）”所在的元素将被作为一个整体另起一行排列。</li>
<li>栅格类适用于与屏幕宽度大于或等于分界点大小的设备 ， 并且针对小屏幕设备覆盖栅格类。 因此，在元素上应用任何 .col-md-<em> 栅格类适用于与屏幕宽度大于或等于分界点大小的设备 ， 并且针对小屏幕设备覆盖栅格类。 因此，在元素上应用任何 .col-lg-</em> 不存在， 也影响大屏幕设备。<br>通过研究后面的实例，可以将这些原理应用到你的代码中。</li>
</ul>
<p>##媒体查询<br>在栅格系统中，我们在 Less 文件中使用以下媒体查询（media query）来创建关键的分界点阈值。</p>
<ul>
<li>/<em> 超小屏幕（手机，小于 768px） </em>/</li>
<li>/<em> 没有任何媒体查询相关的代码，因为这在 Bootstrap 中是默认的（还记得 Bootstrap 是移动设备优先的吗？） </em>/</li>
<li></li>
<li>/<em> 小屏幕（平板，大于等于 768px） </em>/</li>
<li>@media (min-width: @screen-sm-min) { … }</li>
<li></li>
<li>/<em> 中等屏幕（桌面显示器，大于等于 992px） </em>/</li>
<li>@media (min-width: @screen-md-min) { … }</li>
<li></li>
<li>/<em> 大屏幕（大桌面显示器，大于等于 1200px） </em>/</li>
<li>@media (min-width: @screen-lg-min) { … }</li>
<li></li>
</ul>
<p>我们偶尔也会在媒体查询代码中包含 max-width 从而将 CSS 的影响限制在更小范围的屏幕大小之内。</p>
<ul>
<li>@media (max-width: @screen-xs-max) { … }</li>
<li>@media (min-width: @screen-sm-min) and (max-width: @screen-sm-max) { … }</li>
<li>@media (min-width: @screen-md-min) and (max-width: @screen-md-max) { … }</li>
<li>@media (min-width: @screen-lg-min) { … }</li>
</ul>
<p>#组件</p>
<p>##导航<br>Bootstrap 中的导航组件都依赖同一个 .nav 类，状态类也是共用的。改变修饰类可以改变样式。</p>
<p>##模态框 modal.js</p>
<p>模态框经过了优化，更加灵活，以弹出对话框的形式出现，具有最小和最实用的功能集。</p>
<p>不支持同时打开多个模态框<br>千万不要在一个模态框上重叠另一个模态框。要想同时支持多个模态框，需要自己写额外的代码来实现。</p>
<p>模态框的 HTML 代码放置的位置<br>务必将模态框的 HTML 代码放在文档的最高层级内（也就是说，尽量作为 body 标签的直接子元素），以避免其他组件影响模态框的展现和/或功能。</p>
<p>对于移动设备的附加说明<br>这里提供了在移动设备上使用模态框有一些附加说明。请参考浏览器支持章节。</p>
<p>Due to how HTML5 defines its semantics, the autofocus HTML attribute has no effect in Bootstrap modals. To achieve the same effect, use some custom JavaScript:</p>
<p>$(‘#myModal’).on(‘shown.bs.modal’, function () {<br>  $(‘#myInput’).focus()<br>})</p>
<p>##Carousel (轮播图)</p>
<p>#定制<br>为使我们上线的代码更加的轻量/简洁:可以根据需求定制属于自己的bootstrap</p>
<p>定制并下载 Bootstrap<br>通过自定义 Bootstrap 组件、Less 变量和 jQuery 插件，定制一份属于你自己的 Bootstrap 版本吧。</p>
<p>以上的版本基于3.0的学习<br>详细地址:<a href="http://http://v3.bootcss.com/" title="Bootstrap3中文文档" target="_blank" rel="external">http://http://v3.bootcss.com/</a></p>
</head>]]></content>
      
        
        <tags>
            
            <tag> 前端框架_Bootstrap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Bootstrap的笔记]]></title>
      <url>/2015/08/18/bootstrap/</url>
      <content type="html"><![CDATA[<p>##Bootstrap的笔记</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1268909-abc2a99ad3326d8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><strong>1.1   什么是bootstrap?</strong></p>
<p>bootstrap是当下最流行的前端框架（界面工具集);</p>
<p>特点是灵活简介、代码优雅、美观大方；</p>
<p>目的在于让web开发更加迅速、敏捷；</p>
<p>由Twitter公司的两名前端工程师Mark Otto和Jacob Thornton在2011年发起的，并利用业余时间完成了第一个版本的开发。<br><a id="more"></a></p>
<p><strong>1.2    什么是框架？</strong></p>
<p>库 lib library 框架 Framework；</p>
<p>写的更少做的更多 提供一套较为便捷的操作方式；</p>
<p>将一套功能体系封装到一个单独的文件中的东西；</p>
<p>Bootstrap提供一套前端需要的界面工具集合。</p>
<p><strong>1.3    为什么使用Bootstarp？</strong></p>
<p>生态圈火，不断地更新迭代；</p>
<p>提供一套美观大方地界面组件；</p>
<p>提供一套优雅的 HTML+CSS 编码规范；</p>
<p>让我们的 Web 开发更简单，更快捷。</p>
<blockquote>
<p>注意:</p>
<ol>
<li><p>使用 Bootstrap 并不代表不用写 CSS 样式，而是不用写绝大多数大家都会用到的样式</p>
</li>
<li><p>Bootstrap 不是 BootStrap！这是一个词，不是合成词，其含义为：n. 引导指令,引导程序</p>
</li>
</ol>
</blockquote>
<p><strong>1.4    如何使用bootstrap?</strong></p>
<p>下载Bootstrap</p>
<p><a href="https://github.com/twbs/bootstrap/releases/download/v3.3.6/bootstrap-3.3.6-dist.zip" target="_blank" rel="external">https:\/\/github.com\/twbs\/bootstrap\/releases\/download\/v3.3.6\/bootstrap-3.3.6-dist.zip</a>         <a href="https://github.com/twbs/bootstrap/releases/download/v4.0.0-alpha.2/bootstrap-4.0.0-alpha.2-dist.zip" target="_blank" rel="external">https:\/\/github.com\/twbs\/bootstrap\/releases\/download\/v4.0.0-alpha.2\/bootstrap-4.0.0-alpha.2-dist.zip</a></p>
<p><strong>1.5  Bootstrap文档</strong></p>
<p><a href="http://getbootstrap.com/" target="_blank" rel="external">官方文档</a></p>
<p><a href="http://v3.bootcss.com/" target="_blank" rel="external">中文文档</a></p>
<p><strong>1.6   Bootstrap初始化模板</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">    &lt;html lang="en"&gt;</div><div class="line">    &lt;head&gt;</div><div class="line">      &lt;meta charset="UTF-8"&gt;</div><div class="line">      &lt;title&gt;页面标题&lt;/title&gt;</div><div class="line">      &lt;!-- 引入Bootstrap核心样式文件（必须） --&gt;</div><div class="line">      &lt;link rel="stylesheet" href="css/bootstrap.min.css"&gt;</div><div class="line">      &lt;!-- 引入Bootstrap默认主题样式（可选） --&gt;</div><div class="line">      &lt;link rel="stylesheet" href="css/bootstrap.theme.min.css"&gt;</div><div class="line">      &lt;!-- 你自己的样式或其他文件 --&gt;</div><div class="line">      &lt;link rel="stylesheet" href="example.css"&gt;</div><div class="line">    &lt;/head&gt;</div><div class="line">    &lt;body&gt;</div><div class="line">      &lt;!-- 你的HTML结构...... --&gt;</div><div class="line">      &lt;!-- 以下代码，如果不使用JS插件则不需要 --&gt;</div><div class="line">      &lt;!-- 由于Bootstrap的JS插件依赖jQuery，so 引入jQuery --&gt;</div><div class="line">      &lt;script src="js/jquery.min.js"&gt;&lt;/script&gt;</div><div class="line">      &lt;!-- 引入所有的Bootstrap的JS插件 --&gt;</div><div class="line">      &lt;script src="bootstrap.min.js"&gt;&lt;/script&gt;</div><div class="line">      &lt;!-- 你自己的脚本文件 --&gt;</div><div class="line">      &lt;script src="example.js"&gt;&lt;/script&gt;</div><div class="line">    &lt;/body&gt;</div><div class="line">    &lt;/html&gt;</div></pre></td></tr></table></figure>
<p><strong>1.7   Bootstrap相关知识点</strong></p>
<p>（1）Compatible：此属性为文档兼容模式声明，表示如果在IE浏览器下则使用最新的标准渲染当前文档;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</div></pre></td></tr></table></figure>
<p>（2）视口： 此属性为移动端页面视口设置，当前值表示在移动端页面的宽度为设备的宽度，并且不缩放（缩放级别为1）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;</div></pre></td></tr></table></figure>
<p>（3）第三方依赖:</p>
<ul>
<li><p>boostrap的js组件依赖jquery实现 (<a href="https://github.com/jquery/jquery" target="_blank" rel="external">https:\/\/github.com\/jquery\/jquery</a>)</p>
</li>
<li><p>当低版本浏览器不识别新标签时兼容（<a href="https://github.com/aFarkas/html5shiv" target="_blank" rel="external">html5shiv</a>）</p>
</li>
<li><p>让低版本浏览器可以使用CSS的媒体查询 （<a href="https://github.com/scottjehl/Respond" target="_blank" rel="external">respond</a>）</p>
</li>
</ul>
<p>（4）全局CSS样式:</p>
<ul>
<li>修饰已有的标签，比如按钮、文本框之类的</li>
</ul>
<p>（5）组件:   提供一套比较常用的UI组件，比如：按钮、下拉菜单、导航等</p>
<p>[导航](http:\/\/v3.bootcss.com\/components\/#nav)</p>
<p>[导航条](http:\/\/v3.bootcss.com\/components\/#navbar)</p>
<p>[面包屑导航](http:\/\/v3.bootcss.com\/components\/#breadcrumbs)</p>
<p>[下拉菜单](http:\/\/v3.bootcss.com\/components\/#dropdowns)</p>
<p>[按钮式下拉菜单](http:\/\/v3.bootcss.com\/components\/#btn-dropdowns)</p>
<p>[按钮组](http:\/\/v3.bootcss.com\/components\/#btn-groups)</p>
<p>[输入框组](http:\/\/v3.bootcss.com\/components\/#input-groups)</p>
<p>[警告框](http:\/\/v3.bootcss.com\/components\/#alerts)</p>
<p>[页头](http:\/\/v3.bootcss.com\/components\/#page-header)</p>
<p>[分页](http:\/\/v3.bootcss.com\/components\/#pagination)</p>
<p>[列表组](http:\/\/v3.bootcss.com\/components\/#list-group)</p>
<p>[面板](http:\/\/v3.bootcss.com\/components\/#panels)</p>
<p>[媒体对象](http:\/\/v3.bootcss.com\/components\/#media)</p>
<p>[进度条](http:\/\/v3.bootcss.com\/components\/#progress)</p>
<p>[Glyphicons](http:\/\/v3.bootcss.com\/components\/#glyphicons)</p>
<p>[标签](http:\/\/v3.bootcss.com\/components\/#labels)</p>
<p>[徽章](http:\/\/v3.bootcss.com\/components\/#badges)</p>
<p>[缩略图](http:\/\/v3.bootcss.com\/components\/#thumbnails)</p>
<p>[大屏幕](http:\/\/v3.bootcss.com\/components\/#jumbotron)</p>
<p>[嵌入内容](http:\/\/v3.bootcss.com\/components\/#responsive-embed)</p>
<p>[内嵌](http:\/\/v3.bootcss.com\/components\/#wells)</p>
<p>（6）JavaScript插件:   开发中常用的特效继承，依赖于jQuery</p>
<p>[模态对话框](http:\/\/v3.bootcss.com\/javascript\/#modals)</p>
<p>[下拉菜单](http:\/\/v3.bootcss.com\/javascript\/#dropdowns)</p>
<p>[滚动监听](http:\/\/v3.bootcss.com\/javascript\/#scrollspy)</p>
<p>[标签页](http:\/\/v3.bootcss.com\/javascript\/#tabs)</p>
<p>[工具提示](http:\/\/v3.bootcss.com\/javascript\/#tooltips)</p>
<p>[弹出框](http:\/\/v3.bootcss.com\/javascript\/#popovers)</p>
<p>[警告框](http:\/\/v3.bootcss.com\/javascript\/#alerts)</p>
<p>[按钮](http:\/\/v3.bootcss.com\/javascript\/#buttons)</p>
<p>[折叠面板](http:\/\/v3.bootcss.com\/javascript\/#collapse)</p>
<p>[轮播图](http:\/\/v3.bootcss.com\/javascript\/#carousel)</p>
<p>[吸顶效果](http:\/\/v3.bootcss.com\/javascript\/#affix)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">data-spy=&quot;affix&quot;</div><div class="line"></div><div class="line">data-offset-top=&quot;什么位置出现&quot;</div><div class="line"></div><div class="line">data-offset-bottom=&quot;什么位置消失&quot;</div></pre></td></tr></table></figure>
<pre><code>&lt;!--
    兼容的
    IE = edge:告诉浏览器以最新的解析器来解析代码
--&gt;
&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
</code></pre><p>快捷打出视口–&gt;mate:vp加tab键</p>
<pre><code>  &lt;!--device-width:动态布置
     user-scalable  是否允许缩放  不允许
     让wap App 更加接近原生
--&gt;
&lt;meta name=&quot;viewport&quot;
      content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;
&lt;!--
    PC端-&gt;移动互联网的兴起-&gt;app
    PC-&gt;网站(网页)-&gt;手机端(web )
--&gt;

 &lt;!--
    Bootstrap  兼容到IE8
    HTML5 标签  &lt;head&gt; &lt;section&gt; &lt;footer&gt;
    CSS的属性   媒体查询

    html5shiv  让IE8的解析器能够识别html5的新标签
      respond  css3
      JS是用于处理一些标签的或者处理一些样式的导入在前面
    --&gt;
&lt;!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries --&gt;
&lt;!-- WARNING: Respond.js doesn&apos;t work if you view the page via file:// --&gt;
&lt;!--[if lt IE 9]&gt;
&lt;script src=&quot;https://cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js&quot;&gt;&lt;/script&gt;
</code></pre><p>字体图标 矢量的字</p>
<p>sr-only:屏幕阅读器,盲文.读出来<br>全称是 screen reader only，意为：（仅供）屏幕阅读器，这个 class 主要用于增强 accessbility（可访问性）。</p>
<p>##站点图标<br>link:favicon来引入</p>
<p>自定义字体图标:醉牛前端下的<br><img src="http://i.imgur.com/0YwMuum.png" alt=""></p>
<p>###定义类名一般是<br>tab-title</p>
<p>###定义id一般是<br>tab_title</p>
<p>##按钮样式生成</p>
<p><a href="http://blog.koalite.com//bbg//" target="_blank" rel="external">http://blog.koalite.com//bbg//</a></p>
<p>##新闻中心区域</p>
<p>涉及要点:栅(shan)格偏移<br>栅(zan)栏;</p>
]]></content>
      
        
        <tags>
            
            <tag> 前端框架_bootstrap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JQUERY的网页应用]]></title>
      <url>/2015/06/21/jQuery%E7%BD%91%E9%A1%B5%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>##JQUERY的网页应用</p>
<p> /<em>一.设置吸顶效果</em>/</p>
<p> /<em>1.0获取NAV距离顶部的间距</em>/</p>
<p>/<em>1.1监听滚动，设置对应的样式</em>/</p>
<p>/<em>1.2获取滚动的距离</em>/</p>
<p>/<em>1.3判断比较设置样式</em>/</p>
<p>/<em>1.31设置图片的透明度，让图片出来</em>/<br><a id="more"></a></p>
<p>  /<em>二.设置返回顶部</em>/</p>
<p> //2.1判断</p>
<p>/<em>2.2点击BACK_TOP返回顶部</em>/</p>
<p> //2.21让回到顶部</p>
<p> /<em>三.添加LI</em>/<br>/<em>3.0使用数组来记录事项</em>/</p>
<p> /<em>当界面加载进来的时候，就去从从存储的数据中拿出对应的数据，如果没有才去加载</em>/</p>
<p> /<em>渲染界面</em>/</p>
<p>/<em>3.0去掉默认行为</em>/</p>
<p>/<em>3.1获取INPUT中内容，判断</em>/</p>
<p>  /<em>3.2创建事项</em>/</p>
<p>/<em>3.2设置事项的相关属性</em>/</p>
<p>/<em>3.3添加到数组中中保存起来</em>/</p>
<p> /<em>3.4根据数组的长度，添加节点而且吧节点显示出来</em>/</p>
<p> /<em>3.5存储数据</em>/</p>
<p> /*0.存储数据，第一个参数用来表示存储的数据的标示，任何值都可以，只是用这个值来取出数据</p>
<pre><code>* 第二个参数表示要存储的数据*/
</code></pre><p>/<em>把上一次的内容清空</em>/</p>
<p>/<em>注意：为了让对应的CHECKBOX点击的时候，让对应的不同的事项中添加不同的LI</em>/</p>
<p>/<em> 所以我们需要改造渲染方法</em>/</p>
<p>  /<em>3.41根据数组中的个数。来添加节点</em>/</p>
<p>//为了规范和严格要进行元素的判定</p>
<p> /<em>3.42创建LI</em>/</p>
<p>  // DATA-INDEX:用来给LI绑定索引</p>
<p>  /<em>3.43添加LI</em>/</p>
<p>   /<em>根据是否检查过，来确定添加到待选事件还是完成事件</em>/</p>
<p>/<em>四.切换TAB</em>/</p>
<p>   /<em>4.1点击LI切换TAB</em>/</p>
<p>   /<em>4.2获取点击的索引值</em>/</p>
<p>   /<em>4.3切换下面的DIV</em>/<br>/<em>五，点击删除按钮删除对应的LI</em>/</p>
<p>/<em>5.1获取DEL所在的LI</em>/</p>
<p>/<em>5.2获取LI对应的索引值</em>/</p>
<p>/<em>5.3为了代码严格，我们可以回索引进行判断</em>/</p>
<p> /<em>5.4删除数组中的元素</em>/</p>
<p>/<em>5.5删除节点</em>/</p>
<p>/<em>5.6存储数据</em>/</p>
<p>/<em>六.点击待办事项，让对应的事项有待办变为已经完成</em>/</p>
<p>/<em>6.1确定点击的索引</em>/</p>
<p>/<em>6.2拿出INDEX中对应的数组中的元素</em>/</p>
<p>/<em>6.3设置ISCHECK为选中</em>/</p>
<p>/<em>用OBJ替换原来位置的元素</em>/</p>
<p> /<em>6.4进行界面设置</em>/</p>
<p> /<em>6.5存储数据</em>/</p>
<p> /<em>七.点击详情按钮的处理</em>/</p>
<p> /<em>设置一个值用来表示当前点击的是哪一个</em>/</p>
<p> /<em>7.1设置让对应MASK出来</em>/</p>
<p> /<em>7.2获取点击详情按钮的索引</em>/</p>
<p>/<em>7.21设置CURR_INDEX的值</em>/</p>
<p>/<em>7.3根据索引值获取数组中对应的元素</em>/</p>
<p> /<em>7.4根据对应的事项设置我们具体的内容</em>/</p>
<p>/<em>7.41设置标题</em>/</p>
<p>/<em>7.42设置内容</em>/</p>
<p>/<em>7.43设置提醒时间</em>/</p>
<p> /<em>八.处理事件的相关点击</em>/</p>
<p>  /<em>8.1点击内容阻止冒泡</em>/</p>
<p>/<em>8.11阻止冒泡</em>/</p>
<p>  /<em>8.2设置当光标移动到INPUT中设置时间的时候，让对应的时间的选择器展示出来</em>/</p>
<p>  /<em>8.21设置本地化时间(设置中国时间)</em>/</p>
<p>   /<em>8.22给对应的标签设置对应时间选择器</em>/</p>
<p>/<em>九.更新数据和界面</em>/</p>
<p>  /<em>9.1获取点击详细按钮对应的索引值</em>/</p>
<p>   /<em>9.2根据索引值获取对应数组中的元素</em>/</p>
<p>/<em>9.3设置元素的数据</em>/</p>
<p> /<em>IS_NOTICE：表示有没有提醒去做对应事项</em>/</p>
<p>/<em>9.4赋值回原来的位置</em>/</p>
<p> /<em>9.5存储数据</em>/</p>
<p>/<em>9.6更新界面</em>/</p>
<p>/<em>9.7让当前的MASK消失</em>/</p>
<p> /<em>十.提醒设置</em>/</p>
<p>/<em>10.1我们需要时时刻刻比较当前的时间和设置的时间，所以要使用定时器</em>/</p>
<p> /<em>10.2获取每一元素的的提醒时间，和当前时间比较，需要使用遍历</em>/</p>
<p>/<em>10.3判断当前的时间是否大于提醒时间</em>/</p>
<p>  /<em>10.31获取每一提醒时间的毫秒数</em>/</p>
<p>  //需要提醒，让对应铃声响起</p>
<p>   /<em>获取的对象是JQUERY对象我们需要转化成JS对象</em>/</p>
<p>/<em>10.4当铃声响起后，表示已经提醒过了，我们要设置提醒为<br>TRUE</em>/</p>
<p> /<em>10.5重新赋值</em>/</p>
<p> /<em>10.6数据变化，就要存储数据</em>/# #</p>
]]></content>
      
        
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jQuery的简介,操作css与html]]></title>
      <url>/2015/06/15/jQuery%E7%9A%84%E7%AE%80%E4%BB%8B,%E6%93%8D%E4%BD%9Ccss%E4%B8%8Ehtml/</url>
      <content type="html"><![CDATA[<p>  主旨:write less , do more</p>
<pre><code>特点:1.轻量级
 2.强大的处理器
 3.出色的Dom封装
 4.可靠的事件处理
 5.浏览器兼容性强
 6.链式操作方式
 7.隐式迭代
</code></pre><a id="more"></a>
<pre><code>Window.onload 与 $(document).ready()的区别
Window.onload
执行时机:必须等待网页全部加载完毕(包括图片等),然后再执行包裹的代码
执行次数:只能执行一次,如果第二次执行,会把第一次的执行覆盖掉
$(document).ready()
执行时机:只需要等待网页中的DOM结构加载完毕,就能执行包裹着的代码
执行次数:可以执行多次,第N次都不会被上一次覆盖
$(function(){

});

jQuery操作CSS:
  通过jQuery操作CSS样式,直接设置CSS样式,增加CSS类别.类别切换/删除等操作
额外补充:
选择一个类标签
  $(&apos;className&apos;)
给一个标签添加事件
  $(&apos;className&apos;).click(function(){

     });
点击标签时候,执行匿名函数;
</code></pre><p> 直接操作</p>
<pre><code>$(&apos;button&apos;).click(function){
         $(&apos;div&apos;).css(&apos;width&apos;,&apos;200px&apos;);
         $(&apos;div&apos;).css(&apos;height&apos;,&apos;200px&apos;);
         $(&apos;div&apos;).css(&apos;background&apos;,&apos;red&apos;);


   }
</code></pre><p>  链式写法</p>
<pre><code>  $(&apos;button&apos;).click(
        function(){
         $(&apos;div&apos;).css(&apos;width&apos;,&apos;200px&apos;)
                  .css(&apos;height&apos;,&apos;200px&apos;)
                  .css(&apos;background&apos;,&apos;red&apos;)
       })
相同的对象,可以省略对象名称,直接在后面进行操作

$(&apos;div&apos;).css(&quot;width&quot;,200);
$(&apos;div&apos;).css(&quot;height&quot;,200);
$(&apos;div&apos;).css(&quot;background&quot;,&quot;red&quot;);
链式操作形式
$(&apos;div&apos;).css(&apos;width&apos;,&apos;200px&apos;)
         .css(&apos;height&apos;,&apos;200px&apos;)    
         .css(&apos;background&apos;,&apos;red&apos;)      

键值对key:value写法
$(&apos;buttton&apos;).click(function(){
$(&apos;div&apos;).css({
    width:200,
    height:200,
    background:&apos;red&apos;
});
)    
       添加类:
  addClass(class)给某个元素添加一个CSS类
  $(&apos;div&apos;).addClass(&apos;myClass1&apos;);

   addClass(class1  class2 class3...)给某个元素添加多个css类,添加多个类时,类名使用空格隔开
    $(&apos;div&apos;).addClass(&apos;myClass1 myClass2&apos;)
注意点:添加的类名没有&quot;点&quot;
</code></pre><p>  删除类</p>
<pre><code>removeClass(class)删除某个元素的一个CSS类
   $(&apos;div&apos;).removeClass(&apos;myClass1&apos;);
removeClass(class1 class2 class3)删除某个元素的多个css类
   $(&apos;div&apos;).removeClass(&apos;myClass1 myClass2 myClass3&apos;)
</code></pre><p>  切换类</p>
<pre><code>toggleClass(class)来回切换默认样式和指定样式
   $(&apos;div&apos;).toggleClass(&apos;myClass1&apos;);
同样也可以在多个类之前进行切换
$(&apos;div&apos;).toggleClass(&apos;myClass1 myClass2&apos;)


1.jQuery的CSS的获取与修改宽高
   不带值为获取,带值为修改.
   width()
   width(value)
   height()
   height(value)

2.获取元素偏移
 offset() 获取某个元素相对于视口的偏移位置
 offset().left;
 offset().top;

  position()获取某个原色相对于父元素的偏移位置
  position().left
  position().top

3.使用jQuery可以给一个标签内部添加以及获取标签

  没有值代表获取,有值代表添加标签
 html();
 html(value);
 获取标签当中的内容
 text();

text(value);
</code></pre><p>####jQuery本质上就是一个闭包</p>
<p>####为什么要使用闭包<br>1.为了避免和别的框架冲突</p>
<p>#####为什么使用window<br>①在闭包内部的变量在外部是不可以使用的,我们需要使用,所以我们需要把它传递出外面来。</p>
<p>② 使用window的第一个作用是把内部的变量传递出来给外面使用<br>  第二个作用是用来压缩代码。</p>
<p>####undefined在ie9之前是可以修改,但是我们现在不想修改<br>一：把undefined传入进来防止修改</p>
<p>二：用来压缩代码</p>
]]></content>
      
        
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常用数组方法]]></title>
      <url>/2015/04/20/%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%8D%E6%87%82%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。</p>
<p>empty() 方法从被选元素移除所有内容，包括所有文本和子节点。</p>
<p>trim() 函数返回去掉开头和结尾空格后的字符串</p>
<p>prepend() 方法在被选元素的开头（仍位于内部）插入指定内容</p>
<p>data() 方法向被选元素附加数据，或者从被选元素获取数据。</p>
]]></content>
      
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[面向对象2]]></title>
      <url>/2015/04/19/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1day2/</url>
      <content type="html"><![CDATA[<h3 id="一-面向对象的相关概念"><a href="#一-面向对象的相关概念" class="headerlink" title="一:面向对象的相关概念"></a>一:面向对象的相关概念</h3><pre><code>01 对象是什么?
什么都是对象.对象是具体的事物
思考:电脑(分类) 人 桌子 狗 猫 老师 同学  这些都不是对象,只是一种类别.
</code></pre><a id="more"></a>
<pre><code>02 对象的描述信息(静态特征)
张三: 身高 体重 身份证号码 专业 班级 名字
李四家的狗: 颜色 年龄 名字
03 对象的行为特征(动态的行为)
张三: 吃饭 睡觉 打游戏 跑步
李四家的狗: 吃饭 叫 睡觉 打架 流口水
04 js的对象
对象定义:键值对(key-value)的集合 | 属性(方法)的工具包|对遍历和函数的封装.
对象的组成:
    静态特征:属性(定义在对象中变量)    
    动态行为:方法(定义在对象中函数)
05 补充:
面向对象和面向过程并没有孰优孰劣,解决问题的时候需要看实际的情况(选取正确的方案)
为什么要使用面向对象的方式来写代码? 方便 节省 复用性高
&lt;script&gt;
var dog = {
    name:&quot;旺财&quot;,
    age:13,
    color:&quot;紫色&quot;,
    eat: function () {
        console.log(&quot;eat&quot;);
    },
    sleepp:function (){
        console.log(&quot;sleep&quot;);
    },
    run:function () {
        console.log(&quot;run&quot;);
    }
}

console.log(dog);   //object  { dog对象的东西 }
dog.eat();      //eat
dog.run();      //run


&lt;/script&gt;
</code></pre><h3 id="二-创建并设置标签样式的小案例-面向过程"><a href="#二-创建并设置标签样式的小案例-面向过程" class="headerlink" title="二:创建并设置标签样式的小案例(面向过程)"></a>二:创建并设置标签样式的小案例(面向过程)</h3><pre><code>div&lt;我是第$个div标签&gt;*6

p&lt;我是第$个p标签&gt;*3    

 冗余度(重复的代码很多)
&lt;script&gt;
//01 获得页面中所有的div标签
var divs = document.getElementsByTagName(&quot;div&quot;);
//02 遍历所有的标签并且设置
for (var i = 0; i &lt; divs.length; i++) {
    divs[i].style.border = &quot;1px solid red&quot;;
}

//03 获得页面中所有p标签
var ps = document.getElementsByTagName(&apos;p&apos;);
//04 遍历所有的标签并且设置
for (var i = 0; i &lt; ps.length; i++) {
    ps[i].style.border = &apos;1px solid red&apos;;
}
&lt;/script&gt;
</code></pre><h3 id="三-函数封装-面向过程"><a href="#三-函数封装-面向过程" class="headerlink" title="三:函数封装(面向过程):"></a>三:函数封装(面向过程):</h3><pre><code>&lt;div&gt;我是第1个div标签&lt;/div&gt;
&lt;div&gt;我是第2个div标签&lt;/div&gt;
&lt;div&gt;我是第3个div标签&lt;/div&gt;
&lt;div&gt;我是第4个div标签&lt;/div&gt;
&lt;div&gt;我是第5个div标签&lt;/div&gt;
&lt;div&gt;我是第6个div标签&lt;/div&gt;

需求    :设置页面中所有div标签的样式（边框） border = &quot;1px solid red&quot;;
 设置页面中所有的p标签的样式（边框） border = &quot;1px solid red&quot;;
&lt;p&gt;我是第1个p便签&lt;/p&gt;
&lt;p&gt;我是第2个p便签&lt;/p&gt;
&lt;p&gt;我是第3个p便签&lt;/p&gt;
&lt;script&gt;

//把固定不变的部分抽取作为函数体
//把改变的部分抽取作为函数的参数
function getEle(tagName) {
    return document.getElementsByTagName(tagName);
}
function setBorder(eles) {
    for (var i = 0; i &lt; eles.length; i++) {
        eles[i].style.border = &quot;1px solid red&quot;;
    }
}

var divs = getEle(&quot;div&quot;);
var ps = getEle(&quot;p&quot;);
setBorder(divs);
setBorder(ps);

&lt;/script&gt;
</code></pre><h3 id="四-函数封装-面向对象"><a href="#四-函数封装-面向对象" class="headerlink" title="四:函数封装(面向对象)"></a>四:函数封装(面向对象)</h3><pre><code>&lt;div&gt;我是第1个div标签&lt;/div&gt;
&lt;div&gt;我是第2个div标签&lt;/div&gt;
&lt;div&gt;我是第3个div标签&lt;/div&gt;
&lt;div&gt;我是第4个div标签&lt;/div&gt;
&lt;div&gt;我是第5个div标签&lt;/div&gt;    
&lt;div&gt;我是第6个div标签&lt;/div&gt;

需求:设置页面中所有div标签的样式（边框） border = &quot;1px solid red&quot;;
 设置页面中所有的p标签的样式（边框） border = &quot;1px solid red&quot;;
&lt;p&gt;我是第1个p便签&lt;/p&gt;
&lt;p&gt;我是第2个p便签&lt;/p&gt;
&lt;p&gt;我是第3个p便签&lt;/p&gt;

冗余度 （重复的内容）

&lt;script&gt;

//把固定不变的部分抽取作为函数体
//把改变的部分抽取作为函数的参数
//使用对象来进行封装
var XMGQuery =  {
    getEle:{
        tagName:function (tagName) {
            return document.getElementsByTagName(tagName);
        },
        id:function (id) {
            return document.getElementById(id);
        },
        calssName:function (classNmae) {
            return document.getElementsByClassName(classNmae);
        },
    },
    setStyle:{
        setBorder:function (eles) {
            for (var i = 0; i &lt; eles.length; i++) {
                eles[i].style.border = &quot;1px solid red&quot;;
            }
        },
        setColor:function (eles) {
            for (var i = 0; i &lt; eles.length; i++) {
                eles[i].style.color = &quot;red&quot;;
            }
        }
    }
}
XMGQuery.setStyle.setBorder(XMGQuery.getEle.tagName(&quot;div&quot;));
XMGQuery.setStyle.setBorder(XMGQuery.getEle.tagName(&quot;p&quot;));

&lt;/script&gt;
</code></pre><h3 id="六-面向对象的三大特效"><a href="#六-面向对象的三大特效" class="headerlink" title="六:面向对象的三大特效"></a>六:面向对象的三大特效</h3><pre><code>01封装
好处:复用(!),降低冗余度,更有利于模块化编程,能够为变量函数提供更多的保护.使用对象来封装变量和函数
02 继承
现实中继承：一般是子女获得父母的财富|资源的一种方式。
代码中继承：子类获得父类的属性和方法（成员）的一种方式。
js中的继承:
严格来说js并不是一门面向对象的语言(类-class),支持面向对象而已.
js中的继承是一个对象获得另外一个对象的属性和方法的一种行为.
术语:
父类
子类
超类
js中
父对象 - 子对象
a---b(属性|方法)
实现方法
001 属性拷贝(浅拷贝)
002 属性拷贝(深拷贝)
003 原型式继承
004 原型链继承
005 借用构造函数
006 组合继承
02.多态
多种形态
特点:对于同一个操作(指令),不同的对象表现出不同的反应,隐藏不同
观点:js天生就是一门支持多态的语法.
好处:灵活
&lt;script&gt;
var obj = {
    name :&quot;旺财&quot;,
    age:20,
    friends:[&quot;乌拉乌拉&quot;,&quot;扒拉扒拉&quot;,&quot;哗啦哗啦&quot;],
    showName:function () {
        console.log(this.name);
    }
};

var o = {};

//o 对象需要获得obj对象的属性和方法  o 子对象 obj父对象
 //    o.name = obj.name;
    //    o.age = obj.age;
//    o.showName = obj.showName;
//    o.showName();

for(var k in obj)
{
   // o.k = obj.k;
    o[k] = obj[k];
}
console.log(o);

//如果是引用类型，那么会有共享的问题
obj.friends.push(&quot;无力无力&quot;);
console.log(o);
</code></pre><h3 id="七-创建对象的几种方式"><a href="#七-创建对象的几种方式" class="headerlink" title="七:创建对象的几种方式"></a>七:创建对象的几种方式</h3><pre><code>01 字面量
02 内置构造函数 new Object()|new Date()
03 简单工厂函数创建
04 自定义构造函数
05 Object.create()
&lt;script&gt;

//书（对象）
//属性：书名 | 作者 | 出版社 | 价格
//方法：deslog 打印书本的介绍信息

var book1 = {
    name:&quot;西游记&quot;,
    author:&quot;吴承恩&quot;,
    press:&quot;中华书局&quot;,
    price:&quot;0.1&quot;,
    desLog:function () {
        console.log(&quot;书名：&quot; + this.name + &quot; 作者：&quot; + this.author);
    }
}
book1.desLog();

//需求：（图书管理员）
var book2 = {
    name:&quot;悟空传&quot;,
    author:&quot;今何在&quot;,
    press:&quot;湖南文艺出版社&quot;,
    price:&quot;28.00&quot;,
    desLog:function () {
        console.log(&quot;书名：&quot; + this.name + &quot; 作者：&quot; + this.author);
    }
}

var book3 = {
    name:&quot;什么是批判&quot;,
    author:&quot;福柯&quot;,
    press:&quot;北京大学出版社&quot;,
    price:&quot;58.00&quot;,
    desLog:function () {
        console.log(&quot;书名：&quot; + this.name + &quot; 作者：&quot; + this.author);
    }
}
console.log(book3);

//......

//问题:如果要创建多个同类型的对象，那么代码冗余度太高（重复的代码），复用性（差）
&lt;/script&gt;

2  内置构造函数
Array Date Object Function String Number Boolean
使用方法:new 构造函数(参数)
&lt;script&gt;
var date = new Date();
var array = new Array();
var string = new String(&quot;demo&quot;);

&lt;/script&gt;
&lt;script&gt;

var book = new Object();
book.name = &quot;三国演义&quot;;
book.author = &quot;罗贯中&quot;;
book.press = &quot;中华书局&quot;;
book.desLog = function () {
    console.log(this.name + this.author);
}
book.desLog();

var book2 = new Object();
book2.name = &quot;红楼梦&quot;;
book2.author = &quot;曹公子&quot;;
book2.press = &quot;中华书局&quot;;
book2.desLog = function () {
    console.log(this.name + this.author);
}
book2.desLog();

//问题：同字面量方式一样
&lt;/script&gt;

3. 简单工厂函数创建对象

&lt;script&gt;

//01 提供一个函数
function createBook(name,author) {
    //02 创建空的对象
    var book = new Object();
    //03 设置对象的属性和方法
    book.name = name;
    book.author = author;
    book.desLog = function () {
        console.log(this.name + this.author);
    }
    //04 把创建的对象返回
    return book;
}

var book1 = createBook(&quot;悟空传&quot;,&quot;孙悟空&quot;);
var book2 = createBook(&quot;红楼梦&quot;,&quot;曹公子&quot;);
console.log(book1);
console.log(book2);
console.log( book1 ==  book2);
book1.desLog();
book2.desLog();
&lt;/script&gt;


4.自定义构造函数
&lt;script&gt;

//01 提供一个函数
function createBook(name,author) {
    //02 创建空的对象
    var book = new Object();
    //03 设置对象的属性和方法
    book.name = name;
    book.author = author;
    book.desLog = function () {
        console.log(this.name + this.author);
    }
    //04 把创建的对象返回
    return book;
}

var book1 = createBook(&quot;悟空传&quot;,&quot;孙悟空&quot;);
var book2 = createBook(&quot;红楼梦&quot;,&quot;曹公子&quot;);
console.log(book1);
console.log(book2);
console.log(book1 == book2);
book1.desLog();
book2.desLog();

//问题（特点）：对象类型判断的问题
function createPerson(name,age) {
    var obj = new Object();
    obj.name = name;
    obj.age = age;
    return obj;
}
function createDog(name,age) {
    var obj = new Object();
    obj.name = name;
    obj.age = age;
    return obj;
}

//创建人对象
var obj1 = createPerson(&quot;张三&quot;,23);
var obj2 = createDog(&quot;李四&quot;,10);

//obj1 --- obj2
console.log(obj1);
console.log(obj2);

//无法区分对象的类型  ：obj1（人）obj2(狗)

&lt;/script&gt;

自定义构造函数创建对象
术语：
构造函数 ==  普通函数，人为的区分（首字母大写）
构造函数：主要做初始化的处理（设置属性和方法）
new :    创建对象（{}）
var obj = new Object();
核心过程
01 提供一个构造函数（普通函数首字母大写）
02 通过this指针来设置对象的属性和方法
03 使用new 构造函数（）创建对象

内部的实现过程：
01 提供构造函数
02 创建一个空的对象{} ===&gt; Object
03 设置新创建对象的原型对象为构造函数的原型对象
04 设置新创建对象的构造函数为当前的构造函数
05 把新创建的对象赋值给this
06 通过this设置属性和方法
07 默认在最后把新创建的对象返回

返回值
01 如果没有显示的return,那么默认在最后把新创建的对象返回
02 如果显示的return,那么结果得看具体的情况：
    001 返回的是值类型的  忽略（返回新对象）
    002 返回的是引用类型的 return的对象会把新创建的对象覆盖
&lt;script&gt;
function Dog(name) {
    this.name = name;
    return [1,2,3];
}

var dog1 = new Dog(&quot;旺财&quot;);
console.log(dog1);
&lt;/script&gt;
&lt;script&gt;
function CreatePerson(name,age) {
    //创建对象{}
    //把新的对象赋值给this
    this.name = name;
    this.age = age;
    this.showName = function () {
        console.log(this.name);
    }
    //默认把新创建的对象返回
}
var p1 = new CreatePerson(&quot;张三&quot;,99);
var p2 = new CreatePerson(&quot;李四&quot;,0.9);
p1.showName();
p2.showName();
&lt;/script&gt;

&lt;script&gt;
function Person(name,age) {
    //01 创建对象{}
    //var o = new Object();    o的构造函数 --- Object
    //02 把新的对象赋值给this
    //this = o;
    //03 设置新创建对象的原型对象为构造函数的原型对象
    //o.__proto__ = Person.prototype;
    //04 设置新创建对象的构造函数为当前的构造函数
    //o.constructor = Person;

    this.name = name;
    this.age = age;
    this.showName = function () {
        console.log(this.name);
    }
    //默认把新创建的对象返回
    //return this;
}
var p1 = new Person(&quot;张三&quot;,99);
var p2 = new Person(&quot;李四&quot;,0.9);
p1.showName();
p2.showName();
&lt;/script&gt;

构造函数和普通函数没有什么区别，人为的进行区分（首字母大写）
构造函数在调用的时候需要和new一起使用
普通函数直接调用
</code></pre><h3 id="八-构造函数注意事项01"><a href="#八-构造函数注意事项01" class="headerlink" title="八:构造函数注意事项01"></a>八:构造函数注意事项01</h3><pre><code>01 函数传值
02 instanceOf
03 对象到底是什么类型(构造器属性)
&lt;script&gt;
function Person(name,doSomething) {
    this.name = name;
    this.doSomething = doSomething;
}

var p1 = new Person(&quot;张三&quot;,function () {
    console.log(&quot;流口水&quot;);
});
var p2 = new Person(&quot;李四&quot;,function () {
    console.log(&quot;咬人&quot;);
});
p1.doSomething();
p2.doSomething();
&lt;/script&gt;
&lt;script&gt;
function Book(name) {
    this.name = name;
}
function Dog(name) {
    this.name = name;
}

var obj1 = new Book(&quot;阿黄&quot;);
var obj2 = new Dog(&quot;阿黄&quot;);

//可以区分对象的类型
//instanceOf  检查某个对象是否是指定构造函数的实例对象（是不是它创建出来）
console.log(obj1 instanceof Book);   //true
console.log(obj2 instanceof Book);  //false
console.log(obj1 instanceof Dog);   //false
console.log(obj2 instanceof Dog);   //true
console.log(obj1 instanceof Object);  //true Object是所有对象的基本对象

//var obj3 = {};
//obj3 是什么类型？
console.log(obj1.constructor);      //Book
console.log(obj2.constructor);      //Dog
&lt;/script&gt;
</code></pre><h3 id="九-函数注意事项02"><a href="#九-函数注意事项02" class="headerlink" title="九:函数注意事项02"></a>九:函数注意事项02</h3><pre><code>01 构造函数必须要和new一起使用，如果直接调用那么无法创建对象
02 this的指向
如果是使用new 构造函数（）调用，那么this---&gt;具体的对象
如果是以普通函数的方式调用吧，那么this ----&gt;window

03 this的丢失问题

&lt;script&gt;

window.name = &quot;xxxxxx&quot;;
var obj = {
    name:&quot;张三&quot;,
    showName:function () {
        console.log(this.name);
    }
}

obj.showName();             //对象.方法  以对象方法的形式来调用函数 （this ---&gt;对象）

var func = obj.showName;
func();   //undefined ? 空  window.name //以普通函数的方式来调用函数（this ---&gt;window）


&lt;/script&gt;
&lt;!--&lt;script&gt;--&gt;
&lt;!--function Dog(name) {--&gt;
    &lt;!--//判断：是否使用new来调用构造函数--&gt;
    &lt;!--//如果使用了new,那么就正常处理，否则就添加上一个new--&gt;
    &lt;!--//默认创建对象并且赋值给this--&gt;
    &lt;!--//if (this != window)--&gt;
    &lt;!--if (this instanceof Dog)--&gt;
    &lt;!--{--&gt;
        &lt;!--this.name = name;--&gt;
        &lt;!--console.log(this,&quot;_______&quot;);--&gt;
    &lt;!--}else--&gt;
    &lt;!--{--&gt;
        &lt;!--return new Dog(name);--&gt;
    &lt;!--}--&gt;

&lt;!--}--&gt;

&lt;!--//01 创建对象--&gt;
&lt;!--var dog1  = new Dog(&quot;阿鲁巴&quot;);--&gt;
&lt;!--var dog2 = Dog(&quot;晓晓&quot;);  //以普通函数的方式来调用构造函数，并不会报错，返回undefined--&gt;

&lt;!--console.log(dog1);--&gt;
&lt;!--console.log(dog2);--&gt;
&lt;!--console.log(window.name);--&gt;
&lt;!--&lt;/script&gt;--&gt;
</code></pre><h3 id="十-构造函数方式创建对象存在的问题"><a href="#十-构造函数方式创建对象存在的问题" class="headerlink" title="十:构造函数方式创建对象存在的问题"></a>十:构造函数方式创建对象存在的问题</h3><pre><code>&lt;script&gt;

//解决思路：把函数抽取到构造函数外部，让多个对象共享同一个函数
function func() {
    console.log(&quot;描述信息&quot;);
}

function Person(name) {
    this.name = name;
    this.showName = function () {
        console.log(this.name);
    };
    this.descriptionLog = func;
}

var p1 = new Person(&quot;张三&quot;);
var p2 = new Person(&quot;张三&quot;);

console.log(p1);
console.log(p2);

p1.showName()
p2.showName();
console.log(p1.showName == p2.showName);        //false
p1.descriptionLog();
p2.descriptionLog();
console.log(p1.descriptionLog == p2.desc riptionLog);

//新的问题：破坏代码的封装性
func();

function func() {
    console.log(&quot;func&quot;)
};

p1.descriptionLog();  //描述信息？（函数提升）

&lt;/script&gt;
</code></pre><h4 id="十一-构造函数的原型对象"><a href="#十一-构造函数的原型对象" class="headerlink" title="十一:构造函数的原型对象"></a>十一:构造函数的原型对象</h4><pre><code>01 什么是原型对象
构造函数有一个默认的相关联的对象，这个对象称为是该构造函数的原型对象
在使用new和构造函数创建对象的时候，内部默认会关联这个新对象的原型对象为当前构造函数的原型对象
这个原型对象默认是一个空的对象

02 原型对象的作用（特点）
构造函数的原型对象 上面的属性和方法 可以被使用该构造函数创建出来的所有对象 所共享

03 如何访问原型对象
001 构造函数.prototype
002 对象.__proto__
003 Object.getPrototype(对象)

04 原型对象的使用：
001 利用对象的动态特性来设置属性和方法
002 直接使用字面量方式替换原型对象

05 约定（说法）
构造函数的原型对象
对象的原型对象
构造函数的原型
对象的原型
&lt;script&gt;
function Person() {

}

console.log(Person.prototype);
Person.prototype = {
    name:&quot;name&quot;
}

var p1 = new Person();
&lt;/script&gt;

使用原型对象解决构造函数方式创建对象的问题
&lt;script&gt;
function Person(name) {
    this.name = name;
}

//设置原型对象
Person.prototype.hi = &quot;hi&quot;;
Person.prototype.showName =  function () {
    console.log(this.name);
};
Person.prototype.descriptionLog = function () {
    console.log(&quot;描述信息&quot;);
}

//创建对象
var p1 = new Person(&quot;张三&quot;);
var p2 = new Person(&quot;张老汉&quot;);
p1.showName();
p2.showName();
p1.descriptionLog();
p2.descriptionLog();
console.log(p1.hi);
console.log(p2.hi);

&lt;/script&gt;
</code></pre><h3 id="十二-实例化和实例"><a href="#十二-实例化和实例" class="headerlink" title="十二:实例化和实例"></a>十二:实例化和实例</h3><pre><code>实例化:
就是使用构造函数创建对象的过程,该过程我们称为实例化

实例:
使用构造函数来创建对象,创建出来的对象就称为这个构造函数的实例.
我们在说实例的时候,需要指明他是哪个构造函数的实例.    
&lt;script&gt;
function Dog(){
}
var dog1 = new Dog();  //实例化的过程
dog1就是Dog这个构造函数的实例.
</code></pre><h3 id="十三-原型的使用方法"><a href="#十三-原型的使用方法" class="headerlink" title="十三:原型的使用方法"></a>十三:原型的使用方法</h3><pre><code>01 利用对象的动态特性
建议:一般情况下,我们会把属性写在对象上面,把方法写在原型上面
&lt;script&gt;
function Car(type,color) {
    this.type = type;
    this.color = color;
}

//设置原型对象的方法
Car.prototype.run = function () {
    console.log(&quot;run&quot;);
}
Car.prototype.desLog = function () {
    console.log(this.type + this.color);
}
//大量的属性|方法
Car.prototype.eat = function () {
    console.log(&quot;eat&quot;);
}
Car.prototype.test1 = function () {
    console.log(&quot;test1&quot;);
}
Car.prototype.demo1 = function () {
    console.log(&quot;demo1&quot;);
}
Car.prototype.friends = [&quot;奥迪&quot;,&quot;奔驰&quot;,&quot;奥拓&quot;];

//创建对象
var car1 = new Car(&quot;奥迪&quot;,&quot;红色&quot;);
var car2 = new Car(&quot;法拉利&quot;,&quot;粉红色&quot;);
console.log(car1);
console.log(car2);
console.log(car1.friends);
console.log(car2.friends);
car1.friends.push(&quot;法拉利未来&quot;);
console.log(car1.friends);
console.log(car2.friends);
&lt;/script&gt;

02 使用字面量的方式直接替换原型对象
&lt;script&gt;
function Person(name) {
    this.name = name;
}

var p1 = new Person(&quot;威整天&quot;);
console.log(p1.hi);      //undefined

//p1.showName();          //威整天
//字面量替换原型对象
Person.prototype = {
    showName:function () {
        console.log(this.name);
    },
    desLog:function () {
        console.log(&quot;秒选信息&quot;);
    },
    hi:&quot;hi&quot;
}

var p2 = new Person(&quot;石破天&quot;);
p2.showName();          //石破天

console.log(p1.hi);      //?

//p1和p2所指向的原型对象并不是同一个
//p1的原型对象是构造函数默认关联的原型对象（空的对象）
//p2的原型对象是{}

&lt;/script&gt;
</code></pre><h3 id="十四-替换原型对象补充"><a href="#十四-替换原型对象补充" class="headerlink" title="十四:替换原型对象补充"></a>十四:替换原型对象补充</h3><pre><code>注意点:
01 注意设置原型对象的位置.建议（在设置完原型对象之后，再统一的创建对象）
02 替换了原型对象之后，需要修正构造器属性 constructor 指向的是创建当前对象的构造函数
    对象中本身并没有constructor属性,该属性是原型对象上面。
&lt;script&gt;
function Person() {
}

//    new Object()
//设置了之后，发现构造器属性指向的是Object而不是Person
Person.prototype = {
    constructor:Person,  //修正构造器属性
    show:function () {
        console.log(&quot;show&quot;);
    }
}

//Person.prototype.constructor ==》Object
//Person.prototype.constructor ==》 Person

var p1 = new Person();
var p2 = new Person();

console.log(p1.constructor == Person);
console.log(p2.constructor == Person);
//获取构造函数的原型对象的构造器属性
console.log(Person.prototype.constructor == Person);
//    Person.prototype.constructor = &quot;hi&quot;;
//    console.log(p1.constructor);
&lt;/script&gt;    
</code></pre><h3 id="十五-原型对象使用的注意点"><a href="#十五-原型对象使用的注意点" class="headerlink" title="十五:原型对象使用的注意点"></a>十五:原型对象使用的注意点</h3><pre><code>01 访问属性 | 方法
访问逻辑：首先先在对象身上查找是否有对应的属性|方法，如果有就直接使用，如果没有那么就查找原型对象
    常用的术语：
        成员：属性 + 方法
        实例成员：实例属性 + 实例方法
        原型成员：原型对象的属性 + 原型对象的方法
 02 设置属性|方法
    通过对象.属性的方式设置的是实例对象的属性
    设置对象的时候，如果是引用类型的，对象.属性.属性是可以设置原型对象的
&lt;script&gt;
function Person(name) {
    this.name = name;
}

Person.prototype = {
    name:&quot;默认的名称&quot;,
    age:20,
    showName:function () {
        console.log(this.name);
    },
    car:{
        type:&quot;火车&quot;,
        color:&quot;黑色&quot;
    }
}

var p = new Person(&quot;张三&quot;);
var p2 = new Person(&quot;李四&quot;);
console.log(p.name);    //张三
console.log(p.age);     //20
p.showName();

//设置属性
p.des = &quot;123&quot;;      //设置在实例对象身上
console.log(p2.des,&quot;___________&quot;);

console.log(p.car);
p.car.type = &quot;飞船&quot;;
console.log(p.car);

p.dog.name = &quot;呼啦哗啦&quot;;
console.log(p.dog.name); //？报错（！）
&lt;/script&gt;
</code></pre><h3 id="十六-proto属性"><a href="#十六-proto属性" class="headerlink" title="十六:proto属性"></a>十六:<strong>proto</strong>属性</h3><pre><code>该属性不是一个标准的属性（ECMA5中没有），ES6中添加了这个属性
在代码中不要出现这个属性，这个属性一般用来调试的.
在之前，该属性是某些浏览器厂商提供（部分浏览器支持）
</code></pre><h3 id="十七-has-Own-Property方法"><a href="#十七-has-Own-Property方法" class="headerlink" title="十七:has Own Property方法"></a>十七:has Own Property方法</h3><pre><code>has Own Property 我自己是否有这个属性(只检查自己的成员)

in 关键字
01 遍历对象
02 判断对象中是否存在指定的属性（实例成员 + 原型成员）

补充：
需求：检查是否存在某个属性，该属性只存在于原型对象中
    001 不是实例对象上面的属性
    002 有这个属性
&lt;script&gt;
function Person(name) {
    this.name = name;
}

Person.prototype.des = &quot;maioshu&quot;;
Person.prototype.name = &quot;maioshu&quot;;

var p1 = new Person(&quot;李四&quot;);
//in 关键字
console.log(&quot;name&quot; in p1);  //true
console.log(&quot;des&quot; in p1);   //true

console.log(p1.hasOwnProperty(&quot;name&quot;)); //true
console.log(p1.hasOwnProperty(&quot;des&quot;)); //false

function onlyPrototypeProp(obj,name) {
    return !obj.hasOwnProperty(name) &amp;&amp; name in obj;
}

console.log(onlyPrototypeProp(p1, &quot;name&quot;));  //false
console.log(onlyPrototypeProp(p1, &quot;des&quot;));  //true
&lt;/script&gt;
</code></pre><h4 id="十八-isPrototypeOf方法"><a href="#十八-isPrototypeOf方法" class="headerlink" title="十八:isPrototypeOf方法"></a>十八:isPrototypeOf方法</h4><pre><code>isPrototypeOf 是否是某个对象的原型对象
Object.getPrototypeOf(对象)
&lt;script&gt;
function Dog() {
}
var demo = {
    name:&quot;测试的名称&quot;
};

Dog.prototype = demo;  //替换原型对象
Dog.prototype.constructor = Dog;

var dog1 = new Dog;  //补充知识：如果构造函数没有传递参数，那么（）可以省略
console.log(dog1);

var abc = {};

console.log(Object.getPrototypeOf(dog1)); 
console.log(abc.isPrototypeOf(dog1));    //false


&lt;/script&gt;
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[面向对象3]]></title>
      <url>/2015/04/15/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1day1/</url>
      <content type="html"><![CDATA[<h4 id="一-JavaScript是由哪几部分组成"><a href="#一-JavaScript是由哪几部分组成" class="headerlink" title="## 一:JavaScript是由哪几部分组成: ##"></a>## 一:JavaScript是由哪几部分组成: ##</h4><p>01 BOM<br>    Browser Object Mode 浏览器对象模型</p>
<p>02 DOM<br>    Document Object Mode 文档(HTML文档)对象模型</p>
<p>03 ECMAScript<br>       规定了js的语法核心,关键字,类型,语言,结构<br><a id="more"></a></p>
<h4 id="二-js中的数据类型-基本数据类型-复杂数据类型"><a href="#二-js中的数据类型-基本数据类型-复杂数据类型" class="headerlink" title="#二:js中的数据类型:基本数据类型 | 复杂数据类型#"></a>#二:js中的数据类型:基本数据类型 | 复杂数据类型#</h4><p>01基本(简单)数据类型</p>
<pre><code>   string  字符串
number   数值(正数|小数)
boolean  布尔类型的值  true | false
null     空(对象)
undefined  没有定义
</code></pre><p>02复杂(复合)数据类型</p>
<pre><code>Object 对象类型(js中所有的复杂数据类型都是基于object)
  Array  数组类型
Date     日期类型
            x JSON  (不是数据类型--是数据结构)
Function    函数类型
RegRxp    正则表达式
Number    
Boolean
</code></pre><p>03 如何判断数据的类型</p>
<pre><code>typeof
语法: typeof 数据(变量)
结果:
typeof 字符串 string
typeof    数值        number
typeof    true|false    boolean
typeof    undefined    undefinede
typeof 复杂数据类型    object 除了函数(function)之外
</code></pre><p>注意点:</p>
<pre><code>01    typrof 本身是操作符不是函数
02 typeof 本身有返回值,这个返回值是string字符串类型的
03 null和undefined的区别        undefined是声明了变量但是从来没有赋值
变量的值永远不会为null,除非你手动的设置为null

我们设置变量的值为null,是为了我们不用变量的时候,垃圾回收机制就会回收这个变量
</code></pre><h4 id="三-赋值"><a href="#三-赋值" class="headerlink" title="三:赋值(=)"></a>三:赋值(=)</h4><pre><code>a=b;  把等号右边的变量(b)保存的内容复制一份给左边的变量
等于符号(==)
返回值:true|false
判定:比较左右两边的值是否相等,如果相等返回的就是true.反之就是false
全等符号(===)
返回值:true|false
判定:比较左右两边的值&amp;类型是否相等,如果值和类型都相等,那么结果就为true,反之就是false

&lt;script&gt;
var str1 = &quot;string1&quot;;                  //字符串类型
var str2 = &quot;string1&quot;;
var str3 = new String(&quot;string1&quot;);       //字符串对象
var str4 = String(&quot;string1&quot;);
var str5 = new Object(&quot;string1&quot;);

console.log(str1 == str2);    //true
console.log(str1 == str3);      //true
console.log(str1 == str4);      //true
console.log(str1 == str5);      //true
console.log(&quot;_________________&quot;);
console.log(str1 === str2);         //true
console.log(str1 === str3);         //false
console.log(&quot;_________________&quot;);
console.log(str1 === str4);         //true
console.log(str1 === str5);         //false

console.log(str3 == str4);          //true
console.log(str3 === str4);         //false

console.log(str3 == str5);          // false
console.log(str3 === str5);         //false 类型相同但是值（地址）不同
&lt;/script&gt;
</code></pre><h4 id="四-关系运算符"><a href="#四-关系运算符" class="headerlink" title="四:关系运算符:"></a>四:关系运算符:</h4><pre><code>大于(&gt;)
小于(&lt;)
小于等于(&lt;=)
大于等于(&gt;=)
不等于(!=)
</code></pre><h4 id="五-逻辑运算符"><a href="#五-逻辑运算符" class="headerlink" title="五:逻辑运算符"></a>五:逻辑运算符</h4><pre><code>01 逻辑非(!)
!表达式
判定:取反操作
返回值:布尔类型的值:true|false
02 逻辑与(&amp;&amp;)
表达式1 &amp;&amp; 表达式2
返回值:其中的一个表达式
判定:判定表达式1是否为真,如果为真,返回表达式2,否则返回表达式1
03 逻辑或(||)
表达式1 || 表达式2
返回值:其中的一个表达式
判定:判定表达式1是否为真,如果为真,返回表达式1,否则返回表达式2

&lt;script&gt;
console.log(1 || 0);              //1
console.log(1 || 1);              //1
console.log(1 || 2);              //1
console.log(0 || 1);              //1
console.log(0 || 0);               //0
console.log(0 || 2);                //2
console.log(2 || 1);                //2

console.log(1 &amp;&amp; 1);                //1
console.log(1 &amp;&amp; 2);                //2
console.log(1 &amp;&amp; 0);                //0
console.log(0 &amp;&amp; 1);                //0
console.log(0 &amp;&amp; 2);                //0
console.log(0 &amp;&amp; 0);                //0
console.log(2 &amp;&amp; 1);                //1
console.log(2 &amp;&amp; 0);                //0

&lt;/script&gt;
</code></pre><h4 id="六-在js中数据的存储有两种方式-值-引用"><a href="#六-在js中数据的存储有两种方式-值-引用" class="headerlink" title="六:在js中数据的存储有两种方式:值|引用"></a>六:在js中数据的存储有两种方式:值|引用</h4><pre><code>按照存储方式的不同,可以分成两种类型
01 值类型
string
number
boolean
undefined
null
值类型的变量存储的内容是具体的数据,比如说&quot;string&quot;
02 引用类型
object类型的,包括Array Function Date RegExp String Number Boolean
引用类型的对象存储的内容是引用(reference--地址),该地址指向内存中具体的数据,
具体的数据单独存储在内存中
&lt;script&gt;

var str = &quot;string1&quot;;    //值类型
var num = 10;           //值类型
var boolT = true;       //值类型

var car = {             //引用类型
    type:&quot;奔驰&quot;,
    color:&quot;黑色&quot;
}

//key - value
var person = {          //引用类型
    name:&quot;张三&quot;,
    age:18,
    car:car
}


console.log(person.name);     //张三
console.log(person.car);      //Object
(color: &quot;黑色&quot;type: &quot;奔驰&quot;__proto__: Object)
&lt;/script&gt;
</code></pre><h4 id="七-赋值（-）"><a href="#七-赋值（-）" class="headerlink" title="七:赋值（=）"></a>七:赋值（=）</h4><pre><code>a = b；  把等号右边的变量存储的内容复制一份给左边的变量

值类型的赋值:

把等号右边的变量存储的内容(具体的数据)复制一份给左边的变量
注意点:修改了其中的一个变量,对另外一个变量没有影响,他们是相互独立的.

引用类型的赋值

把等号右边的对象存储的内容(指向具体数据的地址)复制一份给左边的对象
注意点:修改了其中的某一个对象,对另外一个对象有影响,他们共享内存中的同一块数据
 &lt;script&gt;
    var str1 = &quot;string1&quot;;
var str2 = str1;        //值类型的赋值
console.log(str1 == str2);  //true
str1 = &quot;修改&quot;;
console.log(str1 == str2);  //false
console.log(str1);      //修改
console.log(str2);      //string1

var obj1 = {
    name:&quot;张三&quot;
}

var obj2 = obj1;   //引用类型的赋值
console.log(obj1 == obj2);      //true
obj1.name = &quot;李四&quot;;
console.log(obj1.name);   //李四
console.log(obj2.name);   //李四

//赋值操作之后，如果重新使用字面量的方式来设置对象，那么会切断和赋值对象之间的联系
obj1 = {
    age:20,
    name:&quot;老王&quot;
}

console.log(obj1.name);     //老王
console.log(obj2.name);     //李四

&lt;/script&gt;  
</code></pre><h4 id="八-值类型和引用类型在函数中的使用"><a href="#八-值类型和引用类型在函数中的使用" class="headerlink" title="八:值类型和引用类型在函数中的使用"></a>八:值类型和引用类型在函数中的使用</h4><pre><code>01 函数的参数:
形式参数(形参):在函数声明的时候,写在()中的变量,形参在函数内部使用,
在函数内部作为局部变量使用,形参用来占位
实际参数(实参):在函数调用的时候,写在()中的变量(对象)
02 函数的调用:
内部会把实参赋值给形参
实参可能是值类型的也可能是引用类型的
03 值类型的数据作为函数的参数
在函数内部修改了形参的值(a),对函数外部的实参不会产生影响,他们是相互独立的.
04 引用类型的数据作为函数的参数
在函数内部修改了形参的值(paremObj),对函数外部的实参会产生影响,他们共享内存中的同一块数据

&lt;script&gt;
var num = 10;
function func(a) {
    console.log(a); //10
    a = 20;
    console.log(a); //20
}
func(num);
console.log(num);   //10
//console.log(a);

var obj = {
    name:&quot;张三&quot;
}

function foo(paramObj) {
    console.log(paramObj.name);   //张三
    paramObj.name = &quot;李老汉&quot;;
    console.log(paramObj.name); //李老汉

    paramObj = {
        name:&quot;老王&quot;
    }
    console.log(paramObj.name); //老王
}
foo(obj);
console.log(obj.name);    // 李老汉
  &lt;/script&gt;
</code></pre><h4 id="九-对象的动态特性"><a href="#九-对象的动态特性" class="headerlink" title="九:对象的动态特性"></a>九:对象的动态特性</h4><pre><code>01  js中的对象具有动态特性
js支持在对象定义之后,动态的添加|删除|修改|查询
对象的成员:对象的属性和方法
对象:键值对的几何(key--value).属性和方法的集合
        属性:定义在对象内部的变量
        方法:定义在对象内部的函数
特性的说明:带来了方便(更灵活),但是在使用的时候容易出错(出现覆盖的问题)
02 对象的访问方式:
    1 点语法
    2 []语法  key必须是字符串的类型,如果不是字符串类型那么就当做一个变量来处理
03 动态的操作
添加:如果当前的属性不存在,那么就是添加
修改:如果当前访问的属性已经存在,那么在设置的时候就是修改
删除:使用关键字delete 语法:delete 对象.属性
&lt;script&gt;
var obj = {
    name:&quot;张三&quot;,
    age : 20,
    log:&quot;log&quot;
};

var o = {};

//需求：复制obj对象中的属性给o对象
for(var k in obj)
{
   o[k] = obj[k];
}
console.log(o);
&lt;/script&gt;
&lt;script&gt;
//01 创建空的对象
var obj ={};

//02 动态的添加成员（属性|方法）
obj.name = &quot;张三&quot;;
obj.age = 20;
obj.showName  = function () {
    console.log(this.name);//张三
}
console.log(obj.name);张三
obj.showName();

//03 修改成员
obj.name = &quot;李四&quot;;
obj.showName  = function () {
    console.log(this.name + &quot; 姓名&quot;);//李四  &quot;姓名&quot;
}
obj.showName();
console.log(obj);

delete obj.age;
console.log(obj.age);   //undefiend
console.log(&quot;___________________&quot;);

var test = {};
console.log(test);

//设置属性（添加属性） 属性名称：backgroundColor
test[&quot;background Color&quot;] = &quot;red&quot;;
console.log(test);

obj[&quot;showAge&quot;] = function () {
    console.log(this.age,&quot;____&quot;);
}
obj[&quot;showAge&quot;]();
&lt;/script&gt;

&lt;script&gt;
var obj = {
    name:&quot;张三&quot;,
    age:20,
    showName:function () {
        console.log(this.name);
    }
}

var name = &quot;name&quot;;
console.log(obj.name);  //张三
console.log(obj[name],&quot;+++++&quot;); // 张三
//console.log(obj[age]);   //报错.[key]必须是字符串类型的，如果不是字符串类型那么就当做一个变量来处理

console.log(window.name);  //name
console.log(obj);

&lt;/script&gt;
</code></pre><h4 id="十-in关键字"><a href="#十-in关键字" class="headerlink" title="十:in关键字"></a>十:in关键字</h4><pre><code>01 遍历(迭代) 对象 for...in
02 判断对象中是否存在指定的属性  语法:&quot;属性&quot; in 对象
返回值:布尔类型的值,如果有那么就返回true
注意点:
01 属性必须是字符串
02 在使用in操作符处理数组的时候需要注意: key是索引
数组[1,2,3,4,5,6] 的对象形式:{0:1,1:2,2:3,3:4,4:5,5:6};

&lt;script&gt;
var dog = {
    name:&quot;旺财&quot;,
    color:&quot;绿色&quot;
}

//判断|检查
console.log(&quot;name&quot; in dog);
console.log(&quot;age&quot; in dog);
console.log(&quot;&quot; in dog);           //false
&lt;/script&gt;

&lt;script&gt;
var arr = [1,2,3,4,5,6];
console.log(&quot;1&quot; in arr);    //true
console.log(&quot;1&quot; in arr);   //true

console.log(&quot;5&quot; in arr);       //true
console.log(&quot;6&quot; in arr);        //false  //判断arr中是否有6这个索引
&lt;/script&gt;
</code></pre><h3 id="十一-delete的作用"><a href="#十一-delete的作用" class="headerlink" title="十一:delete的作用"></a>十一:delete的作用</h3><pre><code>01 删除对象的属性
02 可以删除没有使用var声明的变量
delete关键字的使用注意
01 有返回值 布尔类型的值（true|false） 删除成功那么就是true
02 删除对象中不存在的属性，返回值是true还是false  (true)
03 删除对象的原型对象中的属性，能否删除成功(不能删除)，返回值[delete obj.hi == 删除对象中不存在的属性]
04 delete关键字无法删除使用var声明的全局的变量，但是却可以删除直接定义在window上面的属性

&lt;script&gt;
Object.prototype.hi = &quot;hi&quot;;

var obj = {name:&quot;巴拉巴拉小魔仙&quot;};
console.log(delete obj.name);

var demo = &quot;demoTest&quot;;
console.log(delete demo);

console.log(delete obj.age);
console.log(obj.hi);

//    console.log(delete Object.prototype.hi);  //true
console.log(delete obj.hi);  //true
alert(obj.hi);
console.log(obj.hi);

console.log(window.demo);   //全局变量和函数默认会成为window对象的属性和方法

window.showInfo = &quot;不可描述的信息&quot;;
console.log(showInfo);
delete window.showInfo;
console.log(showInfo);   //报错

&lt;script&gt;
var dog = {
    name:&quot;招财&quot;,
    age:14
}

console.log(dog.name);
//删除对象的属性
delete dog.name;
console.log(dog.name);

//没有使用var关键字声明的变量,那么该变量默认会成为一个全局的变量(变成window的属性)
var a = &quot;testa&quot;;
b = &quot;testb&quot;;
console.log(a);
console.log(b);

function func() {
    var num1 = 10;
    num2 = 20;
}

func();
//console.log(num1);  //
console.log(num2);

//使用delete删除属性
console.log(num2,&quot;____&quot;);
delete num2;
//console.log(num2);

console.log(a);
delete a;
console.log(a);

&lt;/script&gt;


&lt;/script&gt;
</code></pre><h3 id="十二-循环和分支"><a href="#十二-循环和分支" class="headerlink" title="十二:循环和分支"></a>十二:循环和分支</h3><pre><code>01 顺序的执行结构
02 循环结构
for循环
while
do...while   至少会执行一次循环体
for..in
&lt;!--&lt;script&gt;--&gt;
&lt;!--while (条件)--&gt;
&lt;!--{--&gt;
    &lt;!--//执行的代码--&gt;
&lt;!--}--&gt;

&lt;!--do{--&gt;
    &lt;!--//执行的代码--&gt;
&lt;!--}while(条件)--&gt;
&lt;!----&gt;
&lt;!--&lt;/script&gt;--&gt;

03 分支结构
if...else..
switch...case

&lt;script&gt;
switch (12)
{
    case 1:
        console.log(1);
        break;
    case 2:
        console.log(2);
        break;
    default:
        console.log(&quot;其他的数据&quot;);
}
&lt;/script&gt;

04 break continue
break :退出循环，执行该循环后面的代码
continue：退出循环(结束当前的循环)，继续执行下一次的循环

&lt;script&gt;
for (var i = 0; i &lt;10; i++) {
    if (i == 5)
    {
        //break;
        continue;
    }

    console.log(&quot;i = &quot; + i);

}

&lt;/script&gt;
</code></pre><h3 id="十三-调试工具的使用-断点"><a href="#十三-调试工具的使用-断点" class="headerlink" title="十三:调试工具的使用(断点)"></a>十三:调试工具的使用(断点)</h3><pre><code>调试工具
01 打开控制台
windows : F12 MAC OSX  option + command + j

02 控制台的详细介绍
03 断点（普通断点 + 条件断点）
04 网络通信的模型
客户端（浏览器|app） --- 服务器端(电脑)
客户端需要数据      ______请求__________&gt;服务器端  （01 请求）
客户端              _____数据__________服务器端     (02 响应)
请求：请求头（对客户端以及请求本身的描述信息） + 请求体（具体的参数）  GET
响应：响应头（对服务器端以及响应本身的描述信息） + 响应体（具体的数据）

GMT 格林尼治时间
北京时间  +     08

&lt;div id=&quot;demo&quot;&gt;测试的div&lt;/div&gt;
&lt;script&gt;
var a = &quot;testA&quot;;

var b = &quot;testB&quot;;
function func01() {
    console.log(a);
    console.log(b);
    var c = &quot;testC&quot;;
    console.log(c);
}

function func02() {
    console.log(&quot;func02&quot;);
}
console.log(b);
func01();
func02();

//console.log(c);

a = &quot;testAAAAASA&quot;;
console.log(a);

for (var i = 0; i &lt; 10000; i++) {
   console.log(i);

}

&lt;/script&gt;
</code></pre><h3 id="十四-异常处理"><a href="#十四-异常处理" class="headerlink" title="十四:异常处理"></a>十四:异常处理</h3><pre><code>异常处理(try...catch)
如果我们的代码发生了异常，那么该行代码后面的代码将无法得到执行
但是有的时候，我们需要保证在任何情况下某些代码都能够正常得到执行，这个时候就可以使用异常捕获结构
异常捕获结构（try...catch）
01 把可能出错的代码放在try{}代码块中

手动的抛出异常 throw关键字
异常信息：字符串 | 对象（）

完整的异常捕获结构
try{}catch(e){}finally{}
&lt;script&gt;
try
{
    //01 存放的是可能出错的代码
    //console.log(c);
}
catch(e)
{
    //02 出错之后会执行这部分代码
    console.log(e);
}
finally
{
    //03 不管是否出错都会执行的代码
    console.log(&quot;无论如何都会执行的代码&quot;);

    //有什么用？ 前端中一般不会使用
    //Node.js 服务器端  最后的扫尾和资源释放的工作
}
&lt;/script&gt;
&lt;script&gt;
try
{
    //可能出错的代码
    var a = &quot;testA&quot;;
    console.log(a);
    //console.log(c);

    //throw &quot;这里出现了隐秘的错误，请检查！&quot;;
    throw {
        errorMsg:&quot;错误信息&quot;,
        errorCode:&quot;100201&quot;
    }
}
catch (e)
{
    //出现了异常之后，会执行这个代码块中的任务（应对异常的解决方法）
    console.log(e);
}

function func() {
  console.log(&quot;func&quot;);
}

func();
&lt;/script&gt;
</code></pre><h3 id="十五-DOM操作"><a href="#十五-DOM操作" class="headerlink" title="十五: DOM操作"></a>十五: DOM操作</h3><pre><code>DOM:文档对象模型 核心对象：document
增加|删除|修改|查询
查询：getElementById|className |tagName
删除：remove...
修改: 得到标签之后直接设置
增加:createEle...

需求：创建一个div标签，设置标签的内容为：我让掉下眼泪的，不止昨夜的酒，设置样式
样式：
    高度：100px
    宽度：300px
    背景颜色:red
    边框： 1px solid #432
把标签添加到当前的页面中
&lt;script&gt;
//01 创建标签
var div = document.createElement(&quot;div&quot;);
//02 设置内容和样式
div.innerText = &quot;我让掉下眼泪的，不止昨夜的酒&quot;;
div.style.height = &quot;100px&quot;;
div.style.width = &quot;300px&quot;;
div.style.backgroundColor = &quot;red&quot;;
div.style.border = &quot;1px solid #555&quot;;
//03 添加到body
document.body.appendChild(div);
//04 删除标签
document.body.removeChild(div);

&lt;/script&gt;
</code></pre><h3 id="十六-函数和对象的创建"><a href="#十六-函数和对象的创建" class="headerlink" title="十六:函数和对象的创建"></a>十六:函数和对象的创建</h3><pre><code>函数的创建
01 函数声明 function 函数名（参数1，参数2）{函数体}
02 函数表达式 var func =  function [函数名]（参数1，参数2）{函数体}
03 使用构造函数创建（Function）

对象的创建
01 字面量的方式
02 构造函数（Object） + new
&lt;script&gt;
//01 函数声明
function func(a,b) {
    console.log(a + b);
}
func(1,2);

//02 函数表达式
var foo = function () {
    console.log(&quot;foo&quot;);
}

foo();

//03 构造函数创建
var funcName = new Function(&quot;console.log(123)&quot;);
funcName();

&lt;/script&gt;
&lt;script&gt;
var obj = {
    name:&quot;张三&quot;
}

var obj2 = new Object();  //{}
obj2.name = &quot;李四&quot;;
console.log(obj2);


&lt;/script&gt;
</code></pre><h3 id="十七-面向过程和面向对象的概念"><a href="#十七-面向过程和面向对象的概念" class="headerlink" title="十七:面向过程和面向对象的概念"></a>十七:面向过程和面向对象的概念</h3><pre><code>面向过程
关注的是解决问题需要的一个接着一个的过程

面向对象
关注的是解决问题需要的对象

面向对象编程主要重点是对象：内置对象（数组对象|日期对象|函数对象） 自定义

面向对象和面向过程都是一种解决编程问题的思想（方法）

例子：
    面向过程的洗衣服方式：
     01 收集脏衣服
     02 找个盆（桶）
     03 接水
     04 放洗衣液（洗衣粉）
     05 搅匀
     06 先泡几分钟（15）
     07 摩擦摩擦
     08 再清水冲洗一遍
     09 把衣服拧干
     10 晾衣服

    面向对象洗衣服
        01 收集脏衣服
        02 找个合适的洗衣机|男朋友|女朋友
        03 设置洗衣服和烘干的程序

面向对象和面向过程关系 其实是对面向过程的一种封装（？） 减少冗余的代码 + 复用性更好
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JS满天星特效]]></title>
      <url>/2015/04/15/JS%E6%BB%A1%E5%A4%A9%E6%98%9F/</url>
      <content type="html"><![CDATA[<p>这个特效代码很简单,但是效果却出奇的漂亮,用到了css3的属性,虽然有兼容性问题,不过确实又简单效果也很好主要原理有几步<br>①动态创建节点<br>②设置几个随机值,比如星星的大小,星星的位置,星星做动画的延迟时长<br>③在对应的style样式进行设置<br>代码如下<br><a id="more"></a><br><img src="http://i.imgur.com/YoxekGo.png" alt=""><br><img src="http://i.imgur.com/5hwt9OK.png" alt=""><br><img src="http://i.imgur.com/87laKOv.png" alt=""></p>
]]></content>
      
        
        <tags>
            
            <tag> JS特效 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[前端软件整理]]></title>
      <url>/2015/02/15/%E5%89%8D%E7%AB%AF%E8%BD%AF%E4%BB%B6%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<p>###前端学习要用的软件<br>写代码软件:<br>一sublime ,二webstorm/phpstorm, 三notepad++, 四visual studio code,   五eclipse</p>
<a id="more"></a>
<p>写笔记软件:一有道云笔记, 二markdown, 三简书, 四gitbook</p>
<p>切片软件:Fireworks-CS6   </p>
<p>美工软件:PS</p>
<p>翻墙软件:蓝灯</p>
<p>思维导图软件:Xmind</p>
<p>pdf阅读器:福昕PDF阅读器</p>
<p>局域网传输软件:飞秋    飞鸽传书</p>
<p>局域网控屏软件:红蜘蛛</p>
<p>GIF截图软件:LICEcap</p>
<p>前端预处理器语言图形编译工具:koala</p>
<p>Windows Apache Mysql PHP集成安装环境:WampServer</p>
<p>网页调试与发送网页HTTP请求的Chrome插件:postman</p>
<p>基于 Shell 的跨平台开源 MongoDB 管理工具: Robomongo</p>
<p>MAC上:</p>
<p>万能解压包:Dr.Unarchiver.app</p>
<p>操作系统Mac OS X上的集成开发工具（IDE）:Xcode.app</p>
<p>Android集成开发工具:Android studio.app</p>
<p>Android虚拟环境,安卓模拟器:Genymotion.app</p>
<p>截图软件:snip.app</p>
<p>虚拟机:orscle vm virtualbox</p>
<p>前端学习网站:醉牛前端,w3school,知乎,博客园,CSDN,GITHUB</p>
]]></content>
      
        
        <tags>
            
            <tag> 前端工具 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
