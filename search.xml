<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[jQuery选择器]]></title>
      <url>/2017/04/22/jQuery%E7%9A%84%E9%80%89%E6%8B%A9%E5%99%A8/</url>
      <content type="html"><![CDATA[<h1 id="jQuery选择器"><a href="#jQuery选择器" class="headerlink" title="jQuery选择器"></a>jQuery选择器</h1><p>jQuery 最核心的组成部分就是:选择器引擎。<br>   它完全继承了 CSS 的风格,可以对 DOM 元 素的标签名、属性名、状态等进行快速准确的选择,并且不必担心浏览器的兼容性,写法更加简洁。<br>jQuery 选择器实现了 CSS1~CSS3 的大部分规则之外,还实现了一些自定义的选择器,用于各种特殊状态的选择。 </p>
<a id="more"></a>
<h2 id="选择器的分类"><a href="#选择器的分类" class="headerlink" title="选择器的分类:"></a>选择器的分类:</h2><p>  <strong>1.基本选择器</strong></p>
<p>  <strong>2.层级选择器</strong></p>
<p>  <strong>3.属性选择器</strong></p>
<p>  <strong>4.筛选选择器</strong></p>
<p>  <strong>5.表单选择器</strong><br><!-- more --><br>  1.基本选择器<br><img src="http://i.imgur.com/R6VNNw5.png" alt=""></p>
<p>  2.层级选择器<br><img src="http://i.imgur.com/x6i944Z.png" alt=""></p>
<p>  .next .nextAll等价和等级关系<br> <img src="http://i.imgur.com/iE3X4oX.png" alt=""><br> <img src="http://i.imgur.com/dVXlV3c.png" alt=""></p>
<p>  3.属性选择器<br><img src="http://i.imgur.com/e3JWrlv.png" alt=""></p>
<p>  4.筛选选择器<br><img src="http://i.imgur.com/tTqQCNF.png" alt=""></p>
<p>  5.父子兄弟选择</p>
<p>.parent();获取匹配元素的父元素;<br>.parents();获取匹配元素的祖先元素;<br>.children();获取匹配元素的子元素;<br>.siblings();获取匹配元素的兄弟元素;</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[JQUERY的网页应用]]></title>
      <url>/2017/04/21/jQuery%E7%BD%91%E9%A1%B5%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>##JQUERY的网页应用</p>
<p> /<em>一.设置吸顶效果</em>/</p>
<p> /<em>1.0获取NAV距离顶部的间距</em>/</p>
<p>/<em>1.1监听滚动，设置对应的样式</em>/</p>
<p>/<em>1.2获取滚动的距离</em>/</p>
<p>/<em>1.3判断比较设置样式</em>/</p>
<p>/<em>1.31设置图片的透明度，让图片出来</em>/<br><a id="more"></a></p>
<p>  /<em>二.设置返回顶部</em>/</p>
<p> //2.1判断</p>
<p>/<em>2.2点击BACK_TOP返回顶部</em>/</p>
<p> //2.21让回到顶部</p>
<p> /<em>三.添加LI</em>/<br>/<em>3.0使用数组来记录事项</em>/</p>
<p> /<em>当界面加载进来的时候，就去从从存储的数据中拿出对应的数据，如果没有才去加载</em>/</p>
<p> /<em>渲染界面</em>/</p>
<p>/<em>3.0去掉默认行为</em>/</p>
<p>/<em>3.1获取INPUT中内容，判断</em>/</p>
<p>  /<em>3.2创建事项</em>/</p>
<p>/<em>3.2设置事项的相关属性</em>/</p>
<p>/<em>3.3添加到数组中中保存起来</em>/</p>
<p> /<em>3.4根据数组的长度，添加节点而且吧节点显示出来</em>/</p>
<p> /<em>3.5存储数据</em>/</p>
<p> /*0.存储数据，第一个参数用来表示存储的数据的标示，任何值都可以，只是用这个值来取出数据</p>
<pre><code>* 第二个参数表示要存储的数据*/
</code></pre><p>/<em>把上一次的内容清空</em>/</p>
<p>/<em>注意：为了让对应的CHECKBOX点击的时候，让对应的不同的事项中添加不同的LI</em>/</p>
<p>/<em> 所以我们需要改造渲染方法</em>/</p>
<p>  /<em>3.41根据数组中的个数。来添加节点</em>/</p>
<p>//为了规范和严格要进行元素的判定</p>
<p> /<em>3.42创建LI</em>/</p>
<p>  // DATA-INDEX:用来给LI绑定索引</p>
<p>  /<em>3.43添加LI</em>/</p>
<p>   /<em>根据是否检查过，来确定添加到待选事件还是完成事件</em>/</p>
<p>/<em>四.切换TAB</em>/</p>
<p>   /<em>4.1点击LI切换TAB</em>/</p>
<p>   /<em>4.2获取点击的索引值</em>/</p>
<p>   /<em>4.3切换下面的DIV</em>/<br>/<em>五，点击删除按钮删除对应的LI</em>/</p>
<p>/<em>5.1获取DEL所在的LI</em>/</p>
<p>/<em>5.2获取LI对应的索引值</em>/</p>
<p>/<em>5.3为了代码严格，我们可以回索引进行判断</em>/</p>
<p> /<em>5.4删除数组中的元素</em>/</p>
<p>/<em>5.5删除节点</em>/</p>
<p>/<em>5.6存储数据</em>/</p>
<p>/<em>六.点击待办事项，让对应的事项有待办变为已经完成</em>/</p>
<p>/<em>6.1确定点击的索引</em>/</p>
<p>/<em>6.2拿出INDEX中对应的数组中的元素</em>/</p>
<p>/<em>6.3设置ISCHECK为选中</em>/</p>
<p>/<em>用OBJ替换原来位置的元素</em>/</p>
<p> /<em>6.4进行界面设置</em>/</p>
<p> /<em>6.5存储数据</em>/</p>
<p> /<em>七.点击详情按钮的处理</em>/</p>
<p> /<em>设置一个值用来表示当前点击的是哪一个</em>/</p>
<p> /<em>7.1设置让对应MASK出来</em>/</p>
<p> /<em>7.2获取点击详情按钮的索引</em>/</p>
<p>/<em>7.21设置CURR_INDEX的值</em>/</p>
<p>/<em>7.3根据索引值获取数组中对应的元素</em>/</p>
<p> /<em>7.4根据对应的事项设置我们具体的内容</em>/</p>
<p>/<em>7.41设置标题</em>/</p>
<p>/<em>7.42设置内容</em>/</p>
<p>/<em>7.43设置提醒时间</em>/</p>
<p> /<em>八.处理事件的相关点击</em>/</p>
<p>  /<em>8.1点击内容阻止冒泡</em>/</p>
<p>/<em>8.11阻止冒泡</em>/</p>
<p>  /<em>8.2设置当光标移动到INPUT中设置时间的时候，让对应的时间的选择器展示出来</em>/</p>
<p>  /<em>8.21设置本地化时间(设置中国时间)</em>/</p>
<p>   /<em>8.22给对应的标签设置对应时间选择器</em>/</p>
<p>/<em>九.更新数据和界面</em>/</p>
<p>  /<em>9.1获取点击详细按钮对应的索引值</em>/</p>
<p>   /<em>9.2根据索引值获取对应数组中的元素</em>/</p>
<p>/<em>9.3设置元素的数据</em>/</p>
<p> /<em>IS_NOTICE：表示有没有提醒去做对应事项</em>/</p>
<p>/<em>9.4赋值回原来的位置</em>/</p>
<p> /<em>9.5存储数据</em>/</p>
<p>/<em>9.6更新界面</em>/</p>
<p>/<em>9.7让当前的MASK消失</em>/</p>
<p> /<em>十.提醒设置</em>/</p>
<p>/<em>10.1我们需要时时刻刻比较当前的时间和设置的时间，所以要使用定时器</em>/</p>
<p> /<em>10.2获取每一元素的的提醒时间，和当前时间比较，需要使用遍历</em>/</p>
<p>/<em>10.3判断当前的时间是否大于提醒时间</em>/</p>
<p>  /<em>10.31获取每一提醒时间的毫秒数</em>/</p>
<p>  //需要提醒，让对应铃声响起</p>
<p>   /<em>获取的对象是JQUERY对象我们需要转化成JS对象</em>/</p>
<p>/<em>10.4当铃声响起后，表示已经提醒过了，我们要设置提醒为<br>TRUE</em>/</p>
<p> /<em>10.5重新赋值</em>/</p>
<p> /<em>10.6数据变化，就要存储数据</em>/# #</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[常用方法]]></title>
      <url>/2017/04/20/%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%8D%E6%87%82%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。</p>
<p>empty() 方法从被选元素移除所有内容，包括所有文本和子节点。</p>
<p>trim() 函数返回去掉开头和结尾空格后的字符串</p>
<p>prepend() 方法在被选元素的开头（仍位于内部）插入指定内容</p>
<p>data() 方法向被选元素附加数据，或者从被选元素获取数据。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[面向对象1]]></title>
      <url>/2017/04/18/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1day1/</url>
      <content type="html"><![CDATA[<h4 id="一-JavaScript是由哪几部分组成"><a href="#一-JavaScript是由哪几部分组成" class="headerlink" title="## 一:JavaScript是由哪几部分组成: ##"></a>## 一:JavaScript是由哪几部分组成: ##</h4><p>01 BOM<br>    Browser Object Mode 浏览器对象模型</p>
<p>02 DOM<br>    Document Object Mode 文档(HTML文档)对象模型</p>
<p>03 ECMAScript<br>       规定了js的语法核心,关键字,类型,语言,结构<br><a id="more"></a></p>
<h4 id="二-js中的数据类型-基本数据类型-复杂数据类型"><a href="#二-js中的数据类型-基本数据类型-复杂数据类型" class="headerlink" title="#二:js中的数据类型:基本数据类型 | 复杂数据类型#"></a>#二:js中的数据类型:基本数据类型 | 复杂数据类型#</h4><p>01基本(简单)数据类型</p>
<pre><code>   string  字符串
number   数值(正数|小数)
boolean  布尔类型的值  true | false
null     空(对象)
undefined  没有定义
</code></pre><p>02复杂(复合)数据类型</p>
<pre><code>Object 对象类型(js中所有的复杂数据类型都是基于object)
  Array  数组类型
Date     日期类型
            x JSON  (不是数据类型--是数据结构)
Function    函数类型
RegRxp    正则表达式
Number    
Boolean
</code></pre><p>03 如何判断数据的类型</p>
<pre><code>typeof
语法: typeof 数据(变量)
结果:
typeof 字符串 string
typeof    数值        number
typeof    true|false    boolean
typeof    undefined    undefinede
typeof 复杂数据类型    object 除了函数(function)之外
</code></pre><p>注意点:</p>
<pre><code>01    typrof 本身是操作符不是函数
02 typeof 本身有返回值,这个返回值是string字符串类型的
03 null和undefined的区别        undefined是声明了变量但是从来没有赋值
变量的值永远不会为null,除非你手动的设置为null

我们设置变量的值为null,是为了我们不用变量的时候,垃圾回收机制就会回收这个变量
</code></pre><h4 id="三-赋值"><a href="#三-赋值" class="headerlink" title="三:赋值(=)"></a>三:赋值(=)</h4><pre><code>a=b;  把等号右边的变量(b)保存的内容复制一份给左边的变量
等于符号(==)
返回值:true|false
判定:比较左右两边的值是否相等,如果相等返回的就是true.反之就是false
全等符号(===)
返回值:true|false
判定:比较左右两边的值&amp;类型是否相等,如果值和类型都相等,那么结果就为true,反之就是false

&lt;script&gt;
var str1 = &quot;string1&quot;;                  //字符串类型
var str2 = &quot;string1&quot;;
var str3 = new String(&quot;string1&quot;);       //字符串对象
var str4 = String(&quot;string1&quot;);
var str5 = new Object(&quot;string1&quot;);

console.log(str1 == str2);    //true
console.log(str1 == str3);      //true
console.log(str1 == str4);      //true
console.log(str1 == str5);      //true
console.log(&quot;_________________&quot;);
console.log(str1 === str2);         //true
console.log(str1 === str3);         //false
console.log(&quot;_________________&quot;);
console.log(str1 === str4);         //true
console.log(str1 === str5);         //false

console.log(str3 == str4);          //true
console.log(str3 === str4);         //false

console.log(str3 == str5);          // false
console.log(str3 === str5);         //false 类型相同但是值（地址）不同
&lt;/script&gt;
</code></pre><h4 id="四-关系运算符"><a href="#四-关系运算符" class="headerlink" title="四:关系运算符:"></a>四:关系运算符:</h4><pre><code>大于(&gt;)
小于(&lt;)
小于等于(&lt;=)
大于等于(&gt;=)
不等于(!=)
</code></pre><h4 id="五-逻辑运算符"><a href="#五-逻辑运算符" class="headerlink" title="五:逻辑运算符"></a>五:逻辑运算符</h4><pre><code>01 逻辑非(!)
!表达式
判定:取反操作
返回值:布尔类型的值:true|false
02 逻辑与(&amp;&amp;)
表达式1 &amp;&amp; 表达式2
返回值:其中的一个表达式
判定:判定表达式1是否为真,如果为真,返回表达式2,否则返回表达式1
03 逻辑或(||)
表达式1 || 表达式2
返回值:其中的一个表达式
判定:判定表达式1是否为真,如果为真,返回表达式1,否则返回表达式2

&lt;script&gt;
console.log(1 || 0);              //1
console.log(1 || 1);              //1
console.log(1 || 2);              //1
console.log(0 || 1);              //1
console.log(0 || 0);               //0
console.log(0 || 2);                //2
console.log(2 || 1);                //2

console.log(1 &amp;&amp; 1);                //1
console.log(1 &amp;&amp; 2);                //2
console.log(1 &amp;&amp; 0);                //0
console.log(0 &amp;&amp; 1);                //0
console.log(0 &amp;&amp; 2);                //0
console.log(0 &amp;&amp; 0);                //0
console.log(2 &amp;&amp; 1);                //1
console.log(2 &amp;&amp; 0);                //0

&lt;/script&gt;
</code></pre><h4 id="六-在js中数据的存储有两种方式-值-引用"><a href="#六-在js中数据的存储有两种方式-值-引用" class="headerlink" title="六:在js中数据的存储有两种方式:值|引用"></a>六:在js中数据的存储有两种方式:值|引用</h4><pre><code>按照存储方式的不同,可以分成两种类型
01 值类型
string
number
boolean
undefined
null
值类型的变量存储的内容是具体的数据,比如说&quot;string&quot;
02 引用类型
object类型的,包括Array Function Date RegExp String Number Boolean
引用类型的对象存储的内容是引用(reference--地址),该地址指向内存中具体的数据,
具体的数据单独存储在内存中
&lt;script&gt;

var str = &quot;string1&quot;;    //值类型
var num = 10;           //值类型
var boolT = true;       //值类型

var car = {             //引用类型
    type:&quot;奔驰&quot;,
    color:&quot;黑色&quot;
}

//key - value
var person = {          //引用类型
    name:&quot;张三&quot;,
    age:18,
    car:car
}


console.log(person.name);     //张三
console.log(person.car);      //Object
(color: &quot;黑色&quot;type: &quot;奔驰&quot;__proto__: Object)
&lt;/script&gt;
</code></pre><h4 id="七-赋值（-）"><a href="#七-赋值（-）" class="headerlink" title="七:赋值（=）"></a>七:赋值（=）</h4><pre><code>a = b；  把等号右边的变量存储的内容复制一份给左边的变量

值类型的赋值:

把等号右边的变量存储的内容(具体的数据)复制一份给左边的变量
注意点:修改了其中的一个变量,对另外一个变量没有影响,他们是相互独立的.

引用类型的赋值

把等号右边的对象存储的内容(指向具体数据的地址)复制一份给左边的对象
注意点:修改了其中的某一个对象,对另外一个对象有影响,他们共享内存中的同一块数据
 &lt;script&gt;
    var str1 = &quot;string1&quot;;
var str2 = str1;        //值类型的赋值
console.log(str1 == str2);  //true
str1 = &quot;修改&quot;;
console.log(str1 == str2);  //false
console.log(str1);      //修改
console.log(str2);      //string1

var obj1 = {
    name:&quot;张三&quot;
}

var obj2 = obj1;   //引用类型的赋值
console.log(obj1 == obj2);      //true
obj1.name = &quot;李四&quot;;
console.log(obj1.name);   //李四
console.log(obj2.name);   //李四

//赋值操作之后，如果重新使用字面量的方式来设置对象，那么会切断和赋值对象之间的联系
obj1 = {
    age:20,
    name:&quot;老王&quot;
}

console.log(obj1.name);     //老王
console.log(obj2.name);     //李四

&lt;/script&gt;  
</code></pre><h4 id="八-值类型和引用类型在函数中的使用"><a href="#八-值类型和引用类型在函数中的使用" class="headerlink" title="八:值类型和引用类型在函数中的使用"></a>八:值类型和引用类型在函数中的使用</h4><pre><code>01 函数的参数:
形式参数(形参):在函数声明的时候,写在()中的变量,形参在函数内部使用,
在函数内部作为局部变量使用,形参用来占位
实际参数(实参):在函数调用的时候,写在()中的变量(对象)
02 函数的调用:
内部会把实参赋值给形参
实参可能是值类型的也可能是引用类型的
03 值类型的数据作为函数的参数
在函数内部修改了形参的值(a),对函数外部的实参不会产生影响,他们是相互独立的.
04 引用类型的数据作为函数的参数
在函数内部修改了形参的值(paremObj),对函数外部的实参会产生影响,他们共享内存中的同一块数据

&lt;script&gt;
var num = 10;
function func(a) {
    console.log(a); //10
    a = 20;
    console.log(a); //20
}
func(num);
console.log(num);   //10
//console.log(a);

var obj = {
    name:&quot;张三&quot;
}

function foo(paramObj) {
    console.log(paramObj.name);   //张三
    paramObj.name = &quot;李老汉&quot;;
    console.log(paramObj.name); //李老汉

    paramObj = {
        name:&quot;老王&quot;
    }
    console.log(paramObj.name); //老王
}
foo(obj);
console.log(obj.name);    // 李老汉
  &lt;/script&gt;
</code></pre><h4 id="九-对象的动态特性"><a href="#九-对象的动态特性" class="headerlink" title="九:对象的动态特性"></a>九:对象的动态特性</h4><pre><code>01  js中的对象具有动态特性
js支持在对象定义之后,动态的添加|删除|修改|查询
对象的成员:对象的属性和方法
对象:键值对的几何(key--value).属性和方法的集合
        属性:定义在对象内部的变量
        方法:定义在对象内部的函数
特性的说明:带来了方便(更灵活),但是在使用的时候容易出错(出现覆盖的问题)
02 对象的访问方式:
    1 点语法
    2 []语法  key必须是字符串的类型,如果不是字符串类型那么就当做一个变量来处理
03 动态的操作
添加:如果当前的属性不存在,那么就是添加
修改:如果当前访问的属性已经存在,那么在设置的时候就是修改
删除:使用关键字delete 语法:delete 对象.属性
&lt;script&gt;
var obj = {
    name:&quot;张三&quot;,
    age : 20,
    log:&quot;log&quot;
};

var o = {};

//需求：复制obj对象中的属性给o对象
for(var k in obj)
{
   o[k] = obj[k];
}
console.log(o);
&lt;/script&gt;
&lt;script&gt;
//01 创建空的对象
var obj ={};

//02 动态的添加成员（属性|方法）
obj.name = &quot;张三&quot;;
obj.age = 20;
obj.showName  = function () {
    console.log(this.name);//张三
}
console.log(obj.name);张三
obj.showName();

//03 修改成员
obj.name = &quot;李四&quot;;
obj.showName  = function () {
    console.log(this.name + &quot; 姓名&quot;);//李四  &quot;姓名&quot;
}
obj.showName();
console.log(obj);

delete obj.age;
console.log(obj.age);   //undefiend
console.log(&quot;___________________&quot;);

var test = {};
console.log(test);

//设置属性（添加属性） 属性名称：backgroundColor
test[&quot;background Color&quot;] = &quot;red&quot;;
console.log(test);

obj[&quot;showAge&quot;] = function () {
    console.log(this.age,&quot;____&quot;);
}
obj[&quot;showAge&quot;]();
&lt;/script&gt;

&lt;script&gt;
var obj = {
    name:&quot;张三&quot;,
    age:20,
    showName:function () {
        console.log(this.name);
    }
}

var name = &quot;name&quot;;
console.log(obj.name);  //张三
console.log(obj[name],&quot;+++++&quot;); // 张三
//console.log(obj[age]);   //报错.[key]必须是字符串类型的，如果不是字符串类型那么就当做一个变量来处理

console.log(window.name);  //name
console.log(obj);

&lt;/script&gt;
</code></pre><h4 id="十-in关键字"><a href="#十-in关键字" class="headerlink" title="十:in关键字"></a>十:in关键字</h4><pre><code>01 遍历(迭代) 对象 for...in
02 判断对象中是否存在指定的属性  语法:&quot;属性&quot; in 对象
返回值:布尔类型的值,如果有那么就返回true
注意点:
01 属性必须是字符串
02 在使用in操作符处理数组的时候需要注意: key是索引
数组[1,2,3,4,5,6] 的对象形式:{0:1,1:2,2:3,3:4,4:5,5:6};

&lt;script&gt;
var dog = {
    name:&quot;旺财&quot;,
    color:&quot;绿色&quot;
}

//判断|检查
console.log(&quot;name&quot; in dog);
console.log(&quot;age&quot; in dog);
console.log(&quot;&quot; in dog);           //false
&lt;/script&gt;

&lt;script&gt;
var arr = [1,2,3,4,5,6];
console.log(&quot;1&quot; in arr);    //true
console.log(&quot;1&quot; in arr);   //true

console.log(&quot;5&quot; in arr);       //true
console.log(&quot;6&quot; in arr);        //false  //判断arr中是否有6这个索引
&lt;/script&gt;
</code></pre><h3 id="十一-delete的作用"><a href="#十一-delete的作用" class="headerlink" title="十一:delete的作用"></a>十一:delete的作用</h3><pre><code>01 删除对象的属性
02 可以删除没有使用var声明的变量
delete关键字的使用注意
01 有返回值 布尔类型的值（true|false） 删除成功那么就是true
02 删除对象中不存在的属性，返回值是true还是false  (true)
03 删除对象的原型对象中的属性，能否删除成功(不能删除)，返回值[delete obj.hi == 删除对象中不存在的属性]
04 delete关键字无法删除使用var声明的全局的变量，但是却可以删除直接定义在window上面的属性

&lt;script&gt;
Object.prototype.hi = &quot;hi&quot;;

var obj = {name:&quot;巴拉巴拉小魔仙&quot;};
console.log(delete obj.name);

var demo = &quot;demoTest&quot;;
console.log(delete demo);

console.log(delete obj.age);
console.log(obj.hi);

//    console.log(delete Object.prototype.hi);  //true
console.log(delete obj.hi);  //true
alert(obj.hi);
console.log(obj.hi);

console.log(window.demo);   //全局变量和函数默认会成为window对象的属性和方法

window.showInfo = &quot;不可描述的信息&quot;;
console.log(showInfo);
delete window.showInfo;
console.log(showInfo);   //报错

&lt;script&gt;
var dog = {
    name:&quot;招财&quot;,
    age:14
}

console.log(dog.name);
//删除对象的属性
delete dog.name;
console.log(dog.name);

//没有使用var关键字声明的变量,那么该变量默认会成为一个全局的变量(变成window的属性)
var a = &quot;testa&quot;;
b = &quot;testb&quot;;
console.log(a);
console.log(b);

function func() {
    var num1 = 10;
    num2 = 20;
}

func();
//console.log(num1);  //
console.log(num2);

//使用delete删除属性
console.log(num2,&quot;____&quot;);
delete num2;
//console.log(num2);

console.log(a);
delete a;
console.log(a);

&lt;/script&gt;


&lt;/script&gt;
</code></pre><h3 id="十二-循环和分支"><a href="#十二-循环和分支" class="headerlink" title="十二:循环和分支"></a>十二:循环和分支</h3><pre><code>01 顺序的执行结构
02 循环结构
for循环
while
do...while   至少会执行一次循环体
for..in
&lt;!--&lt;script&gt;--&gt;
&lt;!--while (条件)--&gt;
&lt;!--{--&gt;
    &lt;!--//执行的代码--&gt;
&lt;!--}--&gt;

&lt;!--do{--&gt;
    &lt;!--//执行的代码--&gt;
&lt;!--}while(条件)--&gt;
&lt;!----&gt;
&lt;!--&lt;/script&gt;--&gt;

03 分支结构
if...else..
switch...case

&lt;script&gt;
switch (12)
{
    case 1:
        console.log(1);
        break;
    case 2:
        console.log(2);
        break;
    default:
        console.log(&quot;其他的数据&quot;);
}
&lt;/script&gt;

04 break continue
break :退出循环，执行该循环后面的代码
continue：退出循环(结束当前的循环)，继续执行下一次的循环

&lt;script&gt;
for (var i = 0; i &lt;10; i++) {
    if (i == 5)
    {
        //break;
        continue;
    }

    console.log(&quot;i = &quot; + i);

}

&lt;/script&gt;
</code></pre><h3 id="十三-调试工具的使用-断点"><a href="#十三-调试工具的使用-断点" class="headerlink" title="十三:调试工具的使用(断点)"></a>十三:调试工具的使用(断点)</h3><pre><code>调试工具
01 打开控制台
windows : F12 MAC OSX  option + command + j

02 控制台的详细介绍
03 断点（普通断点 + 条件断点）
04 网络通信的模型
客户端（浏览器|app） --- 服务器端(电脑)
客户端需要数据      ______请求__________&gt;服务器端  （01 请求）
客户端              _____数据__________服务器端     (02 响应)
请求：请求头（对客户端以及请求本身的描述信息） + 请求体（具体的参数）  GET
响应：响应头（对服务器端以及响应本身的描述信息） + 响应体（具体的数据）

GMT 格林尼治时间
北京时间  +     08

&lt;div id=&quot;demo&quot;&gt;测试的div&lt;/div&gt;
&lt;script&gt;
var a = &quot;testA&quot;;

var b = &quot;testB&quot;;
function func01() {
    console.log(a);
    console.log(b);
    var c = &quot;testC&quot;;
    console.log(c);
}

function func02() {
    console.log(&quot;func02&quot;);
}
console.log(b);
func01();
func02();

//console.log(c);

a = &quot;testAAAAASA&quot;;
console.log(a);

for (var i = 0; i &lt; 10000; i++) {
   console.log(i);

}

&lt;/script&gt;
</code></pre><h3 id="十四-异常处理"><a href="#十四-异常处理" class="headerlink" title="十四:异常处理"></a>十四:异常处理</h3><pre><code>异常处理(try...catch)
如果我们的代码发生了异常，那么该行代码后面的代码将无法得到执行
但是有的时候，我们需要保证在任何情况下某些代码都能够正常得到执行，这个时候就可以使用异常捕获结构
异常捕获结构（try...catch）
01 把可能出错的代码放在try{}代码块中

手动的抛出异常 throw关键字
异常信息：字符串 | 对象（）

完整的异常捕获结构
try{}catch(e){}finally{}
&lt;script&gt;
try
{
    //01 存放的是可能出错的代码
    //console.log(c);
}
catch(e)
{
    //02 出错之后会执行这部分代码
    console.log(e);
}
finally
{
    //03 不管是否出错都会执行的代码
    console.log(&quot;无论如何都会执行的代码&quot;);

    //有什么用？ 前端中一般不会使用
    //Node.js 服务器端  最后的扫尾和资源释放的工作
}
&lt;/script&gt;
&lt;script&gt;
try
{
    //可能出错的代码
    var a = &quot;testA&quot;;
    console.log(a);
    //console.log(c);

    //throw &quot;这里出现了隐秘的错误，请检查！&quot;;
    throw {
        errorMsg:&quot;错误信息&quot;,
        errorCode:&quot;100201&quot;
    }
}
catch (e)
{
    //出现了异常之后，会执行这个代码块中的任务（应对异常的解决方法）
    console.log(e);
}

function func() {
  console.log(&quot;func&quot;);
}

func();
&lt;/script&gt;
</code></pre><h3 id="十五-DOM操作"><a href="#十五-DOM操作" class="headerlink" title="十五: DOM操作"></a>十五: DOM操作</h3><pre><code>DOM:文档对象模型 核心对象：document
增加|删除|修改|查询
查询：getElementById|className |tagName
删除：remove...
修改: 得到标签之后直接设置
增加:createEle...

需求：创建一个div标签，设置标签的内容为：我让掉下眼泪的，不止昨夜的酒，设置样式
样式：
    高度：100px
    宽度：300px
    背景颜色:red
    边框： 1px solid #432
把标签添加到当前的页面中
&lt;script&gt;
//01 创建标签
var div = document.createElement(&quot;div&quot;);
//02 设置内容和样式
div.innerText = &quot;我让掉下眼泪的，不止昨夜的酒&quot;;
div.style.height = &quot;100px&quot;;
div.style.width = &quot;300px&quot;;
div.style.backgroundColor = &quot;red&quot;;
div.style.border = &quot;1px solid #555&quot;;
//03 添加到body
document.body.appendChild(div);
//04 删除标签
document.body.removeChild(div);

&lt;/script&gt;
</code></pre><h3 id="十六-函数和对象的创建"><a href="#十六-函数和对象的创建" class="headerlink" title="十六:函数和对象的创建"></a>十六:函数和对象的创建</h3><pre><code>函数的创建
01 函数声明 function 函数名（参数1，参数2）{函数体}
02 函数表达式 var func =  function [函数名]（参数1，参数2）{函数体}
03 使用构造函数创建（Function）

对象的创建
01 字面量的方式
02 构造函数（Object） + new
&lt;script&gt;
//01 函数声明
function func(a,b) {
    console.log(a + b);
}
func(1,2);

//02 函数表达式
var foo = function () {
    console.log(&quot;foo&quot;);
}

foo();

//03 构造函数创建
var funcName = new Function(&quot;console.log(123)&quot;);
funcName();

&lt;/script&gt;
&lt;script&gt;
var obj = {
    name:&quot;张三&quot;
}

var obj2 = new Object();  //{}
obj2.name = &quot;李四&quot;;
console.log(obj2);


&lt;/script&gt;
</code></pre><h3 id="十七-面向过程和面向对象的概念"><a href="#十七-面向过程和面向对象的概念" class="headerlink" title="十七:面向过程和面向对象的概念"></a>十七:面向过程和面向对象的概念</h3><pre><code>面向过程
关注的是解决问题需要的一个接着一个的过程

面向对象
关注的是解决问题需要的对象

面向对象编程主要重点是对象：内置对象（数组对象|日期对象|函数对象） 自定义

面向对象和面向过程都是一种解决编程问题的思想（方法）

例子：
    面向过程的洗衣服方式：
     01 收集脏衣服
     02 找个盆（桶）
     03 接水
     04 放洗衣液（洗衣粉）
     05 搅匀
     06 先泡几分钟（15）
     07 摩擦摩擦
     08 再清水冲洗一遍
     09 把衣服拧干
     10 晾衣服

    面向对象洗衣服
        01 收集脏衣服
        02 找个合适的洗衣机|男朋友|女朋友
        03 设置洗衣服和烘干的程序

面向对象和面向过程关系 其实是对面向过程的一种封装（？） 减少冗余的代码 + 复用性更好
</code></pre>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[项目实战]]></title>
      <url>/2016/04/25/Bootstrap%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/</url>
      <content type="html"><![CDATA[<p>#项目实战</p>
<h3 id="一-搭建-Bootstrap-页面骨架及项目目录结构"><a href="#一-搭建-Bootstrap-页面骨架及项目目录结构" class="headerlink" title="一. 搭建 Bootstrap 页面骨架及项目目录结构"></a>一. 搭建 Bootstrap 页面骨架及项目目录结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">├─ /weijinsuo/ ··················· 项目根目录</div><div class="line">└─┬─ /css/ ······················· 项目CSS文件</div><div class="line">├─ /font/ ······················ 使用到的字体文件</div><div class="line">├─ /img/ ······················· 使用到的图片文件</div><div class="line">├─ /js/ ························ 自己的JS脚本</div><div class="line">├─ /lib/ ······················· 第三方类库</div><div class="line">├─ /favicon.ico ················ 站点图标</div><div class="line">└─ /index.html ················· 入口文件</div></pre></td></tr></table></figure>
<a id="more"></a>
<p><img src="/assets/place.png" alt=""></p>
<h3 id="二、项目编码规范约定"><a href="#二、项目编码规范约定" class="headerlink" title="二、项目编码规范约定"></a>二、项目编码规范约定</h3><h4 id="2-1-HTML约定"><a href="#2-1-HTML约定" class="headerlink" title="2.1   HTML约定"></a>2.1   HTML约定</h4><ul>
<li><p>所有的CSS引用在HEAD中，按照第三方优先的顺序排列，我们自己的CSS肯定在最下面</p>
</li>
<li><p>所有JS文件都引用在Body的最下面（加载的缘由），按照依赖顺序排序</p>
</li>
<li><p>如果只是使用bootstrap的样式的话，就不用引用js文件</p>
</li>
<li><p>在head中引入必要的CSS文件，优先引用第三方的CSS，方便我们自己的样式覆盖</p>
</li>
<li><p>在body末尾引入必要的JS文件，优先引用第三方的JS，注意JS文件之间的依赖关系，比如bootstrap.js依赖jQuery，那就应该先引用jquery.js 然后引用bootstrap.js</p>
</li>
<li><p>特殊情况：如果js文件是用于处理一些css样式的，那一般在head中进行引入</p>
</li>
</ul>
<h4 id="2-2-CSS约定"><a href="#2-2-CSS约定" class="headerlink" title="2.2   CSS约定"></a>2.2   CSS约定</h4><ul>
<li><p>除了公共级别样式，其余样式全部加模块前缀</p>
</li>
<li><p>尽量使用 直接子代选择器， 少用间接子代 避免选错</p>
</li>
<li><p>CSS类名冲突 通过约定 给模块加上一个独一无二的名字</p>
</li>
<li><p>使用子代选择器的方式</p>
</li>
</ul>
<h4 id="2-2-JS约定"><a href="#2-2-JS约定" class="headerlink" title="2.2   JS约定"></a>2.2   JS约定</h4><ul>
<li><p>不允许使用onxxx = function(){}的方式注册事件</p>
</li>
<li><p>原生JS统一使用addEventListener(‘xxx’, function(){});</p>
</li>
</ul>
<p><img src="/assets/place.png" alt=""></p>
<h3 id="三、项目默认配置设定"><a href="#三、项目默认配置设定" class="headerlink" title="三、项目默认配置设定"></a>三、项目默认配置设定</h3><h4 id="3-1-HTML5文档结构"><a href="#3-1-HTML5文档结构" class="headerlink" title="3.1   HTML5文档结构"></a>3.1   HTML5文档结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;zh-CN&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;页面标题&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line"></div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<h4 id="3-2-Viewport设置"><a href="#3-2-Viewport设置" class="headerlink" title="3.2   Viewport设置"></a>3.2   Viewport设置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0&quot;&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p>html中插入视口设置，可以通过emmet __meta:vp__ 插入</p>
<p>此属性为移动端页面视口设置，当前值表示在移动端页面的宽度为设备的宽度，并且不缩放（缩放级别为1）</p>
<p>960px 内容 被套在一个宽度为980px(绝大多数设备的视口默认尺寸)的容器(视口)中，将视口缩放到设备的真实尺寸中进行展示</p>
</blockquote>
<h4 id="3-3-浏览器兼容模式"><a href="#3-3-浏览器兼容模式" class="headerlink" title="3.3   浏览器兼容模式"></a>3.3   浏览器兼容模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p>html中插入兼容模式设置，可以通过emmet __meta:compat__ 插入</p>
<p>此属性为文档兼容模式声明，表示如果在IE浏览器下则使用最新的标准渲染当前文档</p>
</blockquote>
<h4 id="3-4-favicon（站点图标）"><a href="#3-4-favicon（站点图标）" class="headerlink" title="3.4   favicon（站点图标）"></a>3.4   favicon（站点图标）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;link rel=&quot;shortcut icon&quot; type=&quot;image/x-icon&quot; href=&quot;favicon.ico&quot;&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p>html中插入图标链接，可以通过emmet __link:favicon__ 插入</p>
</blockquote>
<h4 id="3-5-引入相应的第三方文件"><a href="#3-5-引入相应的第三方文件" class="headerlink" title="3.5   引入相应的第三方文件"></a>3.5   引入相应的第三方文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;bootstrap.css&quot;&gt;</div><div class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;index.css&quot;&gt;</div><div class="line">...</div><div class="line">&lt;script src=&quot;jquery.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script src=&quot;bootstrap.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<h4 id="3-6-设置默认字体"><a href="#3-6-设置默认字体" class="headerlink" title="3.6   设置默认字体"></a>3.6   设置默认字体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">body&#123;</div><div class="line">font-family: &quot;Helvetica Neue&quot;,</div><div class="line">Helvetica,</div><div class="line">Microsoft Yahei,</div><div class="line">Hiragino Sans GB,</div><div class="line">WenQuanYi Micro Hei,</div><div class="line">sans-serif;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/assets/place.png" alt=""></p>
<h3 id="四、项目结构搭建"><a href="#四、项目结构搭建" class="headerlink" title="四、项目结构搭建"></a>四、项目结构搭建</h3><h4 id="4-1-完成页面空结构搭建"><a href="#4-1-完成页面空结构搭建" class="headerlink" title="4.1   完成页面空结构搭建"></a>4.1   完成页面空结构搭建</h4><blockquote>
<p>先划分好页面中的大容器，然后在具体看每一个容器中单独的情况</p>
</blockquote>
<h4 id="4-2-构建顶部通栏"><a href="#4-2-构建顶部通栏" class="headerlink" title="4.2   构建顶部通栏"></a>4.2   构建顶部通栏</h4><ul>
<li><strong>container类</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">定义一个固定宽度且居中的版心</div><div class="line">container是具备响应式的能力</div><div class="line">四个档位 1170 970 750 100%</div></pre></td></tr></table></figure>
<ul>
<li><strong>栅格系统</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Bootstrap中的栅格系统就是将一行划分为12列</div><div class="line">我们通过col-*-*的类名控制某个元素在某种屏幕的情况下展示几列</div><div class="line">col-md-6 在中等屏幕下 占1/2</div><div class="line">col-xs-12 在超小屏幕下 占全部</div></pre></td></tr></table></figure>
<ul>
<li><strong>row类</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">.row&#123; marginLeft:-15px; marginRight:-15px &#125;</div><div class="line">抵消掉container中定义的padding</div></pre></td></tr></table></figure>
<ul>
<li><strong>col-**</strong><em>-\</em><strong>**类</strong></li>
</ul>
<p>在某种屏幕尺寸下控制列的占比</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">col-xs-[列数]：在超小屏幕下展示几份</div><div class="line">col-sm-[列数]：在小屏幕下展示几份</div><div class="line">col-md-[列数]：在中等屏幕下展示几份</div><div class="line">col-lg-[列数]：在大屏幕下展示几份</div><div class="line">__xs__ : 超小屏幕 手机 (&lt;768px)</div><div class="line">__sm__ : 小屏幕 平板 (≥768px)</div><div class="line">__md__ : 中等屏幕 桌面显示器 (≥992px)</div><div class="line">__lg__ : 大屏幕 大桌面显示器 (≥1200px)</div></pre></td></tr></table></figure>
<h4 id="4-3-字体图标"><a href="#4-3-字体图标" class="headerlink" title="4.3   字体图标"></a>4.3   字体图标</h4><blockquote>
<p>字体实际上就是记录一个字符对应的图形</p>
<p>在CSS中为元素设置字体，以前只能设置客户端存在的字体</p>
<p>webfont 在线字体</p>
<p>我自己做一套图形的字体</p>
<p>如何定义一个web字体？</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/* 定义一个叫做“bb”字体 */</div><div class="line">@font-face &#123;</div><div class="line">font-family: &apos;bb&apos;;</div><div class="line">src: url(&apos;../font/MiFie-Web-Font.eot&apos;) format(&apos;embedded-opentype&apos;),</div><div class="line">url(&apos;../font/MiFie-Web-Font.svg&apos;) format(&apos;svg&apos;),</div><div class="line">url(&apos;../font/MiFie-Web-Font.ttf&apos;) format(&apos;truetype&apos;),</div><div class="line">url(&apos;../font/MiFie-Web-Font.woff&apos;) format(&apos;woff&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>字体文件格式</strong></li>
</ul>
<p>eot : embedded-opentype</p>
<p>svg : svg</p>
<p>ttf : truetype</p>
<p>woff : woff</p>
<ul>
<li><p><strong>icomoon</strong></p>
</li>
<li><p><strong>使用方式</strong></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">@font-face &#123;</div><div class="line">font-family: &apos;bb&apos;;</div><div class="line">src: url(&apos;../font/MiFie-Web-Font.eot&apos;) format(&apos;embedded-opentype&apos;),</div><div class="line">url(&apos;../font/MiFie-Web-Font.svg&apos;) format(&apos;svg&apos;),</div><div class="line">url(&apos;../font/MiFie-Web-Font.ttf&apos;) format(&apos;truetype&apos;),</div><div class="line">url(&apos;../font/MiFie-Web-Font.woff&apos;) format(&apos;woff&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">[class^=&quot;icon-&quot;],</div><div class="line">[class*=&quot; icon-&quot;] &#123;</div><div class="line">/*注意上面选择器中间的空格*/</div><div class="line">/*我们使用的名为bb的字体就是上面的@font-face的方式声明的*/</div><div class="line">font-family: bb;</div><div class="line">font-style: normal;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.icon-mobilephone::before&#123;</div><div class="line">content: &apos;\e908&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;div class=&quot;col-md-2 text-center&quot;&gt;</div><div class="line">    &lt;a class=&quot;mobile-link&quot; href=&quot;#&quot;&gt;</div><div class="line">        &lt;i class=&quot;icon-mobile&quot;&gt;&lt;/i&gt;</div><div class="line">        &lt;span&gt;IT点论坛&lt;/span&gt;</div><div class="line">        &lt;!-- 这里使用的是bootstrap中的字体图标 --&gt;</div><div class="line">        &lt;i class=&quot;glyphicon glyphicon-chevron-down&quot;&gt;&lt;/i&gt;</div><div class="line">        &lt;img src=&quot;...&quot; alt=&quot;&quot;&gt;</div><div class="line">    &lt;/a&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p>[<em>attribute</em>^=<em>value</em>]   选择器匹配属性值以指定值开头的每个元素。</p>
<p>[<em>attribute*</em>=<em>value</em>]    选择器匹配属性值包含指定值开头的每个元素。</p>
</blockquote>
<h4 id="4-4-二维码图片展示"><a href="#4-4-二维码图片展示" class="headerlink" title="4.4   二维码图片展示"></a>4.4   二维码图片展示</h4><h4 id="4-5-按钮样式生成"><a href="#4-5-按钮样式生成" class="headerlink" title="4.5   按钮样式生成"></a>4.5   按钮样式生成</h4><ul>
<li><p>http:\/\/blog.koalite.com\/bbg\/</p>
</li>
<li><p>可以通过界面生成一个新的按钮样式</p>
</li>
<li><p>具体代码</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">.btn-bb &#123;</div><div class="line">color: #ffffff;</div><div class="line">background-color: #E92322;</div><div class="line">border-color: #DB3B43;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.btn-bb:hover,</div><div class="line">.btn-bb:focus,</div><div class="line">.btn-bb:active,</div><div class="line">.btn-bb.active,</div><div class="line">.open .dropdown-toggle.btn-bb &#123;</div><div class="line">color: #ffffff;</div><div class="line">background-color: #E92322;</div><div class="line">border-color: #DB3B43;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.btn-bb:active,</div><div class="line">.btn-bb.active,</div><div class="line">.open .dropdown-toggle.btn-bb &#123;</div><div class="line">background-image: none;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.btn-bb.disabled,</div><div class="line">.btn-bb[disabled],</div><div class="line">fieldset[disabled] .btn-bb,</div><div class="line">.btn-bb.disabled:hover,</div><div class="line">.btn-bb[disabled]:hover,</div><div class="line">fieldset[disabled] .btn-bb:hover,</div><div class="line">.btn-bb.disabled:focus,</div><div class="line">.btn-bb[disabled]:focus,</div><div class="line">fieldset[disabled] .btn-bb:focus,</div><div class="line">.btn-bb.disabled:active,</div><div class="line">.btn-bb[disabled]:active,</div><div class="line">fieldset[disabled] .btn-bb:active,</div><div class="line">.btn-bb.disabled.active,</div><div class="line">.btn-bb[disabled].active,</div><div class="line">fieldset[disabled] .btn-bb.active &#123;</div><div class="line">background-color: #E92322;</div><div class="line">border-color: #DB3B43;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.btn-bb .badge &#123;</div><div class="line">color: #E92322;</div><div class="line">background-color: #ffffff;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-6-小屏幕隐藏"><a href="#4-6-小屏幕隐藏" class="headerlink" title="4.6   小屏幕隐藏"></a>4.6   小屏幕隐藏</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;topbar hidden-xs hidden-sm&quot;&gt;&lt;/div&gt;</div><div class="line">//  或者</div><div class="line">&lt;div class=&quot;topbar visible-md visible-lg&quot;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p>__hidden-xx__ : 在某种屏幕下隐藏</p>
<p>__visible-xx-xxx__ : 在某种屏幕尺寸下显示</p>
<p>visible-md-xx：指的是中等屏幕可见，不是中等屏幕以上</p>
<p>visible-md-block visible-lg-block == hidden-sm hidden-xs</p>
</blockquote>
<ul>
<li>根据hidden-xxx和visible-xxx的特点，我们可以通过媒体查询的方式实习</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">@media (max-width:768px) &#123;</div><div class="line">/*-xs*/</div><div class="line">.hidden-xs &#123;</div><div class="line">display: none;</div><div class="line">&#125;</div><div class="line">.visible-xs-block &#123;</div><div class="line">display: block;</div><div class="line">&#125;</div><div class="line">.visible-xs-inline &#123;</div><div class="line">display: inline;</div><div class="line">&#125;</div><div class="line">.visible-xs-inline-block &#123;</div><div class="line">display: inline-block;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@media (max-width:992px) &#123;</div><div class="line">/*-sm*/</div><div class="line">.hidden-sm &#123;</div><div class="line">display: none;</div><div class="line">&#125;</div><div class="line">.visible-sm-block &#123;</div><div class="line">display: block;</div><div class="line">&#125;</div><div class="line">.visible-sm-inline &#123;</div><div class="line">display: inline;</div><div class="line">&#125;</div><div class="line">.visible-sm-inline-block &#123;</div><div class="line">display: inline-block;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@media (max-width:1200px) &#123;</div><div class="line">/*-md*/</div><div class="line">.hidden-md &#123;</div><div class="line">display: none;</div><div class="line">&#125;</div><div class="line">.visible-md-block &#123;</div><div class="line">display: block;</div><div class="line">&#125;</div><div class="line">.visible-md-inline &#123;</div><div class="line">display: inline;</div><div class="line">&#125;</div><div class="line">.visible-md-inline-block &#123;</div><div class="line">display: inline-block;</div><div class="line">&#125;</div><div class="line"></div><div class="line">----------</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">@media (min-width:1200px) &#123;</div><div class="line">/*-lg*/</div><div class="line">.hidden-lg &#123;</div><div class="line">display: none;</div><div class="line">&#125;</div><div class="line">.visible-lg-block &#123;</div><div class="line">display: block;</div><div class="line">&#125;</div><div class="line">.visible-lg-inline &#123;</div><div class="line">display: inline;</div><div class="line">&#125;</div><div class="line">.visible-lg-inline-block &#123;</div><div class="line">display: inline-block;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-7-导航通栏"><a href="#4-7-导航通栏" class="headerlink" title="4.7   导航通栏"></a>4.7   导航通栏</h4><ul>
<li>在使用了boostrap过后，大多数界面元素都是通过bootstrap提供好的界面组件修改得来</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;nav class=&quot;navbar navbar-default navbar-bb navbar-static-top&quot;&gt;</div><div class="line">    &lt;div class=&quot;container&quot;&gt;</div><div class="line">        &lt;div class=&quot;navbar-header&quot;&gt;</div><div class="line">            &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;</div><div class="line">                &lt;i class=&quot;icon-icon&quot;&gt;&lt;/i&gt;</div><div class="line">                &lt;i class=&quot;icon-logo&quot;&gt;&lt;/i&gt;</div><div class="line">            &lt;/a&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">        &lt;ul class=&quot;nav navbar-nav&quot;&gt;</div><div class="line">            &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;我要投资&lt;/a&gt;&lt;/li&gt;</div><div class="line">            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;我要借款&lt;/a&gt;&lt;/li&gt;</div><div class="line">            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;平台介绍&lt;/a&gt;&lt;/li&gt;</div><div class="line">            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;新手专区&lt;/a&gt;&lt;/li&gt;</div><div class="line">            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;最新动态&lt;/a&gt;&lt;/li&gt;</div><div class="line">            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;微论坛&lt;/a&gt;&lt;/li&gt;</div><div class="line">        &lt;/ul&gt;</div><div class="line">        &lt;ul class=&quot;nav navbar-nav navbar-right hidden-sm&quot;&gt;</div><div class="line">            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;个人中心&lt;/a&gt;&lt;/li&gt;</div><div class="line">        &lt;/ul&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/nav&gt;</div></pre></td></tr></table></figure>
<ul>
<li>Bootstrap扩展</li>
</ul>
<blockquote>
<p>通过bootstrap文档对导航条样式的设置发现，其实本身是有一个类似于主题的概念</p>
<p>navbar-default：默认的外观</p>
<p>navbar-inverse：暗色背景的样式</p>
<p>所以我们希望可以通过自定义一套完整的风格（继承navbar-default）：</p>
<p>navbar-bb</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.navbar-bb&#123;</div><div class="line">...</div><div class="line">&#125;</div><div class="line">...具体代码参考navbar-default实现即可</div></pre></td></tr></table></figure>
<ul>
<li>品牌logo</li>
</ul>
<blockquote>
<p>使用字体图标</p>
</blockquote>
<ul>
<li>菜单行高调整</li>
</ul>
<blockquote>
<p>默认样式中菜单的行高为20px，我们可以调整为自己想要的高度</p>
<p>一般都是通过自己的样式去覆盖</p>
</blockquote>
<ul>
<li>响应式菜单</li>
</ul>
<blockquote>
<p>默认菜单是不具备响应式的能力的，通过观察文档发现，响应式菜单是通过一个按钮控制的</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">&lt;nav class=&quot;navbar navbar-default navbar-bb navbar-static-top&quot;&gt;</div><div class="line">    &lt;div class=&quot;container&quot;&gt;</div><div class="line">        &lt;div class=&quot;navbar-header&quot;&gt;</div><div class="line">            &lt;!-- 点击该按钮会切换菜单的显示或隐藏 --&gt;</div><div class="line">            &lt;button</div><div class="line">                    id=&quot;btn&quot;</div><div class="line">                    type=&quot;button&quot;</div><div class="line">                    class=&quot;navbar-toggle collapsed&quot;</div><div class="line">                    data-toggle=&quot;collapse&quot;</div><div class="line">                    data-target=&quot;#nav_list&quot;</div><div class="line">                    aria-expanded=&quot;false&quot;</div><div class="line">            &gt;</div><div class="line">                &lt;span class=&quot;sr-only&quot;&gt;切换菜单&lt;/span&gt;</div><div class="line">                &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;</div><div class="line">                &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;</div><div class="line">                &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;</div><div class="line">            &lt;/button&gt;</div><div class="line">            &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;</div><div class="line">                &lt;i class=&quot;icon-icon&quot;&gt;&lt;/i&gt;</div><div class="line">                &lt;i class=&quot;icon-logo&quot;&gt;&lt;/i&gt;</div><div class="line">            &lt;/a&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">        &lt;div id=&quot;nav_list&quot; class=&quot;collapse navbar-collapse&quot;&gt;</div><div class="line">            &lt;ul class=&quot;nav navbar-nav&quot;&gt;</div><div class="line">                &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;我要投资&lt;/a&gt;&lt;/li&gt;</div><div class="line">                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;我要借款&lt;/a&gt;&lt;/li&gt;</div><div class="line">                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;平台介绍&lt;/a&gt;&lt;/li&gt;</div><div class="line">                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;新手专区&lt;/a&gt;&lt;/li&gt;</div><div class="line">                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;最新动态&lt;/a&gt;&lt;/li&gt;</div><div class="line">                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;微论坛&lt;/a&gt;&lt;/li&gt;</div><div class="line">            &lt;/ul&gt;</div><div class="line">            &lt;ul class=&quot;nav navbar-nav navbar-right hidden-sm&quot;&gt;</div><div class="line">                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;个人中心&lt;/a&gt;&lt;/li&gt;</div><div class="line">            &lt;/ul&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/nav&gt;</div></pre></td></tr></table></figure>
<h4 id="4-8-轮播图"><a href="#4-8-轮播图" class="headerlink" title="4.8  轮播图"></a>4.8  轮播图</h4><ul>
<li>Bootstrap JS插件使用</li>
</ul>
<blockquote>
<p>对于Bootstrap的JS插件</p>
<p>我们只需要将文档实例中的代码粘到我们自己的代码中</p>
<p>然后作出相应的样式调整</p>
</blockquote>
<ul>
<li><p>Bootstrap中轮播图插件叫作Carousel</p>
</li>
<li><p>基本的轮播图实现</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">&lt;!-- </div><div class="line">  以下容器就是整个轮播图组件的整体，</div><div class="line">  注意该盒子必须加上 class=&quot;carousel slide&quot; data-ride=&quot;carousel&quot; 表示当前是一个轮播图</div><div class="line">  bootstrap.js会自动为当前元素添加图片轮播的特效</div><div class="line">--&gt;</div><div class="line">&lt;div id=&quot;轮播图的ID&quot; class=&quot;carousel slide&quot; data-ride=&quot;carousel&quot;&gt;</div><div class="line">    &lt;!-- ol标签是图片轮播的控制点 --&gt;</div><div class="line">    &lt;ol class=&quot;carousel-indicators&quot;&gt;</div><div class="line">        &lt;!--</div><div class="line">          每一个li就是一个单独的控制点</div><div class="line">            data-target属性就是指定当前控制点控制的是哪一个轮播图，其目的是如果界面上有多个轮播图，便于区分到底控制哪一个</div><div class="line">            data-slide-to属性是指当前的li元素绑定的是第几个轮播项</div><div class="line">          注意，默认必须给其中某个li加上active，展示的时候就是焦点项目</div><div class="line">        --&gt;</div><div class="line">        &lt;li data-target=&quot;#轮播图的ID&quot; data-slide-to=&quot;0&quot; class=&quot;active&quot;&gt;&lt;/li&gt;</div><div class="line">        &lt;li data-target=&quot;#轮播图的ID&quot; data-slide-to=&quot;1&quot;&gt;&lt;/li&gt;</div><div class="line">        &lt;!-- ...更多的 --&gt;</div><div class="line">    &lt;/ol&gt;</div><div class="line">    &lt;!--</div><div class="line">      .carousel-inner是所有轮播项的容器盒子，</div><div class="line">      注意role=&quot;listbox&quot;代表当前div是一个列表盒子，作用就是给当前div添加一个语义</div><div class="line">    --&gt;</div><div class="line">    &lt;div class=&quot;carousel-inner&quot; role=&quot;listbox&quot;&gt;</div><div class="line">        &lt;!-- 每一个.item就是单个轮播项目，注意默认要给第一个轮播项目加上active，表示为焦点 --&gt;</div><div class="line">        &lt;div class=&quot;item active&quot;&gt;</div><div class="line">            &lt;!-- 轮播项目中展示的图片 --&gt;</div><div class="line">            &lt;img src=&quot;example.jpg&quot; alt=&quot;示例图片&quot;&gt;</div><div class="line">            &lt;div class=&quot;carousel-caption&quot;&gt;</div><div class="line">                &lt;!-- 标题或说明性文字，如果不需要，直接删除当前div.carousel-caption --&gt;</div><div class="line">            &lt;/div&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">        &lt;div class=&quot;item&quot;&gt;</div><div class="line">            &lt;!-- ... --&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">        &lt;!-- ... --&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">    &lt;!-- 图片轮播上左右两个控制按钮，分别点击可以滚动到上一张和下一张 --&gt;</div><div class="line">    &lt;!-- 此处需要注意的是 该a链接的href属性必须指向需要控制的轮播图ID --&gt;</div><div class="line">    &lt;!-- 另外a链接中的data-slide=&quot;prev&quot;代表点击该链接会滚到上一张，如果设置为next的话则相反 --&gt;</div><div class="line">    &lt;a class=&quot;left carousel-control&quot; href=&quot;#轮播图的ID&quot; role=&quot;button&quot; data-slide=&quot;prev&quot;&gt;</div><div class="line">        &lt;span class=&quot;glyphicon glyphicon-chevron-left&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;</div><div class="line">        &lt;span class=&quot;sr-only&quot;&gt;上一张&lt;/span&gt;</div><div class="line">    &lt;/a&gt;</div><div class="line">    &lt;a class=&quot;right carousel-control&quot; href=&quot;#轮播图的ID&quot; role=&quot;button&quot; data-slide=&quot;next&quot;&gt;</div><div class="line">        &lt;span class=&quot;glyphicon glyphicon-chevron-right&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;</div><div class="line">        &lt;span class=&quot;sr-only&quot;&gt;下一张&lt;/span&gt;</div><div class="line">    &lt;/a&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<ul>
<li><p>轮播图片超宽造成的影响</p>
</li>
<li><p>美工为了在不同屏幕下更好地展示将图片两边做的非常宽，但是我们大多数情况的页面宽度都无法满足这样的图片宽度</p>
</li>
<li><p>而且Bootstrap的样式中默认将图片的max-width设置为100%, 造成界面图片缩放</p>
</li>
<li><p>想在一个较小屏幕下展示一个超宽的图片，并让图片居中显示</p>
</li>
<li><p>两种办法：</p>
</li>
</ul>
<p>换用背景图的方式，background-position: center center;</p>
<p>使img元素绝对定位，left:50%，margin-left: -width\/2</p>
<p>translate方式</p>
<ul>
<li>background-size</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- length</div><div class="line">+ 如 background-size: 100px 100px，将背景图固定到多大尺寸</div><div class="line">- percentage</div><div class="line">+ 如 background-size: 90% 90%，以百分比的形式设置背景大小</div><div class="line">- cover</div><div class="line">+ 1.背景图片等比例缩放</div><div class="line">+ 2.让背景图相对较小边放大到目标容器大小结束</div><div class="line">* 如：一张100\*200的背景图放到一个300\*400的盒子中，最终背景图片的大小是300\*600</div><div class="line">* 因为背景图的较小边为100，将100放大到目标容器300的宽度，放大了3倍，最终结果300\*600</div><div class="line">- contain</div><div class="line">+ 1.背景图片等比例缩放</div><div class="line">+ 2.让背景图相对较大边放大到目标容器大小结束</div><div class="line">* 如：一张100\*200的背景图放到一个300\*400的盒子中，最终背景图片的大小是200\*400</div><div class="line">* 因为背景图的较大边为200，将200放大到目标容器400的高度，放大了2倍，最终结果200\*400</div></pre></td></tr></table></figure>
<p><img src="/assets/Snip20170410_15.png" alt=""></p>
<ul>
<li><p>图片响应式</p>
</li>
<li><p>目的</p>
</li>
<li><p>各种终端都需要正常显示图片</p>
</li>
<li><p>移动端应该使用更小（体积）的图片</p>
</li>
<li><p>实现方式</p>
</li>
<li><ul>
<li>将元素中直接设置的图片背景删除，换成两个data-属性（如：data-img-sm=”小图路径”，data-img-lg=”大图路径”）</li>
</ul>
</li>
<li><p>通过JS的方式获取屏幕的宽度；</p>
</li>
<li><p>判断屏幕宽度是否小于一定的值（如：768px）；</p>
</li>
<li><p>根据判断情况决定使用具体的大图还是小图；</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 获取屏幕宽度</div><div class="line">var windowWidth = $(window).width();</div><div class="line">// 判断屏幕属于大还是小</div><div class="line">var isSmallScreen = windowWidth &lt; 768;</div><div class="line">// 根据大小为界面上的每一张轮播图设置背景</div><div class="line">// $(&apos;#main_ad &gt; .carousel-inner &gt; .item&apos;) // 获取到的是一个DOM数组（多个元素）</div><div class="line">$(&apos;#main_ad &gt; .carousel-inner &gt; .item&apos;).each(function(i, item) &#123;</div><div class="line">// 因为拿到是DOM对象 需要转换</div><div class="line">var $item = $(item);</div><div class="line">// var imgSrc = $item.data(isSmallScreen ? &apos;image-xs&apos; : &apos;image-lg&apos;);</div><div class="line">var imgSrc =</div><div class="line">isSmallScreen ? $item.data(&apos;image-xs&apos;) : $item.data(&apos;image-lg&apos;);</div><div class="line"></div><div class="line">// 设置背景图片</div><div class="line">$item.css(&apos;backgroundImage&apos;, &apos;url(&quot;&apos; + imgSrc + &apos;&quot;)&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ul>
<li>window resize事件</li>
</ul>
<blockquote>
<p>由于上一步我们实现的过程是指在页面加载完成判断一次，</p>
<p>当用户手动调整页面宽度过后没有及时发生变化，</p>
<p>所以我们可以通过window的resize事件中重新完成以上操作来解决这个问题</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function 窗口变化后执行的函数名()&#123;</div><div class="line">// 具体的操作</div><div class="line">&#125;</div><div class="line">$(window).on(&apos;resize&apos;, 窗口变化后执行的函数名);</div></pre></td></tr></table></figure>
<blockquote>
<p>这个事件只会在窗口尺寸发生变化后执行，但是我们需要一开始时执行一次</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">$(window).on(&apos;resize&apos;, 窗口变化后执行的函数名).trigger(&apos;resize&apos;);</div></pre></td></tr></table></figure>
<h4 id="4-9-网站特性"><a href="#4-9-网站特性" class="headerlink" title="4.9  网站特性"></a>4.9  网站特性</h4><ul>
<li><p>网格系统</p>
</li>
<li><p>该板块当屏幕为中等尺寸时分为3列，较小屏幕是分为2列</p>
</li>
<li><p>所以使用网格系统划分</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;col-sm-6 col-md-4&quot;&gt;</div><div class="line">    &lt;!-- ... --&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;!-- ... --&gt;</div></pre></td></tr></table></figure>
<ul>
<li><p>媒体对象样式</p>
</li>
<li><ul>
<li>每一个小块的样式可以通过Bootstrap中的媒体对象样式实现</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;a href=&quot;#&quot;&gt;</div><div class="line">    &lt;div class=&quot;media&quot;&gt;</div><div class="line">        &lt;div class=&quot;media-left&quot;&gt;</div><div class="line">            &lt;i class=&quot;icon-uniE907&quot;&gt;&lt;/i&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">        &lt;div class=&quot;media-body&quot;&gt;</div><div class="line">            &lt;h4 class=&quot;media-heading&quot;&gt;支付交易保障&lt;/h4&gt;</div><div class="line">            &lt;p&gt;银联支付全称保证支付安全&lt;/p&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/a&gt;</div></pre></td></tr></table></figure>
<ul>
<li><p>响应式辅助类型</p>
</li>
<li><ul>
<li>整个板块在超小屏幕下是隐藏起来的</li>
</ul>
</li>
<li><p>只需要给当前板块加上hidden-xs的class</p>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 前端  bootstrap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Bootstrap实践理解]]></title>
      <url>/2016/04/20/Bootstrap3%E7%9A%84%E5%AD%A6%E4%B9%A0md/</url>
      <content type="html"><![CDATA[<p>##Bootstrap编码规范</p>
<p>###黄金定律:不管有多少人共同参加同一项目,一定要确保每一行代码都像是一个人写的一样.</p>
<p>###HTML:语法<br>用两个空格来代替制表符（tab） – 这是唯一能保证在所有环境下获得一致展现的方法。<br>嵌套元素应当缩进一次（即两个空格）。<br>对于属性的定义，确保全部使用双引号，绝不要使用单引号。<br>不要在自闭合（self-closing）元素的尾部添加斜线 – HTML5 规范中明确说明这是可选的。<br>不要省略可选的结束标签（closing tag）（例如， 或 ）。<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">由于markdown不支持显示HTML的DOM元素,所以,每个DOM元素前面的&lt;号我都加了一个空格让代码显示出来</div></pre></td></tr></table></figure>
<pre>
< !DOCTYPE html>
< html>
  < head>
    < title>Page title
  < /head>
  < body>
    < img src="images/company-logo.png" alt="Company">
    < h1 class="hello-world">Hello, world!
  < /body>
< /html>
</pre>

<p>###HTML5 doctype<br>为每个 HTML 页面的第一行添加标准模式（standard mode）的声明，这样能够确保在每个浏览器中拥有一致的展现。</p>
<pre>
< !DOCTYPE html>
< html>
  < head>
  < /head>
< /html>
</pre>
更多请查文档:
[http://codeguide.bootcss.com/](http://codeguide.bootcss.com/ "Bootstrap编码规范")

##禁止响应式布局
Bootstrap 会自动帮你针对不同的屏幕尺寸调整你的页面，使其在各个尺寸的屏幕上表现良好。下面我们列出了如何禁用这一特性，就像这个非响应式布局实例页面一样。

禁止响应式布局有如下几步：
1. 移除 此 CSS 文档中提到的设置浏览器视口（viewport）的标签：<meta>。
2. 通过为 .container 类设置一个 width 值从而覆盖框架的默认 width 设置，例如 width: 970px !important; 。请确保这些设置全部放在默认的 Bootstrap CSS 文件的后面。注意，如果你把它放到媒体查询中，也可以略去 !important 。
3. 如果使用了导航条，需要移除所有导航条的折叠和展开行为。
4. 对于栅格布局，额外增加 .col-xs-* 类或替换掉 .col-md-* 和 .col-lg-*。 不要担心，针对超小屏幕设备的栅格系统能够在所有分辨率的环境下展开。


针对 IE8 仍然需要额外引入 Respond.js 文件（由于仍然利用了浏览器对媒体查询（media query）的支持，因此还需要做处理）。这样就禁用了 Bootstrap 对移动设备的响应式支持。


##标题嵌套
当标题嵌套时 (< h1> - < h6>)，你的文档的主标题应该是 < h1> 标签。随后的标题逻辑上就应该使用 < h2> - < h6> ，这样，屏幕阅读器就可以构造出页面的内容列表了。



#全局 CSS 样式
##移动设备优先
在 Bootstrap 2 中，框架中的某些关键部分增加了对移动设备友好的样式。而在 Bootstrap 3 中，重写了整个框架，使其一开始就是对移动设备友好的。这次不是简单的增加一些可选的针对移动设备的样式，而是直接融合进了框架的内核中。也就是说，Bootstrap 是移动设备优先的。针对移动设备的样式融合进了框架的每个角落，而不是增加一个额外的文件。

为了确保适当的绘制和触屏缩放，需要在 <head> 之中添加 viewport 元数据标签。
<pre>
< meta name="viewport" content="width=device-width, initial-scale=1">
</pre>

<p>在移动设备浏览器上，通过为视口（viewport）设置 meta 属性为 user-scalable=no 可以禁用其缩放（zooming）功能。这样禁用缩放功能后，用户只能滚动屏幕，就能让你的网站看上去更像原生应用的感觉。注意，这种方式我们并不推荐所有网站使用，还是要看你自己的情况而定！</p>
<pre>
< meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
</pre>


<p>##布局容器<br>Bootstrap 需要为页面内容和栅格系统包裹一个 .container 容器。我们提供了两个作此用处的类。注意，由于 padding 等属性的原因，这两种 容器类不能互相嵌套。</p>
<p>.container 类用于固定宽度并支持响应式布局的容器。</p>
<pre>
< div class="container">
  ...
< /div>
</pre>
.container-fluid 类用于 100% 宽度，占据全部视口（viewport）的容器。
<pre>
< div class="container-fluid">
  ...
< /div>
</pre>

<p>##栅格系统</p>
<p>Bootstrap 提供了一套响应式、移动设备优先的流式栅格系统，随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列。它包含了易于使用的预定义类，还有强大的mixin 用于生成更具语义的布局。</p>
<p>简介</p>
<p>栅格系统用于通过一系列的行（row）与列（column）的组合来创建页面布局，你的内容就可以放入这些创建好的布局中。下面就介绍一下 Bootstrap 栅格系统的工作原理：</p>
<ul>
<li>“行（row）”必须包含在 .container （固定宽度）或 .container-fluid （100% 宽度）中，以便为其赋予合适的排列（aligment）和内补（padding）。</li>
<li>通过“行（row）”在水平方向创建一组“列（column）”。</li>
<li>你的内容应当放置于“列（column）”内，并且，只有“列（column）”可以作为行（row）”的直接子元素。</li>
<li>类似 .row 和 .col-xs-4 这种预定义的类，可以用来快速创建栅格布局。Bootstrap 源码中定义的 mixin 也可以用来创建语义化的布局。</li>
<li>通过为“列（column）”设置 padding 属性，从而创建列与列之间的间隔（gutter）。通过为 .row 元素设置负值 margin 从而抵消掉为 .container 元素设置的 padding，也就间接为“行（row）”所包含的“列（column）”抵消掉了padding。</li>
<li>负值的 margin就是下面的示例为什么是向外突出的原因。在栅格列中的内容排成一行。</li>
<li>栅格系统中的列是通过指定1到12的值来表示其跨越的范围。例如，三个等宽的列可以使用三个 .col-xs-4 来创建。</li>
<li>如果一“行（row）”中包含了的“列（column）”大于 12，多余的“列（column）”所在的元素将被作为一个整体另起一行排列。</li>
<li>栅格类适用于与屏幕宽度大于或等于分界点大小的设备 ， 并且针对小屏幕设备覆盖栅格类。 因此，在元素上应用任何 .col-md-<em> 栅格类适用于与屏幕宽度大于或等于分界点大小的设备 ， 并且针对小屏幕设备覆盖栅格类。 因此，在元素上应用任何 .col-lg-</em> 不存在， 也影响大屏幕设备。<br>通过研究后面的实例，可以将这些原理应用到你的代码中。</li>
</ul>
<p>##媒体查询<br>在栅格系统中，我们在 Less 文件中使用以下媒体查询（media query）来创建关键的分界点阈值。</p>
<ul>
<li>/<em> 超小屏幕（手机，小于 768px） </em>/</li>
<li>/<em> 没有任何媒体查询相关的代码，因为这在 Bootstrap 中是默认的（还记得 Bootstrap 是移动设备优先的吗？） </em>/</li>
<li></li>
<li>/<em> 小屏幕（平板，大于等于 768px） </em>/</li>
<li>@media (min-width: @screen-sm-min) { … }</li>
<li></li>
<li>/<em> 中等屏幕（桌面显示器，大于等于 992px） </em>/</li>
<li>@media (min-width: @screen-md-min) { … }</li>
<li></li>
<li>/<em> 大屏幕（大桌面显示器，大于等于 1200px） </em>/</li>
<li>@media (min-width: @screen-lg-min) { … }</li>
<li></li>
</ul>
<p>我们偶尔也会在媒体查询代码中包含 max-width 从而将 CSS 的影响限制在更小范围的屏幕大小之内。</p>
<ul>
<li>@media (max-width: @screen-xs-max) { … }</li>
<li>@media (min-width: @screen-sm-min) and (max-width: @screen-sm-max) { … }</li>
<li>@media (min-width: @screen-md-min) and (max-width: @screen-md-max) { … }</li>
<li>@media (min-width: @screen-lg-min) { … }</li>
</ul>
<p>#组件</p>
<p>##导航<br>Bootstrap 中的导航组件都依赖同一个 .nav 类，状态类也是共用的。改变修饰类可以改变样式。</p>
<p>##模态框 modal.js</p>
<p>模态框经过了优化，更加灵活，以弹出对话框的形式出现，具有最小和最实用的功能集。</p>
<p>不支持同时打开多个模态框<br>千万不要在一个模态框上重叠另一个模态框。要想同时支持多个模态框，需要自己写额外的代码来实现。</p>
<p>模态框的 HTML 代码放置的位置<br>务必将模态框的 HTML 代码放在文档的最高层级内（也就是说，尽量作为 body 标签的直接子元素），以避免其他组件影响模态框的展现和/或功能。</p>
<p>对于移动设备的附加说明<br>这里提供了在移动设备上使用模态框有一些附加说明。请参考浏览器支持章节。</p>
<p>Due to how HTML5 defines its semantics, the autofocus HTML attribute has no effect in Bootstrap modals. To achieve the same effect, use some custom JavaScript:</p>
<p>$(‘#myModal’).on(‘shown.bs.modal’, function () {<br>  $(‘#myInput’).focus()<br>})</p>
<p>##Carousel (轮播图)</p>
<p>#定制<br>为使我们上线的代码更加的轻量/简洁:可以根据需求定制属于自己的bootstrap</p>
<p>定制并下载 Bootstrap<br>通过自定义 Bootstrap 组件、Less 变量和 jQuery 插件，定制一份属于你自己的 Bootstrap 版本吧。</p>
<p>以上的版本基于3.0的学习<br>详细地址:<a href="http://http://v3.bootcss.com/" title="Bootstrap3中文文档" target="_blank" rel="external">http://http://v3.bootcss.com/</a></p>
</head>]]></content>
      
        
        <tags>
            
            <tag> 前端  bootstrap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[面向对象2]]></title>
      <url>/2016/04/19/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1day2/</url>
      <content type="html"><![CDATA[<h3 id="一-面向对象的相关概念"><a href="#一-面向对象的相关概念" class="headerlink" title="一:面向对象的相关概念"></a>一:面向对象的相关概念</h3><pre><code>01 对象是什么?
什么都是对象.对象是具体的事物
思考:电脑(分类) 人 桌子 狗 猫 老师 同学  这些都不是对象,只是一种类别.
</code></pre><a id="more"></a>
<pre><code>02 对象的描述信息(静态特征)
张三: 身高 体重 身份证号码 专业 班级 名字
李四家的狗: 颜色 年龄 名字
03 对象的行为特征(动态的行为)
张三: 吃饭 睡觉 打游戏 跑步
李四家的狗: 吃饭 叫 睡觉 打架 流口水
04 js的对象
对象定义:键值对(key-value)的集合 | 属性(方法)的工具包|对遍历和函数的封装.
对象的组成:
    静态特征:属性(定义在对象中变量)    
    动态行为:方法(定义在对象中函数)
05 补充:
面向对象和面向过程并没有孰优孰劣,解决问题的时候需要看实际的情况(选取正确的方案)
为什么要使用面向对象的方式来写代码? 方便 节省 复用性高
&lt;script&gt;
var dog = {
    name:&quot;旺财&quot;,
    age:13,
    color:&quot;紫色&quot;,
    eat: function () {
        console.log(&quot;eat&quot;);
    },
    sleepp:function (){
        console.log(&quot;sleep&quot;);
    },
    run:function () {
        console.log(&quot;run&quot;);
    }
}

console.log(dog);   //object  { dog对象的东西 }
dog.eat();      //eat
dog.run();      //run


&lt;/script&gt;
</code></pre><h3 id="二-创建并设置标签样式的小案例-面向过程"><a href="#二-创建并设置标签样式的小案例-面向过程" class="headerlink" title="二:创建并设置标签样式的小案例(面向过程)"></a>二:创建并设置标签样式的小案例(面向过程)</h3><pre><code>div&lt;我是第$个div标签&gt;*6

p&lt;我是第$个p标签&gt;*3    

 冗余度(重复的代码很多)
&lt;script&gt;
//01 获得页面中所有的div标签
var divs = document.getElementsByTagName(&quot;div&quot;);
//02 遍历所有的标签并且设置
for (var i = 0; i &lt; divs.length; i++) {
    divs[i].style.border = &quot;1px solid red&quot;;
}

//03 获得页面中所有p标签
var ps = document.getElementsByTagName(&apos;p&apos;);
//04 遍历所有的标签并且设置
for (var i = 0; i &lt; ps.length; i++) {
    ps[i].style.border = &apos;1px solid red&apos;;
}
&lt;/script&gt;
</code></pre><h3 id="三-函数封装-面向过程"><a href="#三-函数封装-面向过程" class="headerlink" title="三:函数封装(面向过程):"></a>三:函数封装(面向过程):</h3><pre><code>&lt;div&gt;我是第1个div标签&lt;/div&gt;
&lt;div&gt;我是第2个div标签&lt;/div&gt;
&lt;div&gt;我是第3个div标签&lt;/div&gt;
&lt;div&gt;我是第4个div标签&lt;/div&gt;
&lt;div&gt;我是第5个div标签&lt;/div&gt;
&lt;div&gt;我是第6个div标签&lt;/div&gt;

需求    :设置页面中所有div标签的样式（边框） border = &quot;1px solid red&quot;;
 设置页面中所有的p标签的样式（边框） border = &quot;1px solid red&quot;;
&lt;p&gt;我是第1个p便签&lt;/p&gt;
&lt;p&gt;我是第2个p便签&lt;/p&gt;
&lt;p&gt;我是第3个p便签&lt;/p&gt;
&lt;script&gt;

//把固定不变的部分抽取作为函数体
//把改变的部分抽取作为函数的参数
function getEle(tagName) {
    return document.getElementsByTagName(tagName);
}
function setBorder(eles) {
    for (var i = 0; i &lt; eles.length; i++) {
        eles[i].style.border = &quot;1px solid red&quot;;
    }
}

var divs = getEle(&quot;div&quot;);
var ps = getEle(&quot;p&quot;);
setBorder(divs);
setBorder(ps);

&lt;/script&gt;
</code></pre><h3 id="四-函数封装-面向对象"><a href="#四-函数封装-面向对象" class="headerlink" title="四:函数封装(面向对象)"></a>四:函数封装(面向对象)</h3><pre><code>&lt;div&gt;我是第1个div标签&lt;/div&gt;
&lt;div&gt;我是第2个div标签&lt;/div&gt;
&lt;div&gt;我是第3个div标签&lt;/div&gt;
&lt;div&gt;我是第4个div标签&lt;/div&gt;
&lt;div&gt;我是第5个div标签&lt;/div&gt;    
&lt;div&gt;我是第6个div标签&lt;/div&gt;

需求:设置页面中所有div标签的样式（边框） border = &quot;1px solid red&quot;;
 设置页面中所有的p标签的样式（边框） border = &quot;1px solid red&quot;;
&lt;p&gt;我是第1个p便签&lt;/p&gt;
&lt;p&gt;我是第2个p便签&lt;/p&gt;
&lt;p&gt;我是第3个p便签&lt;/p&gt;

冗余度 （重复的内容）

&lt;script&gt;

//把固定不变的部分抽取作为函数体
//把改变的部分抽取作为函数的参数
//使用对象来进行封装
var XMGQuery =  {
    getEle:{
        tagName:function (tagName) {
            return document.getElementsByTagName(tagName);
        },
        id:function (id) {
            return document.getElementById(id);
        },
        calssName:function (classNmae) {
            return document.getElementsByClassName(classNmae);
        },
    },
    setStyle:{
        setBorder:function (eles) {
            for (var i = 0; i &lt; eles.length; i++) {
                eles[i].style.border = &quot;1px solid red&quot;;
            }
        },
        setColor:function (eles) {
            for (var i = 0; i &lt; eles.length; i++) {
                eles[i].style.color = &quot;red&quot;;
            }
        }
    }
}
XMGQuery.setStyle.setBorder(XMGQuery.getEle.tagName(&quot;div&quot;));
XMGQuery.setStyle.setBorder(XMGQuery.getEle.tagName(&quot;p&quot;));

&lt;/script&gt;
</code></pre><h3 id="六-面向对象的三大特效"><a href="#六-面向对象的三大特效" class="headerlink" title="六:面向对象的三大特效"></a>六:面向对象的三大特效</h3><pre><code>01封装
好处:复用(!),降低冗余度,更有利于模块化编程,能够为变量函数提供更多的保护.使用对象来封装变量和函数
02 继承
现实中继承：一般是子女获得父母的财富|资源的一种方式。
代码中继承：子类获得父类的属性和方法（成员）的一种方式。
js中的继承:
严格来说js并不是一门面向对象的语言(类-class),支持面向对象而已.
js中的继承是一个对象获得另外一个对象的属性和方法的一种行为.
术语:
父类
子类
超类
js中
父对象 - 子对象
a---b(属性|方法)
实现方法
001 属性拷贝(浅拷贝)
002 属性拷贝(深拷贝)
003 原型式继承
004 原型链继承
005 借用构造函数
006 组合继承
02.多态
多种形态
特点:对于同一个操作(指令),不同的对象表现出不同的反应,隐藏不同
观点:js天生就是一门支持多态的语法.
好处:灵活
&lt;script&gt;
var obj = {
    name :&quot;旺财&quot;,
    age:20,
    friends:[&quot;乌拉乌拉&quot;,&quot;扒拉扒拉&quot;,&quot;哗啦哗啦&quot;],
    showName:function () {
        console.log(this.name);
    }
};

var o = {};

//o 对象需要获得obj对象的属性和方法  o 子对象 obj父对象
 //    o.name = obj.name;
    //    o.age = obj.age;
//    o.showName = obj.showName;
//    o.showName();

for(var k in obj)
{
   // o.k = obj.k;
    o[k] = obj[k];
}
console.log(o);

//如果是引用类型，那么会有共享的问题
obj.friends.push(&quot;无力无力&quot;);
console.log(o);
</code></pre><h3 id="七-创建对象的几种方式"><a href="#七-创建对象的几种方式" class="headerlink" title="七:创建对象的几种方式"></a>七:创建对象的几种方式</h3><pre><code>01 字面量
02 内置构造函数 new Object()|new Date()
03 简单工厂函数创建
04 自定义构造函数
05 Object.create()
&lt;script&gt;

//书（对象）
//属性：书名 | 作者 | 出版社 | 价格
//方法：deslog 打印书本的介绍信息

var book1 = {
    name:&quot;西游记&quot;,
    author:&quot;吴承恩&quot;,
    press:&quot;中华书局&quot;,
    price:&quot;0.1&quot;,
    desLog:function () {
        console.log(&quot;书名：&quot; + this.name + &quot; 作者：&quot; + this.author);
    }
}
book1.desLog();

//需求：（图书管理员）
var book2 = {
    name:&quot;悟空传&quot;,
    author:&quot;今何在&quot;,
    press:&quot;湖南文艺出版社&quot;,
    price:&quot;28.00&quot;,
    desLog:function () {
        console.log(&quot;书名：&quot; + this.name + &quot; 作者：&quot; + this.author);
    }
}

var book3 = {
    name:&quot;什么是批判&quot;,
    author:&quot;福柯&quot;,
    press:&quot;北京大学出版社&quot;,
    price:&quot;58.00&quot;,
    desLog:function () {
        console.log(&quot;书名：&quot; + this.name + &quot; 作者：&quot; + this.author);
    }
}
console.log(book3);

//......

//问题:如果要创建多个同类型的对象，那么代码冗余度太高（重复的代码），复用性（差）
&lt;/script&gt;

2  内置构造函数
Array Date Object Function String Number Boolean
使用方法:new 构造函数(参数)
&lt;script&gt;
var date = new Date();
var array = new Array();
var string = new String(&quot;demo&quot;);

&lt;/script&gt;
&lt;script&gt;

var book = new Object();
book.name = &quot;三国演义&quot;;
book.author = &quot;罗贯中&quot;;
book.press = &quot;中华书局&quot;;
book.desLog = function () {
    console.log(this.name + this.author);
}
book.desLog();

var book2 = new Object();
book2.name = &quot;红楼梦&quot;;
book2.author = &quot;曹公子&quot;;
book2.press = &quot;中华书局&quot;;
book2.desLog = function () {
    console.log(this.name + this.author);
}
book2.desLog();

//问题：同字面量方式一样
&lt;/script&gt;

3. 简单工厂函数创建对象

&lt;script&gt;

//01 提供一个函数
function createBook(name,author) {
    //02 创建空的对象
    var book = new Object();
    //03 设置对象的属性和方法
    book.name = name;
    book.author = author;
    book.desLog = function () {
        console.log(this.name + this.author);
    }
    //04 把创建的对象返回
    return book;
}

var book1 = createBook(&quot;悟空传&quot;,&quot;孙悟空&quot;);
var book2 = createBook(&quot;红楼梦&quot;,&quot;曹公子&quot;);
console.log(book1);
console.log(book2);
console.log( book1 ==  book2);
book1.desLog();
book2.desLog();
&lt;/script&gt;


4.自定义构造函数
&lt;script&gt;

//01 提供一个函数
function createBook(name,author) {
    //02 创建空的对象
    var book = new Object();
    //03 设置对象的属性和方法
    book.name = name;
    book.author = author;
    book.desLog = function () {
        console.log(this.name + this.author);
    }
    //04 把创建的对象返回
    return book;
}

var book1 = createBook(&quot;悟空传&quot;,&quot;孙悟空&quot;);
var book2 = createBook(&quot;红楼梦&quot;,&quot;曹公子&quot;);
console.log(book1);
console.log(book2);
console.log(book1 == book2);
book1.desLog();
book2.desLog();

//问题（特点）：对象类型判断的问题
function createPerson(name,age) {
    var obj = new Object();
    obj.name = name;
    obj.age = age;
    return obj;
}
function createDog(name,age) {
    var obj = new Object();
    obj.name = name;
    obj.age = age;
    return obj;
}

//创建人对象
var obj1 = createPerson(&quot;张三&quot;,23);
var obj2 = createDog(&quot;李四&quot;,10);

//obj1 --- obj2
console.log(obj1);
console.log(obj2);

//无法区分对象的类型  ：obj1（人）obj2(狗)

&lt;/script&gt;

自定义构造函数创建对象
术语：
构造函数 ==  普通函数，人为的区分（首字母大写）
构造函数：主要做初始化的处理（设置属性和方法）
new :    创建对象（{}）
var obj = new Object();
核心过程
01 提供一个构造函数（普通函数首字母大写）
02 通过this指针来设置对象的属性和方法
03 使用new 构造函数（）创建对象

内部的实现过程：
01 提供构造函数
02 创建一个空的对象{} ===&gt; Object
03 设置新创建对象的原型对象为构造函数的原型对象
04 设置新创建对象的构造函数为当前的构造函数
05 把新创建的对象赋值给this
06 通过this设置属性和方法
07 默认在最后把新创建的对象返回

返回值
01 如果没有显示的return,那么默认在最后把新创建的对象返回
02 如果显示的return,那么结果得看具体的情况：
    001 返回的是值类型的  忽略（返回新对象）
    002 返回的是引用类型的 return的对象会把新创建的对象覆盖
&lt;script&gt;
function Dog(name) {
    this.name = name;
    return [1,2,3];
}

var dog1 = new Dog(&quot;旺财&quot;);
console.log(dog1);
&lt;/script&gt;
&lt;script&gt;
function CreatePerson(name,age) {
    //创建对象{}
    //把新的对象赋值给this
    this.name = name;
    this.age = age;
    this.showName = function () {
        console.log(this.name);
    }
    //默认把新创建的对象返回
}
var p1 = new CreatePerson(&quot;张三&quot;,99);
var p2 = new CreatePerson(&quot;李四&quot;,0.9);
p1.showName();
p2.showName();
&lt;/script&gt;

&lt;script&gt;
function Person(name,age) {
    //01 创建对象{}
    //var o = new Object();    o的构造函数 --- Object
    //02 把新的对象赋值给this
    //this = o;
    //03 设置新创建对象的原型对象为构造函数的原型对象
    //o.__proto__ = Person.prototype;
    //04 设置新创建对象的构造函数为当前的构造函数
    //o.constructor = Person;

    this.name = name;
    this.age = age;
    this.showName = function () {
        console.log(this.name);
    }
    //默认把新创建的对象返回
    //return this;
}
var p1 = new Person(&quot;张三&quot;,99);
var p2 = new Person(&quot;李四&quot;,0.9);
p1.showName();
p2.showName();
&lt;/script&gt;

构造函数和普通函数没有什么区别，人为的进行区分（首字母大写）
构造函数在调用的时候需要和new一起使用
普通函数直接调用
</code></pre><h3 id="八-构造函数注意事项01"><a href="#八-构造函数注意事项01" class="headerlink" title="八:构造函数注意事项01"></a>八:构造函数注意事项01</h3><pre><code>01 函数传值
02 instanceOf
03 对象到底是什么类型(构造器属性)
&lt;script&gt;
function Person(name,doSomething) {
    this.name = name;
    this.doSomething = doSomething;
}

var p1 = new Person(&quot;张三&quot;,function () {
    console.log(&quot;流口水&quot;);
});
var p2 = new Person(&quot;李四&quot;,function () {
    console.log(&quot;咬人&quot;);
});
p1.doSomething();
p2.doSomething();
&lt;/script&gt;
&lt;script&gt;
function Book(name) {
    this.name = name;
}
function Dog(name) {
    this.name = name;
}

var obj1 = new Book(&quot;阿黄&quot;);
var obj2 = new Dog(&quot;阿黄&quot;);

//可以区分对象的类型
//instanceOf  检查某个对象是否是指定构造函数的实例对象（是不是它创建出来）
console.log(obj1 instanceof Book);   //true
console.log(obj2 instanceof Book);  //false
console.log(obj1 instanceof Dog);   //false
console.log(obj2 instanceof Dog);   //true
console.log(obj1 instanceof Object);  //true Object是所有对象的基本对象

//var obj3 = {};
//obj3 是什么类型？
console.log(obj1.constructor);      //Book
console.log(obj2.constructor);      //Dog
&lt;/script&gt;
</code></pre><h3 id="九-函数注意事项02"><a href="#九-函数注意事项02" class="headerlink" title="九:函数注意事项02"></a>九:函数注意事项02</h3><pre><code>01 构造函数必须要和new一起使用，如果直接调用那么无法创建对象
02 this的指向
如果是使用new 构造函数（）调用，那么this---&gt;具体的对象
如果是以普通函数的方式调用吧，那么this ----&gt;window

03 this的丢失问题

&lt;script&gt;

window.name = &quot;xxxxxx&quot;;
var obj = {
    name:&quot;张三&quot;,
    showName:function () {
        console.log(this.name);
    }
}

obj.showName();             //对象.方法  以对象方法的形式来调用函数 （this ---&gt;对象）

var func = obj.showName;
func();   //undefined ? 空  window.name //以普通函数的方式来调用函数（this ---&gt;window）


&lt;/script&gt;
&lt;!--&lt;script&gt;--&gt;
&lt;!--function Dog(name) {--&gt;
    &lt;!--//判断：是否使用new来调用构造函数--&gt;
    &lt;!--//如果使用了new,那么就正常处理，否则就添加上一个new--&gt;
    &lt;!--//默认创建对象并且赋值给this--&gt;
    &lt;!--//if (this != window)--&gt;
    &lt;!--if (this instanceof Dog)--&gt;
    &lt;!--{--&gt;
        &lt;!--this.name = name;--&gt;
        &lt;!--console.log(this,&quot;_______&quot;);--&gt;
    &lt;!--}else--&gt;
    &lt;!--{--&gt;
        &lt;!--return new Dog(name);--&gt;
    &lt;!--}--&gt;

&lt;!--}--&gt;

&lt;!--//01 创建对象--&gt;
&lt;!--var dog1  = new Dog(&quot;阿鲁巴&quot;);--&gt;
&lt;!--var dog2 = Dog(&quot;晓晓&quot;);  //以普通函数的方式来调用构造函数，并不会报错，返回undefined--&gt;

&lt;!--console.log(dog1);--&gt;
&lt;!--console.log(dog2);--&gt;
&lt;!--console.log(window.name);--&gt;
&lt;!--&lt;/script&gt;--&gt;
</code></pre><h3 id="十-构造函数方式创建对象存在的问题"><a href="#十-构造函数方式创建对象存在的问题" class="headerlink" title="十:构造函数方式创建对象存在的问题"></a>十:构造函数方式创建对象存在的问题</h3><pre><code>&lt;script&gt;

//解决思路：把函数抽取到构造函数外部，让多个对象共享同一个函数
function func() {
    console.log(&quot;描述信息&quot;);
}

function Person(name) {
    this.name = name;
    this.showName = function () {
        console.log(this.name);
    };
    this.descriptionLog = func;
}

var p1 = new Person(&quot;张三&quot;);
var p2 = new Person(&quot;张三&quot;);

console.log(p1);
console.log(p2);

p1.showName()
p2.showName();
console.log(p1.showName == p2.showName);        //false
p1.descriptionLog();
p2.descriptionLog();
console.log(p1.descriptionLog == p2.desc riptionLog);

//新的问题：破坏代码的封装性
func();

function func() {
    console.log(&quot;func&quot;)
};

p1.descriptionLog();  //描述信息？（函数提升）

&lt;/script&gt;
</code></pre><h4 id="十一-构造函数的原型对象"><a href="#十一-构造函数的原型对象" class="headerlink" title="十一:构造函数的原型对象"></a>十一:构造函数的原型对象</h4><pre><code>01 什么是原型对象
构造函数有一个默认的相关联的对象，这个对象称为是该构造函数的原型对象
在使用new和构造函数创建对象的时候，内部默认会关联这个新对象的原型对象为当前构造函数的原型对象
这个原型对象默认是一个空的对象

02 原型对象的作用（特点）
构造函数的原型对象 上面的属性和方法 可以被使用该构造函数创建出来的所有对象 所共享

03 如何访问原型对象
001 构造函数.prototype
002 对象.__proto__
003 Object.getPrototype(对象)

04 原型对象的使用：
001 利用对象的动态特性来设置属性和方法
002 直接使用字面量方式替换原型对象

05 约定（说法）
构造函数的原型对象
对象的原型对象
构造函数的原型
对象的原型
&lt;script&gt;
function Person() {

}

console.log(Person.prototype);
Person.prototype = {
    name:&quot;name&quot;
}

var p1 = new Person();
&lt;/script&gt;

使用原型对象解决构造函数方式创建对象的问题
&lt;script&gt;
function Person(name) {
    this.name = name;
}

//设置原型对象
Person.prototype.hi = &quot;hi&quot;;
Person.prototype.showName =  function () {
    console.log(this.name);
};
Person.prototype.descriptionLog = function () {
    console.log(&quot;描述信息&quot;);
}

//创建对象
var p1 = new Person(&quot;张三&quot;);
var p2 = new Person(&quot;张老汉&quot;);
p1.showName();
p2.showName();
p1.descriptionLog();
p2.descriptionLog();
console.log(p1.hi);
console.log(p2.hi);

&lt;/script&gt;
</code></pre><h3 id="十二-实例化和实例"><a href="#十二-实例化和实例" class="headerlink" title="十二:实例化和实例"></a>十二:实例化和实例</h3><pre><code>实例化:
就是使用构造函数创建对象的过程,该过程我们称为实例化

实例:
使用构造函数来创建对象,创建出来的对象就称为这个构造函数的实例.
我们在说实例的时候,需要指明他是哪个构造函数的实例.    
&lt;script&gt;
function Dog(){
}
var dog1 = new Dog();  //实例化的过程
dog1就是Dog这个构造函数的实例.
</code></pre><h3 id="十三-原型的使用方法"><a href="#十三-原型的使用方法" class="headerlink" title="十三:原型的使用方法"></a>十三:原型的使用方法</h3><pre><code>01 利用对象的动态特性
建议:一般情况下,我们会把属性写在对象上面,把方法写在原型上面
&lt;script&gt;
function Car(type,color) {
    this.type = type;
    this.color = color;
}

//设置原型对象的方法
Car.prototype.run = function () {
    console.log(&quot;run&quot;);
}
Car.prototype.desLog = function () {
    console.log(this.type + this.color);
}
//大量的属性|方法
Car.prototype.eat = function () {
    console.log(&quot;eat&quot;);
}
Car.prototype.test1 = function () {
    console.log(&quot;test1&quot;);
}
Car.prototype.demo1 = function () {
    console.log(&quot;demo1&quot;);
}
Car.prototype.friends = [&quot;奥迪&quot;,&quot;奔驰&quot;,&quot;奥拓&quot;];

//创建对象
var car1 = new Car(&quot;奥迪&quot;,&quot;红色&quot;);
var car2 = new Car(&quot;法拉利&quot;,&quot;粉红色&quot;);
console.log(car1);
console.log(car2);
console.log(car1.friends);
console.log(car2.friends);
car1.friends.push(&quot;法拉利未来&quot;);
console.log(car1.friends);
console.log(car2.friends);
&lt;/script&gt;

02 使用字面量的方式直接替换原型对象
&lt;script&gt;
function Person(name) {
    this.name = name;
}

var p1 = new Person(&quot;威整天&quot;);
console.log(p1.hi);      //undefined

//p1.showName();          //威整天
//字面量替换原型对象
Person.prototype = {
    showName:function () {
        console.log(this.name);
    },
    desLog:function () {
        console.log(&quot;秒选信息&quot;);
    },
    hi:&quot;hi&quot;
}

var p2 = new Person(&quot;石破天&quot;);
p2.showName();          //石破天

console.log(p1.hi);      //?

//p1和p2所指向的原型对象并不是同一个
//p1的原型对象是构造函数默认关联的原型对象（空的对象）
//p2的原型对象是{}

&lt;/script&gt;
</code></pre><h3 id="十四-替换原型对象补充"><a href="#十四-替换原型对象补充" class="headerlink" title="十四:替换原型对象补充"></a>十四:替换原型对象补充</h3><pre><code>注意点:
01 注意设置原型对象的位置.建议（在设置完原型对象之后，再统一的创建对象）
02 替换了原型对象之后，需要修正构造器属性 constructor 指向的是创建当前对象的构造函数
    对象中本身并没有constructor属性,该属性是原型对象上面。
&lt;script&gt;
function Person() {
}

//    new Object()
//设置了之后，发现构造器属性指向的是Object而不是Person
Person.prototype = {
    constructor:Person,  //修正构造器属性
    show:function () {
        console.log(&quot;show&quot;);
    }
}

//Person.prototype.constructor ==》Object
//Person.prototype.constructor ==》 Person

var p1 = new Person();
var p2 = new Person();

console.log(p1.constructor == Person);
console.log(p2.constructor == Person);
//获取构造函数的原型对象的构造器属性
console.log(Person.prototype.constructor == Person);
//    Person.prototype.constructor = &quot;hi&quot;;
//    console.log(p1.constructor);
&lt;/script&gt;    
</code></pre><h3 id="十五-原型对象使用的注意点"><a href="#十五-原型对象使用的注意点" class="headerlink" title="十五:原型对象使用的注意点"></a>十五:原型对象使用的注意点</h3><pre><code>01 访问属性 | 方法
访问逻辑：首先先在对象身上查找是否有对应的属性|方法，如果有就直接使用，如果没有那么就查找原型对象
    常用的术语：
        成员：属性 + 方法
        实例成员：实例属性 + 实例方法
        原型成员：原型对象的属性 + 原型对象的方法
 02 设置属性|方法
    通过对象.属性的方式设置的是实例对象的属性
    设置对象的时候，如果是引用类型的，对象.属性.属性是可以设置原型对象的
&lt;script&gt;
function Person(name) {
    this.name = name;
}

Person.prototype = {
    name:&quot;默认的名称&quot;,
    age:20,
    showName:function () {
        console.log(this.name);
    },
    car:{
        type:&quot;火车&quot;,
        color:&quot;黑色&quot;
    }
}

var p = new Person(&quot;张三&quot;);
var p2 = new Person(&quot;李四&quot;);
console.log(p.name);    //张三
console.log(p.age);     //20
p.showName();

//设置属性
p.des = &quot;123&quot;;      //设置在实例对象身上
console.log(p2.des,&quot;___________&quot;);

console.log(p.car);
p.car.type = &quot;飞船&quot;;
console.log(p.car);

p.dog.name = &quot;呼啦哗啦&quot;;
console.log(p.dog.name); //？报错（！）
&lt;/script&gt;
</code></pre><h3 id="十六-proto属性"><a href="#十六-proto属性" class="headerlink" title="十六:proto属性"></a>十六:<strong>proto</strong>属性</h3><pre><code>该属性不是一个标准的属性（ECMA5中没有），ES6中添加了这个属性
在代码中不要出现这个属性，这个属性一般用来调试的.
在之前，该属性是某些浏览器厂商提供（部分浏览器支持）
</code></pre><h3 id="十七-has-Own-Property方法"><a href="#十七-has-Own-Property方法" class="headerlink" title="十七:has Own Property方法"></a>十七:has Own Property方法</h3><pre><code>has Own Property 我自己是否有这个属性(只检查自己的成员)

in 关键字
01 遍历对象
02 判断对象中是否存在指定的属性（实例成员 + 原型成员）

补充：
需求：检查是否存在某个属性，该属性只存在于原型对象中
    001 不是实例对象上面的属性
    002 有这个属性
&lt;script&gt;
function Person(name) {
    this.name = name;
}

Person.prototype.des = &quot;maioshu&quot;;
Person.prototype.name = &quot;maioshu&quot;;

var p1 = new Person(&quot;李四&quot;);
//in 关键字
console.log(&quot;name&quot; in p1);  //true
console.log(&quot;des&quot; in p1);   //true

console.log(p1.hasOwnProperty(&quot;name&quot;)); //true
console.log(p1.hasOwnProperty(&quot;des&quot;)); //false

function onlyPrototypeProp(obj,name) {
    return !obj.hasOwnProperty(name) &amp;&amp; name in obj;
}

console.log(onlyPrototypeProp(p1, &quot;name&quot;));  //false
console.log(onlyPrototypeProp(p1, &quot;des&quot;));  //true
&lt;/script&gt;
</code></pre><h4 id="十八-isPrototypeOf方法"><a href="#十八-isPrototypeOf方法" class="headerlink" title="十八:isPrototypeOf方法"></a>十八:isPrototypeOf方法</h4><pre><code>isPrototypeOf 是否是某个对象的原型对象
Object.getPrototypeOf(对象)
&lt;script&gt;
function Dog() {
}
var demo = {
    name:&quot;测试的名称&quot;
};

Dog.prototype = demo;  //替换原型对象
Dog.prototype.constructor = Dog;

var dog1 = new Dog;  //补充知识：如果构造函数没有传递参数，那么（）可以省略
console.log(dog1);

var abc = {};

console.log(Object.getPrototypeOf(dog1)); 
console.log(abc.isPrototypeOf(dog1));    //false


&lt;/script&gt;
</code></pre>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Bootstrap的笔记]]></title>
      <url>/2016/04/18/bootstrap/</url>
      <content type="html"><![CDATA[<p>##Bootstrap的笔记</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1268909-abc2a99ad3326d8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><strong>1.1   什么是bootstrap?</strong></p>
<p>bootstrap是当下最流行的前端框架（界面工具集);</p>
<p>特点是灵活简介、代码优雅、美观大方；</p>
<p>目的在于让web开发更加迅速、敏捷；</p>
<p>由Twitter公司的两名前端工程师Mark Otto和Jacob Thornton在2011年发起的，并利用业余时间完成了第一个版本的开发。<br><a id="more"></a></p>
<p><strong>1.2    什么是框架？</strong></p>
<p>库 lib library 框架 Framework；</p>
<p>写的更少做的更多 提供一套较为便捷的操作方式；</p>
<p>将一套功能体系封装到一个单独的文件中的东西；</p>
<p>Bootstrap提供一套前端需要的界面工具集合。</p>
<p><strong>1.3    为什么使用Bootstarp？</strong></p>
<p>生态圈火，不断地更新迭代；</p>
<p>提供一套美观大方地界面组件；</p>
<p>提供一套优雅的 HTML+CSS 编码规范；</p>
<p>让我们的 Web 开发更简单，更快捷。</p>
<blockquote>
<p>注意:</p>
<ol>
<li><p>使用 Bootstrap 并不代表不用写 CSS 样式，而是不用写绝大多数大家都会用到的样式</p>
</li>
<li><p>Bootstrap 不是 BootStrap！这是一个词，不是合成词，其含义为：n. 引导指令,引导程序</p>
</li>
</ol>
</blockquote>
<p><strong>1.4    如何使用bootstrap?</strong></p>
<p>下载Bootstrap</p>
<p><a href="https://github.com/twbs/bootstrap/releases/download/v3.3.6/bootstrap-3.3.6-dist.zip" target="_blank" rel="external">https:\/\/github.com\/twbs\/bootstrap\/releases\/download\/v3.3.6\/bootstrap-3.3.6-dist.zip</a>         <a href="https://github.com/twbs/bootstrap/releases/download/v4.0.0-alpha.2/bootstrap-4.0.0-alpha.2-dist.zip" target="_blank" rel="external">https:\/\/github.com\/twbs\/bootstrap\/releases\/download\/v4.0.0-alpha.2\/bootstrap-4.0.0-alpha.2-dist.zip</a></p>
<p><strong>1.5  Bootstrap文档</strong></p>
<p><a href="http://getbootstrap.com/" target="_blank" rel="external">官方文档</a></p>
<p><a href="http://v3.bootcss.com/" target="_blank" rel="external">中文文档</a></p>
<p><strong>1.6   Bootstrap初始化模板</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">    &lt;html lang="en"&gt;</div><div class="line">    &lt;head&gt;</div><div class="line">      &lt;meta charset="UTF-8"&gt;</div><div class="line">      &lt;title&gt;页面标题&lt;/title&gt;</div><div class="line">      &lt;!-- 引入Bootstrap核心样式文件（必须） --&gt;</div><div class="line">      &lt;link rel="stylesheet" href="css/bootstrap.min.css"&gt;</div><div class="line">      &lt;!-- 引入Bootstrap默认主题样式（可选） --&gt;</div><div class="line">      &lt;link rel="stylesheet" href="css/bootstrap.theme.min.css"&gt;</div><div class="line">      &lt;!-- 你自己的样式或其他文件 --&gt;</div><div class="line">      &lt;link rel="stylesheet" href="example.css"&gt;</div><div class="line">    &lt;/head&gt;</div><div class="line">    &lt;body&gt;</div><div class="line">      &lt;!-- 你的HTML结构...... --&gt;</div><div class="line">      &lt;!-- 以下代码，如果不使用JS插件则不需要 --&gt;</div><div class="line">      &lt;!-- 由于Bootstrap的JS插件依赖jQuery，so 引入jQuery --&gt;</div><div class="line">      &lt;script src="js/jquery.min.js"&gt;&lt;/script&gt;</div><div class="line">      &lt;!-- 引入所有的Bootstrap的JS插件 --&gt;</div><div class="line">      &lt;script src="bootstrap.min.js"&gt;&lt;/script&gt;</div><div class="line">      &lt;!-- 你自己的脚本文件 --&gt;</div><div class="line">      &lt;script src="example.js"&gt;&lt;/script&gt;</div><div class="line">    &lt;/body&gt;</div><div class="line">    &lt;/html&gt;</div></pre></td></tr></table></figure>
<p><strong>1.7   Bootstrap相关知识点</strong></p>
<p>（1）Compatible：此属性为文档兼容模式声明，表示如果在IE浏览器下则使用最新的标准渲染当前文档;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</div></pre></td></tr></table></figure>
<p>（2）视口： 此属性为移动端页面视口设置，当前值表示在移动端页面的宽度为设备的宽度，并且不缩放（缩放级别为1）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;</div></pre></td></tr></table></figure>
<p>（3）第三方依赖:</p>
<ul>
<li><p>boostrap的js组件依赖jquery实现 (<a href="https://github.com/jquery/jquery" target="_blank" rel="external">https:\/\/github.com\/jquery\/jquery</a>)</p>
</li>
<li><p>当低版本浏览器不识别新标签时兼容（<a href="https://github.com/aFarkas/html5shiv" target="_blank" rel="external">html5shiv</a>）</p>
</li>
<li><p>让低版本浏览器可以使用CSS的媒体查询 （<a href="https://github.com/scottjehl/Respond" target="_blank" rel="external">respond</a>）</p>
</li>
</ul>
<p>（4）全局CSS样式:</p>
<ul>
<li>修饰已有的标签，比如按钮、文本框之类的</li>
</ul>
<p>（5）组件:   提供一套比较常用的UI组件，比如：按钮、下拉菜单、导航等</p>
<p>[导航](http:\/\/v3.bootcss.com\/components\/#nav)</p>
<p>[导航条](http:\/\/v3.bootcss.com\/components\/#navbar)</p>
<p>[面包屑导航](http:\/\/v3.bootcss.com\/components\/#breadcrumbs)</p>
<p>[下拉菜单](http:\/\/v3.bootcss.com\/components\/#dropdowns)</p>
<p>[按钮式下拉菜单](http:\/\/v3.bootcss.com\/components\/#btn-dropdowns)</p>
<p>[按钮组](http:\/\/v3.bootcss.com\/components\/#btn-groups)</p>
<p>[输入框组](http:\/\/v3.bootcss.com\/components\/#input-groups)</p>
<p>[警告框](http:\/\/v3.bootcss.com\/components\/#alerts)</p>
<p>[页头](http:\/\/v3.bootcss.com\/components\/#page-header)</p>
<p>[分页](http:\/\/v3.bootcss.com\/components\/#pagination)</p>
<p>[列表组](http:\/\/v3.bootcss.com\/components\/#list-group)</p>
<p>[面板](http:\/\/v3.bootcss.com\/components\/#panels)</p>
<p>[媒体对象](http:\/\/v3.bootcss.com\/components\/#media)</p>
<p>[进度条](http:\/\/v3.bootcss.com\/components\/#progress)</p>
<p>[Glyphicons](http:\/\/v3.bootcss.com\/components\/#glyphicons)</p>
<p>[标签](http:\/\/v3.bootcss.com\/components\/#labels)</p>
<p>[徽章](http:\/\/v3.bootcss.com\/components\/#badges)</p>
<p>[缩略图](http:\/\/v3.bootcss.com\/components\/#thumbnails)</p>
<p>[大屏幕](http:\/\/v3.bootcss.com\/components\/#jumbotron)</p>
<p>[嵌入内容](http:\/\/v3.bootcss.com\/components\/#responsive-embed)</p>
<p>[内嵌](http:\/\/v3.bootcss.com\/components\/#wells)</p>
<p>（6）JavaScript插件:   开发中常用的特效继承，依赖于jQuery</p>
<p>[模态对话框](http:\/\/v3.bootcss.com\/javascript\/#modals)</p>
<p>[下拉菜单](http:\/\/v3.bootcss.com\/javascript\/#dropdowns)</p>
<p>[滚动监听](http:\/\/v3.bootcss.com\/javascript\/#scrollspy)</p>
<p>[标签页](http:\/\/v3.bootcss.com\/javascript\/#tabs)</p>
<p>[工具提示](http:\/\/v3.bootcss.com\/javascript\/#tooltips)</p>
<p>[弹出框](http:\/\/v3.bootcss.com\/javascript\/#popovers)</p>
<p>[警告框](http:\/\/v3.bootcss.com\/javascript\/#alerts)</p>
<p>[按钮](http:\/\/v3.bootcss.com\/javascript\/#buttons)</p>
<p>[折叠面板](http:\/\/v3.bootcss.com\/javascript\/#collapse)</p>
<p>[轮播图](http:\/\/v3.bootcss.com\/javascript\/#carousel)</p>
<p>[吸顶效果](http:\/\/v3.bootcss.com\/javascript\/#affix)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">data-spy=&quot;affix&quot;</div><div class="line"></div><div class="line">data-offset-top=&quot;什么位置出现&quot;</div><div class="line"></div><div class="line">data-offset-bottom=&quot;什么位置消失&quot;</div></pre></td></tr></table></figure>
<pre><code>&lt;!--
    兼容的
    IE = edge:告诉浏览器以最新的解析器来解析代码
--&gt;
&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
</code></pre><p>快捷打出视口–&gt;mate:vp加tab键</p>
<pre><code>  &lt;!--device-width:动态布置
     user-scalable  是否允许缩放  不允许
     让wap App 更加接近原生
--&gt;
&lt;meta name=&quot;viewport&quot;
      content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;
&lt;!--
    PC端-&gt;移动互联网的兴起-&gt;app
    PC-&gt;网站(网页)-&gt;手机端(web )
--&gt;

 &lt;!--
    Bootstrap  兼容到IE8
    HTML5 标签  &lt;head&gt; &lt;section&gt; &lt;footer&gt;
    CSS的属性   媒体查询

    html5shiv  让IE8的解析器能够识别html5的新标签
      respond  css3
      JS是用于处理一些标签的或者处理一些样式的导入在前面
    --&gt;
&lt;!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries --&gt;
&lt;!-- WARNING: Respond.js doesn&apos;t work if you view the page via file:// --&gt;
&lt;!--[if lt IE 9]&gt;
&lt;script src=&quot;https://cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js&quot;&gt;&lt;/script&gt;
</code></pre><p>字体图标 矢量的字</p>
<p>sr-only:屏幕阅读器,盲文.读出来<br>全称是 screen reader only，意为：（仅供）屏幕阅读器，这个 class 主要用于增强 accessbility（可访问性）。</p>
<p>##站点图标<br>link:favicon来引入</p>
<p>自定义字体图标:醉牛前端下的<br><img src="http://i.imgur.com/0YwMuum.png" alt=""></p>
<p>###定义类名一般是<br>tab-title</p>
<p>###定义id一般是<br>tab_title</p>
<p>##按钮样式生成</p>
<p><a href="http://blog.koalite.com//bbg//" target="_blank" rel="external">http://blog.koalite.com//bbg//</a></p>
<p>##新闻中心区域</p>
<p>涉及要点:栅(shan)格偏移<br>栅(zan)栏;</p>
]]></content>
      
        
        <tags>
            
            <tag> 前端  bootstrap </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
